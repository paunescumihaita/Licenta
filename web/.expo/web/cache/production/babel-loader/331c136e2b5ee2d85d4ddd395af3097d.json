{"ast":null,"code":"var _interopRequireWildcard=require(\"@babel/runtime/helpers/interopRequireWildcard\");var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.default=void 0;var _classCallCheck2=_interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));var _createClass2=_interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));var _assertThisInitialized2=_interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));var _inherits2=_interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));var _possibleConstructorReturn2=_interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));var _getPrototypeOf2=_interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));var React=_interopRequireWildcard(require(\"react\"));var _reactNative=require(\"react-native\");function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=(0,_getPrototypeOf2.default)(Derived),result;if(hasNativeReflectConstruct){var NewTarget=(0,_getPrototypeOf2.default)(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return(0,_possibleConstructorReturn2.default)(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}var KeyboardManager=function(_React$Component){(0,_inherits2.default)(KeyboardManager,_React$Component);var _super=_createSuper(KeyboardManager);function KeyboardManager(){var _this;(0,_classCallCheck2.default)(this,KeyboardManager);for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_super.call.apply(_super,[this].concat(args));_defineProperty((0,_assertThisInitialized2.default)(_this),\"previouslyFocusedTextInput\",undefined);_defineProperty((0,_assertThisInitialized2.default)(_this),\"startTimestamp\",0);_defineProperty((0,_assertThisInitialized2.default)(_this),\"keyboardTimeout\",void 0);_defineProperty((0,_assertThisInitialized2.default)(_this),\"clearKeyboardTimeout\",function(){if(_this.keyboardTimeout!==undefined){clearTimeout(_this.keyboardTimeout);_this.keyboardTimeout=undefined;}});_defineProperty((0,_assertThisInitialized2.default)(_this),\"handlePageChangeStart\",function(){if(!_this.props.enabled){return;}_this.clearKeyboardTimeout();var input=_reactNative.TextInput.State.currentlyFocusedInput?_reactNative.TextInput.State.currentlyFocusedInput():_reactNative.TextInput.State.currentlyFocusedField();_reactNative.TextInput.State.blurTextInput(input);_this.previouslyFocusedTextInput=input;_this.startTimestamp=Date.now();});_defineProperty((0,_assertThisInitialized2.default)(_this),\"handlePageChangeConfirm\",function(force){if(!_this.props.enabled){return;}_this.clearKeyboardTimeout();if(force){_reactNative.Keyboard.dismiss();}else{var input=_this.previouslyFocusedTextInput;if(input){_reactNative.TextInput.State.blurTextInput(input);}}_this.previouslyFocusedTextInput=undefined;});_defineProperty((0,_assertThisInitialized2.default)(_this),\"handlePageChangeCancel\",function(){if(!_this.props.enabled){return;}_this.clearKeyboardTimeout();var input=_this.previouslyFocusedTextInput;if(input){if(Date.now()-_this.startTimestamp<100){_this.keyboardTimeout=setTimeout(function(){_reactNative.TextInput.State.focusTextInput(input);_this.previouslyFocusedTextInput=undefined;},100);}else{_reactNative.TextInput.State.focusTextInput(input);_this.previouslyFocusedTextInput=undefined;}}});return _this;}(0,_createClass2.default)(KeyboardManager,[{key:\"componentWillUnmount\",value:function componentWillUnmount(){this.clearKeyboardTimeout();}},{key:\"render\",value:function render(){return this.props.children({onPageChangeStart:this.handlePageChangeStart,onPageChangeConfirm:this.handlePageChangeConfirm,onPageChangeCancel:this.handlePageChangeCancel});}}]);return KeyboardManager;}(React.Component);exports.default=KeyboardManager;","map":{"version":3,"sources":["KeyboardManager.tsx"],"names":["React","componentWillUnmount","clearTimeout","input","TextInput","Date","force","Keyboard","setTimeout","render","onPageChangeStart","onPageChangeConfirm","onPageChangeCancel","handlePageChangeCancel"],"mappings":"8zBAAA,oDACA,yC,i5BAae,CAAA,e,8HAAqD,0BAAA,4FAAA,IAAA,0CAAA,IAAA,wBAAA,6CAAA,IAAA,GAAA,eAAA,4CAAA,4BAAA,CAAA,SAAA,CAAA,CAAA,eAAA,4CAAA,gBAAA,CAAA,CAAA,CAAA,CAAA,eAAA,4CAAA,iBAAA,CAAA,IAAA,EAAA,CAAA,CAAA,eAAA,4CAAA,sBAAA,CAWnC,UAAM,CACnC,GAAI,MAAA,eAAA,GAAJ,SAAA,CAAwC,CACtCE,YAAY,CAAC,MAAbA,eAAY,CAAZA,CACA,MAAA,eAAA,CAAA,SAAA,CACD,CAf+D,CAAA,CAAA,CAAA,eAAA,4CAAA,uBAAA,CAkBlC,UAAM,CACpC,GAAI,CAAC,MAAA,KAAA,CAAL,OAAA,CAAyB,CACvB,OACD,CAED,MALoC,oBAKpC,GAGA,GAAMC,CAAAA,KAAe,CAAGC,uBAAAA,KAAAA,CAAAA,qBAAAA,CACpBA,uBAAAA,KAAAA,CADoBA,qBACpBA,EADoBA,CAEpBA,uBAAAA,KAAAA,CAVgC,qBAUhCA,EAFJ,CAKAA,uBAAAA,KAAAA,CAAAA,aAAAA,CAboC,KAapCA,EAGA,MAAA,0BAAA,CAhBoC,KAgBpC,CAGA,MAAA,cAAA,CAAsBC,IAAI,CAA1B,GAAsBA,EAAtB,CArCgE,CAAA,CAAA,CAAA,eAAA,4CAAA,yBAAA,CAwC/BC,SAAAA,KAAD,CAAoB,CACpD,GAAI,CAAC,MAAA,KAAA,CAAL,OAAA,CAAyB,CACvB,OACD,CAED,MAAA,oBAAA,GAEA,GAAA,KAAA,CAAW,CAITC,sBAAAA,OAAAA,GAJF,CAAA,IAKO,CACL,GAAMJ,CAAAA,KAAK,CAAG,MAAd,0BAAA,CAEA,GAAA,KAAA,CAAW,CAGTC,uBAAAA,KAAAA,CAAAA,aAAAA,CAAAA,KAAAA,EACD,CAnBiD,CAuBpD,MAAA,0BAAA,CAAA,SAAA,CA/DgE,CAAA,CAAA,CAAA,eAAA,4CAAA,wBAAA,CAkEjC,UAAM,CACrC,GAAI,CAAC,MAAA,KAAA,CAAL,OAAA,CAAyB,CACvB,OACD,CAED,MALqC,oBAKrC,GAGA,GAAMD,CAAAA,KAAK,CAAG,MAAd,0BAAA,CAEA,GAAA,KAAA,CAAW,CAQT,GAAIE,IAAI,CAAJA,GAAAA,GAAa,MAAbA,cAAAA,CAAJ,GAAA,CAA4C,CAC1C,MAAA,eAAA,CAAuBG,UAAU,CAAC,UAAM,CACtCJ,uBAAAA,KAAAA,CAAAA,cAAAA,CAAAA,KAAAA,EACA,MAAA,0BAAA,CAAA,SAAA,CAF+B,CAAA,CAAjC,GAAiC,CAAjC,CADF,CAAA,IAKO,CACLA,uBAAAA,KAAAA,CAAAA,cAAAA,CAAAA,KAAAA,EACA,MAAA,0BAAA,CAAA,SAAA,CACD,CACF,CA7F+D,CAAA,CAAA,CAAA,aAAA,C,6EAClEH,+BAAuB,CACrB,KAAA,oBAAA,GAFgE,C,sBAgGlEQ,iBAAS,CACP,MAAO,MAAA,KAAA,CAAA,QAAA,CAAoB,CACzBC,iBAAiB,CAAE,KADM,qBAAA,CAEzBC,mBAAmB,CAAE,KAFI,uBAAA,CAGzBC,kBAAkB,CAAE,KAAKC,sBAHA,CAApB,CAAP,CAKD,C,6BAtG0Cb,KAAK,CAAnC,S","sourcesContent":["import * as React from 'react';\nimport { TextInput, Keyboard, HostComponent } from 'react-native';\n\ntype Props = {\n  enabled: boolean;\n  children: (props: {\n    onPageChangeStart: () => void;\n    onPageChangeConfirm: (force: boolean) => void;\n    onPageChangeCancel: () => void;\n  }) => React.ReactNode;\n};\n\ntype InputRef = React.ElementRef<HostComponent<unknown>> | undefined;\n\nexport default class KeyboardManager extends React.Component<Props> {\n  componentWillUnmount() {\n    this.clearKeyboardTimeout();\n  }\n\n  // Numeric id of the previously focused text input\n  // When a gesture didn't change the tab, we can restore the focused input with this\n  private previouslyFocusedTextInput: InputRef = undefined;\n  private startTimestamp: number = 0;\n  private keyboardTimeout: any;\n\n  private clearKeyboardTimeout = () => {\n    if (this.keyboardTimeout !== undefined) {\n      clearTimeout(this.keyboardTimeout);\n      this.keyboardTimeout = undefined;\n    }\n  };\n\n  private handlePageChangeStart = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    // @ts-expect-error: blurTextInput accepts both number and ref, but types say only ref\n    const input: InputRef = TextInput.State.currentlyFocusedInput\n      ? TextInput.State.currentlyFocusedInput()\n      : TextInput.State.currentlyFocusedField();\n\n    // When a page change begins, blur the currently focused input\n    TextInput.State.blurTextInput(input);\n\n    // Store the id of this input so we can refocus it if change was cancelled\n    this.previouslyFocusedTextInput = input;\n\n    // Store timestamp for touch start\n    this.startTimestamp = Date.now();\n  };\n\n  private handlePageChangeConfirm = (force: boolean) => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    if (force) {\n      // Always dismiss input, even if we don't have a ref to it\n      // We might not have the ref if onPageChangeStart was never called\n      // This can happen if page change was not from a gesture\n      Keyboard.dismiss();\n    } else {\n      const input = this.previouslyFocusedTextInput;\n\n      if (input) {\n        // Dismiss the keyboard only if an input was a focused before\n        // This makes sure we don't dismiss input on going back and focusing an input\n        TextInput.State.blurTextInput(input);\n      }\n    }\n\n    // Cleanup the ID on successful page change\n    this.previouslyFocusedTextInput = undefined;\n  };\n\n  private handlePageChangeCancel = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    // The page didn't change, we should restore the focus of text input\n    const input = this.previouslyFocusedTextInput;\n\n    if (input) {\n      // If the interaction was super short we should make sure keyboard won't hide again.\n\n      // Too fast input refocus will result only in keyboard flashing on screen and hiding right away.\n      // During first ~100ms keyboard will be dismissed no matter what,\n      // so we have to make sure it won't interrupt input refocus logic.\n      // That's why when the interaction is shorter than 100ms we add delay so it won't hide once again.\n      // Subtracting timestamps makes us sure the delay is executed only when needed.\n      if (Date.now() - this.startTimestamp < 100) {\n        this.keyboardTimeout = setTimeout(() => {\n          TextInput.State.focusTextInput(input);\n          this.previouslyFocusedTextInput = undefined;\n        }, 100);\n      } else {\n        TextInput.State.focusTextInput(input);\n        this.previouslyFocusedTextInput = undefined;\n      }\n    }\n  };\n\n  render() {\n    return this.props.children({\n      onPageChangeStart: this.handlePageChangeStart,\n      onPageChangeConfirm: this.handlePageChangeConfirm,\n      onPageChangeCancel: this.handlePageChangeCancel,\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}
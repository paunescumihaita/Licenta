"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const child_process_1 = require("child_process");
const path_1 = __importDefault(require("path"));
const wrap_ansi_1 = __importDefault(require("wrap-ansi"));
const internal_1 = require("./internal");
const forks = {};
function parseMessageJson(data) {
    const stringData = data.toString();
    try {
        return JSON.parse(stringData);
    }
    catch (e) {
        internal_1.Logger.global.debug('Failed to parse simctl JSON message:\n' + stringData);
    }
    return null;
}
// There are a lot of networking logs in RN that aren't relevant to the user.
function isNetworkLog(simLog) {
    var _a;
    return (simLog.subsystem === 'com.apple.network' ||
        simLog.category === 'connection' ||
        ((_a = simLog.source) === null || _a === void 0 ? void 0 : _a.image) === 'CFNetwork');
}
function isReactLog(simLog) {
    var _a;
    return simLog.subsystem === 'com.facebook.react.log' && ((_a = simLog.source) === null || _a === void 0 ? void 0 : _a.file) === 'RCTLog.mm';
}
// It's not clear what these are but they aren't very useful.
// (The connection to service on pid 0 named com.apple.commcenter.coretelephony.xpc was invalidated)
// We can add them later if need.
function isCoreTelephonyLog(simLog) {
    // [CoreTelephony] Updating selectors failed with: Error Domain=NSCocoaErrorDomain Code=4099
    // "The connection to service on pid 0 named com.apple.commcenter.coretelephony.xpc was invalidated." UserInfo={NSDebugDescription=The connection to service on pid 0 named com.apple.commcenter.coretelephony.xpc was invalidated.}
    return simLog.subsystem === 'com.apple.CoreTelephony';
}
// https://stackoverflow.com/a/65313219/4047926
function isWebKitLog(simLog) {
    // [WebKit] 0x1143ca500 - ProcessAssertion: Failed to acquire RBS Background assertion 'WebProcess Background Assertion' for process with PID 27084, error: Error Domain=RBSAssertionErrorDomain Code=3 "Target is not running or required target
    // entitlement is missing" UserInfo={RBSAssertionAttribute=<RBSDomainAttribute| domain:"com.apple.webkit" name:"Background" sourceEnvironment:"(null)">, NSLocalizedFailureReason=Target is not running or required target entitlement is missing}
    return simLog.subsystem === 'com.apple.WebKit';
}
// Similar to WebKit logs
function isRunningBoardServicesLog(simLog) {
    // [RunningBoardServices] Error acquiring assertion: <Error Domain=RBSAssertionErrorDomain Code=3 "Target is not running or required target entitlement is missing" UserInfo={RBSAssertionAttribute=<RBSDomainAttribute| domain:"com.apple.webkit"
    // name:"Background" sourceEnvironment:"(null)">, NSLocalizedFailureReason=Target is not running or required target entitlement is missing}>
    return simLog.subsystem === 'com.apple.runningboard';
}
function formatMessage(simLog) {
    var _a, _b;
    // TODO: Maybe change "TCC" to "Consent" or "System".
    const category = chalk_1.default.gray(`[${(_b = (_a = simLog.source) === null || _a === void 0 ? void 0 : _a.image) !== null && _b !== void 0 ? _b : simLog.subsystem}]`);
    const message = simLog.eventMessage;
    return wrap_ansi_1.default(category + ' ' + message, process.stdout.columns || 80);
}
function onMessage(simLog) {
    var _a;
    let hasLogged = false;
    if (simLog.messageType === 'Error') {
        if (
        // Hide all networking errors which are mostly useless.
        !isNetworkLog(simLog) &&
            // Showing React errors will result in duplicate messages.
            !isReactLog(simLog) &&
            !isCoreTelephonyLog(simLog) &&
            !isWebKitLog(simLog) &&
            !isRunningBoardServicesLog(simLog)) {
            hasLogged = true;
            // Sim: This app has crashed because it attempted to access privacy-sensitive data without a usage description.  The app's Info.plist must contain an NSCameraUsageDescription key with a string value explaining to the user how the app uses this data.
            internal_1.Logger.global.error(formatMessage(simLog));
        }
    }
    else if (simLog.eventMessage) {
        // If the source has a file (i.e. not a system log).
        if (((_a = simLog.source) === null || _a === void 0 ? void 0 : _a.file) ||
            simLog.eventMessage.includes('Terminating app due to uncaught exception')) {
            hasLogged = true;
            internal_1.Logger.global.info(formatMessage(simLog));
        }
    }
    if (!hasLogged) {
        internal_1.Logger.global.debug(formatMessage(simLog));
    }
    else {
        // console.log('DATA:', JSON.stringify(simLog));
    }
}
exports.onMessage = onMessage;
// The primary purpose of this module is to surface logs related to fatal app crashes.
// Everything else should come through the native React logger.
function streamLogs({ pid, udid }) {
    // Prevent adding a duplicate listener.
    // This only works because our current usage of SimControlLogs only allows for one possible `pid` to be used.
    // If in the future, you can attach logs to two different apps from the same process, then this will need to be changed.
    if (forks[udid]) {
        return;
    }
    // xcrun simctl spawn booted log stream --process --style json
    const childProcess = child_process_1.spawn('xcrun', [
        'simctl',
        'spawn',
        udid,
        'log',
        'stream',
        '--process',
        pid,
        // ndjson provides a better format than json.
        '--style',
        'ndjson',
        // Provide the source so we can filter logs better
        '--source',
        // log, activity, trace -- activity was related to layouts, trace didn't work, so that leaves log.
        // Passing nothing combines all three, but we don't use activity.
        '--type',
        'log',
        // backtrace doesn't seem very useful in basic cases.
        // TODO: Maybe we can format as a stack trace for native errors.
        '--no-backtrace',
    ]);
    childProcess.stdout.on('data', (data) => {
        const simLog = parseMessageJson(data);
        if (!simLog) {
            return;
        }
        onMessage(simLog);
    });
    childProcess.on('error', ({ message }) => {
        internal_1.Logger.global.debug('[simctl error]:', message);
    });
    forks[udid] = childProcess;
    // Ensure the process is removed.
    ensureExitHooksInstalled();
}
exports.streamLogs = streamLogs;
async function detachStream(udid) {
    if (forks[udid]) {
        await killProcess(forks[udid]);
        delete forks[udid];
    }
}
exports.detachStream = detachStream;
let hasInstalledExitHooks = false;
function ensureExitHooksInstalled() {
    if (hasInstalledExitHooks)
        return;
    hasInstalledExitHooks = true;
    const killSignals = ['SIGINT', 'SIGTERM'];
    for (const signal of killSignals) {
        process.on(signal, async () => {
            await Promise.all(Object.keys(forks).map(udid => detachStream(udid)));
        });
    }
}
async function killProcess(childProcess) {
    if (childProcess) {
        return new Promise(resolve => {
            childProcess.on('close', resolve);
            childProcess.kill();
        });
    }
}
/**
 *
 * @param udid
 * @param bundleIdentifier
 * @returns Image name like `Exponent` and `null` when the app is not installed on the provided simulator.
 */
async function getImageNameFromBundleIdentifierAsync(udid, bundleIdentifier) {
    const containerPath = await internal_1.SimControl.getContainerPathAsync(udid, bundleIdentifier);
    if (containerPath) {
        return getImageNameFromContainerPath(containerPath);
    }
    return null;
}
exports.getImageNameFromBundleIdentifierAsync = getImageNameFromBundleIdentifierAsync;
function getImageNameFromContainerPath(binaryPath) {
    return path_1.default.basename(binaryPath).split('.')[0];
}
exports.getImageNameFromContainerPath = getImageNameFromContainerPath;
//# sourceMappingURL=SimControlLogs.js.map
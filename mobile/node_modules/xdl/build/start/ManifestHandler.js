"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("@expo/config");
const chalk_1 = __importDefault(require("chalk"));
const os_1 = __importDefault(require("os"));
const url_1 = require("url");
const internal_1 = require("../internal");
const _cachedSignedManifest = {
    manifestString: null,
    signedManifest: null,
};
const blacklistedEnvironmentVariables = new Set([
    'EXPO_APPLE_PASSWORD',
    'EXPO_ANDROID_KEY_PASSWORD',
    'EXPO_ANDROID_KEYSTORE_PASSWORD',
    'EXPO_IOS_DIST_P12_PASSWORD',
    'EXPO_IOS_PUSH_P12_PASSWORD',
    'EXPO_CLI_PASSWORD',
]);
function shouldExposeEnvironmentVariableInManifest(key) {
    if (blacklistedEnvironmentVariables.has(key.toUpperCase())) {
        return false;
    }
    return key.startsWith('REACT_NATIVE_') || key.startsWith('EXPO_');
}
function stripPort(host) {
    if (!host) {
        return host;
    }
    return new url_1.URL('/', `http://${host}`).hostname;
}
async function getPackagerOptionsAsync(projectRoot) {
    // Get packager opts and then copy into bundleUrlPackagerOpts
    const projectSettings = await internal_1.ProjectSettings.readAsync(projectRoot);
    const bundleUrlPackagerOpts = JSON.parse(JSON.stringify(projectSettings));
    bundleUrlPackagerOpts.urlType = 'http';
    if (bundleUrlPackagerOpts.hostType === 'redirect') {
        bundleUrlPackagerOpts.hostType = 'tunnel';
    }
    return [projectSettings, bundleUrlPackagerOpts];
}
async function getBundleUrlAsync({ projectRoot, platform, projectSettings, bundleUrlPackagerOpts, mainModuleName, hostname, }) {
    const queryParams = internal_1.UrlUtils.constructBundleQueryParams(projectRoot, projectSettings);
    const path = `/${encodeURI(mainModuleName)}.bundle?platform=${encodeURIComponent(platform)}&${queryParams}`;
    return ((await internal_1.UrlUtils.constructBundleUrlAsync(projectRoot, bundleUrlPackagerOpts, hostname)) + path);
}
function getPlatformFromRequest(headers) {
    return (headers['exponent-platform'] || 'ios').toString();
}
function getManifestHandler(projectRoot) {
    return async (req, res) => {
        var _a;
        try {
            // We intentionally don't `await`. We want to continue trying even
            // if there is a potential error in the package.json and don't want to slow
            // down the request
            internal_1.Doctor.validateWithNetworkAsync(projectRoot).catch(error => {
                internal_1.ProjectUtils.logError(projectRoot, 'expo', `Error: could not load config json at ${projectRoot}: ${error.toString()}`, 'doctor-config-json-not-read');
            });
            const { manifestString, exp, hostInfo } = await getManifestResponseFromHeadersAsync({
                projectRoot,
                headers: req.headers,
            });
            const sdkVersion = (_a = exp.sdkVersion) !== null && _a !== void 0 ? _a : null;
            // Send the response
            res.setHeader('Exponent-Server', JSON.stringify(hostInfo));
            // End the request
            res.end(manifestString);
            // Log analytics
            internal_1.Analytics.logEvent('Serve Manifest', {
                projectRoot,
                developerTool: internal_1.Config.developerTool,
                sdkVersion,
            });
        }
        catch (e) {
            internal_1.ProjectUtils.logError(projectRoot, 'expo', e.stack);
            // 5xx = Server Error HTTP code
            res.statusCode = 520;
            res.end(JSON.stringify({
                error: e.toString(),
            }));
        }
    };
}
exports.getManifestHandler = getManifestHandler;
async function getManifestResponseFromHeadersAsync({ projectRoot, headers, }) {
    // Read from headers
    const platform = getPlatformFromRequest(headers);
    const acceptSignature = headers['exponent-accept-signature'];
    return getManifestResponseAsync({ projectRoot, host: headers.host, platform, acceptSignature });
}
async function getManifestResponseAsync({ projectRoot, host, platform, acceptSignature, }) {
    // Read the config
    const projectConfig = config_1.getConfig(projectRoot);
    const manifest = projectConfig.exp;
    // Read from headers
    const hostname = stripPort(host);
    // Get project entry point and initial module
    const entryPoint = internal_1.resolveEntryPoint(projectRoot, platform, projectConfig);
    const mainModuleName = internal_1.UrlUtils.stripJSExtension(entryPoint);
    // Gather packager and host info
    const hostInfo = await createHostInfoAsync();
    const [projectSettings, bundleUrlPackagerOpts] = await getPackagerOptionsAsync(projectRoot);
    // Mutate the manifest
    manifest.xde = true; // deprecated
    manifest.developer = {
        tool: internal_1.Config.developerTool,
        projectRoot,
    };
    manifest.packagerOpts = projectSettings;
    manifest.mainModuleName = mainModuleName;
    // Adding the env variables to the Expo manifest is unsafe.
    // This feature is deprecated in SDK 41 forward.
    if (manifest.sdkVersion && internal_1.Versions.lteSdkVersion(manifest, '40.0.0')) {
        manifest.env = getManifestEnvironment();
    }
    // Add URLs to the manifest
    manifest.bundleUrl = await getBundleUrlAsync({
        projectRoot,
        platform,
        projectSettings,
        bundleUrlPackagerOpts,
        mainModuleName,
        hostname,
    });
    manifest.debuggerHost = await internal_1.UrlUtils.constructDebuggerHostAsync(projectRoot, hostname);
    manifest.logUrl = await internal_1.UrlUtils.constructLogUrlAsync(projectRoot, hostname);
    manifest.hostUri = await internal_1.UrlUtils.constructHostUriAsync(projectRoot, hostname);
    // Resolve all assets and set them on the manifest as URLs
    await internal_1.ProjectAssets.resolveManifestAssets({
        projectRoot,
        manifest: manifest,
        async resolver(path) {
            return manifest.bundleUrl.match(/^https?:\/\/.*?\//)[0] + 'assets/' + path;
        },
    });
    // The server normally inserts this but if we're offline we'll do it here
    await internal_1.ProjectAssets.resolveGoogleServicesFile(projectRoot, manifest);
    // Create the final string
    let manifestString;
    try {
        manifestString = await getManifestStringAsync(manifest, hostInfo.host, acceptSignature);
    }
    catch (error) {
        if (error.code === 'UNAUTHORIZED_ERROR' && manifest.owner) {
            // Don't have permissions for siging, warn and enable offline mode.
            addSigningDisabledWarning(projectRoot, `This project belongs to ${chalk_1.default.bold(`@${manifest.owner}`)} and you have not been granted the appropriate permissions.\n` +
                `Please request access from an admin of @${manifest.owner} or change the "owner" field to an account you belong to.\n` +
                internal_1.learnMore('https://docs.expo.io/versions/latest/config/app/#owner'));
            internal_1.Config.offline = true;
            manifestString = await getManifestStringAsync(manifest, hostInfo.host, acceptSignature);
        }
        else if (error.code === 'ENOTFOUND') {
            // Got a DNS error, i.e. can't access exp.host, warn and enable offline mode.
            addSigningDisabledWarning(projectRoot, `Could not reach Expo servers, please check if you can access ${error.hostname || 'exp.host'}.`);
            internal_1.Config.offline = true;
            manifestString = await getManifestStringAsync(manifest, hostInfo.host, acceptSignature);
        }
        else {
            throw error;
        }
    }
    return {
        manifestString,
        exp: manifest,
        hostInfo,
    };
}
exports.getManifestResponseAsync = getManifestResponseAsync;
const addSigningDisabledWarning = (() => {
    let seen = false;
    return (projectRoot, reason) => {
        if (!seen) {
            seen = true;
            internal_1.ProjectUtils.logWarning(projectRoot, 'expo', `${reason}\nFalling back to offline mode.`, 'signing-disabled');
        }
    };
})();
function getManifestEnvironment() {
    return Object.keys(process.env).reduce((prev, key) => {
        if (shouldExposeEnvironmentVariableInManifest(key)) {
            prev[key] = process.env[key];
        }
        return prev;
    }, {});
}
async function getManifestStringAsync(manifest, hostUUID, acceptSignature) {
    const currentSession = await internal_1.UserManager.getSessionAsync();
    if (!currentSession || internal_1.Config.offline) {
        manifest.id = `@${internal_1.ANONYMOUS_USERNAME}/${manifest.slug}-${hostUUID}`;
    }
    if (!acceptSignature) {
        return JSON.stringify(manifest);
    }
    else if (!currentSession || internal_1.Config.offline) {
        return getUnsignedManifestString(manifest);
    }
    else {
        return await getSignedManifestStringAsync(manifest, currentSession);
    }
}
async function createHostInfoAsync() {
    const host = await internal_1.UserSettings.anonymousIdentifier();
    return {
        host,
        server: 'xdl',
        serverVersion: require('xdl/package.json').version,
        serverDriver: internal_1.Config.developerTool,
        serverOS: os_1.default.platform(),
        serverOSVersion: os_1.default.release(),
    };
}
async function getSignedManifestStringAsync(manifest, 
// NOTE: we currently ignore the currentSession that is passed in, see the note below about analytics.
currentSession) {
    var _a;
    const manifestString = JSON.stringify(manifest);
    if (_cachedSignedManifest.manifestString === manifestString) {
        return _cachedSignedManifest.signedManifest;
    }
    // WARNING: Removing the following line will regress analytics, see: https://github.com/expo/expo-cli/pull/2357
    // TODO: make this more obvious from code
    const user = await internal_1.UserManager.ensureLoggedInAsync();
    const { response } = await internal_1.ApiV2.clientForUser(user).postAsync('manifest/sign', {
        args: {
            remoteUsername: (_a = manifest.owner) !== null && _a !== void 0 ? _a : (await internal_1.UserManager.getCurrentUsernameAsync()),
            remotePackageName: manifest.slug,
        },
        manifest: manifest,
    });
    _cachedSignedManifest.manifestString = manifestString;
    _cachedSignedManifest.signedManifest = response;
    return response;
}
exports.getSignedManifestStringAsync = getSignedManifestStringAsync;
function getUnsignedManifestString(manifest) {
    const unsignedManifest = {
        manifestString: JSON.stringify(manifest),
        signature: 'UNSIGNED',
    };
    return JSON.stringify(unsignedManifest);
}
exports.getUnsignedManifestString = getUnsignedManifestString;
//# sourceMappingURL=ManifestHandler.js.map
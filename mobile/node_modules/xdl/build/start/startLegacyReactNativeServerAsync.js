"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("@expo/config");
const paths_1 = require("@expo/config/paths");
const axios_1 = __importDefault(require("axios"));
const child_process_1 = __importDefault(require("child_process"));
const escapeRegExp_1 = __importDefault(require("lodash/escapeRegExp"));
const path_1 = __importDefault(require("path"));
const resolve_from_1 = __importDefault(require("resolve-from"));
const split_1 = __importDefault(require("split"));
const tree_kill_1 = __importDefault(require("tree-kill"));
const util_1 = require("util");
const internal_1 = require("../internal");
const treekillAsync = util_1.promisify(tree_kill_1.default);
// The --verbose flag is intended for react-native-cli/metro, not expo-cli
const METRO_VERBOSE_WARNING = 'Run CLI with --verbose flag for more details.';
// Remove these constants and related code when SDK35 isn't supported anymore
// Context: https://github.com/expo/expo-cli/issues/1074
const NODE_12_WINDOWS_METRO_ERROR = `Invalid regular expression: /(.*\\__fixtures__\\.*|node_modules[\\]react[\\]dist[\\].*|website\\node_modules\\.*|heapCapture\\bundle.js|.*\\__tests__\\.*)$/: Unterminated character class`;
const NODE_12_WINDOWS_METRO_SUGGESTION = `\nUnable to start the project due to a documented incompatibility between Node 12 LTS and Expo SDK 35 on Windows.
Please refer to this GitHub comment for a solution:
https://github.com/expo/expo-cli/issues/1074#issuecomment-559220752\n`;
function _logPackagerOutput(projectRoot, level, data) {
    let output = data.toString();
    if (!output) {
        return;
    }
    // Temporarily hide warnings about duplicate providesModule declarations
    // under react-native
    if (_isIgnorableDuplicateModuleWarning(projectRoot, level, output)) {
        internal_1.ProjectUtils.logDebug(projectRoot, 'expo', `Suppressing @providesModule warning: ${output}`, 'project-suppress-providesmodule-warning');
        return;
    }
    if (_isIgnorableMetroConsoleOutput(output) || _isIgnorableRnpmWarning(output)) {
        internal_1.ProjectUtils.logDebug(projectRoot, 'expo', output);
        return;
    }
    if (output.includes(NODE_12_WINDOWS_METRO_ERROR)) {
        internal_1.ProjectUtils.logError(projectRoot, 'expo', NODE_12_WINDOWS_METRO_SUGGESTION);
        return;
    }
    if (output.includes(METRO_VERBOSE_WARNING)) {
        output = output.replace(METRO_VERBOSE_WARNING, '');
    }
    if (/^Scanning folders for symlinks in /.test(output)) {
        internal_1.ProjectUtils.logDebug(projectRoot, 'metro', output);
        return;
    }
    if (level === 'info') {
        internal_1.ProjectUtils.logInfo(projectRoot, 'metro', output);
    }
    else {
        internal_1.ProjectUtils.logError(projectRoot, 'metro', output);
    }
}
function _isIgnorableMetroConsoleOutput(output) {
    // As of react-native 0.61.x, Metro prints console logs from the device to console, without
    // passing them through the custom log reporter.
    //
    // Managed apps have a separate remote logging implementation included in the Expo SDK,
    // (see: _handleDeviceLogs), so we can just ignore these device logs from Metro.
    // if (/^ () /)
    //
    // These logs originate from:
    // https://github.com/facebook/metro/blob/e8181fb9db7db31adf7d1ed9ab840f54449ef238/packages/metro/src/lib/logToConsole.js#L50
    return /^\s+(INFO|WARN|LOG|GROUP|DEBUG) /.test(output);
}
function _isIgnorableRnpmWarning(output) {
    return output.startsWith('warn The following packages use deprecated "rnpm" config that will stop working from next release');
}
function _isIgnorableDuplicateModuleWarning(projectRoot, level, output) {
    if (level !== 'error' ||
        !output.startsWith('jest-haste-map: @providesModule naming collision:')) {
        return false;
    }
    const reactNativeNodeModulesPath = path_1.default.join(projectRoot, 'node_modules', 'react-native', 'node_modules');
    const reactNativeNodeModulesPattern = escapeRegExp_1.default(reactNativeNodeModulesPath);
    const reactNativeNodeModulesCollisionRegex = new RegExp(`Paths: ${reactNativeNodeModulesPattern}.+ collides with ${reactNativeNodeModulesPattern}.+`);
    return reactNativeNodeModulesCollisionRegex.test(output);
}
async function startReactNativeServerAsync({ projectRoot, options = {}, exp = config_1.getConfig(projectRoot).exp, verbose = true, }) {
    var _a;
    internal_1.assertValidProjectRoot(projectRoot);
    await stopReactNativeServerAsync(projectRoot);
    await internal_1.Watchman.addToPathAsync(); // Attempt to fix watchman if it's hanging
    await internal_1.Watchman.unblockAndGetVersionAsync(projectRoot);
    let packagerPort = await internal_1.getFreePortAsync(19001); // Create packager options
    const customLogReporterPath = require.resolve(path_1.default.join(__dirname, '../../build/reporter'));
    // TODO: Bacon: Support .mjs (short-lived JS modules extension that some packages use)
    const sourceExtsConfig = { isTS: true, isReact: true, isModern: false };
    const sourceExts = options.target === 'bare'
        ? paths_1.getBareExtensions([], sourceExtsConfig)
        : paths_1.getManagedExtensions([], sourceExtsConfig);
    let packagerOpts = {
        port: packagerPort,
        customLogReporterPath,
        sourceExts,
    };
    if (options.nonPersistent && internal_1.Versions.lteSdkVersion(exp, '32.0.0')) {
        packagerOpts.nonPersistent = true;
    }
    if (internal_1.Versions.gteSdkVersion(exp, '33.0.0')) {
        // starting with SDK 37, we bundle this plugin with the expo-asset package instead of expo,
        // so check there first and fall back to expo if we can't find it in expo-asset
        packagerOpts.assetPlugins = resolve_from_1.default.silent(projectRoot, 'expo-asset/tools/hashAssetFiles');
        if (!packagerOpts.assetPlugins) {
            packagerOpts.assetPlugins = resolve_from_1.default.silent(projectRoot, 'expo/tools/hashAssetFiles');
            if (!packagerOpts.assetPlugins) {
                throw new Error('Unable to find the expo-asset package in the current project. Install it and try again.');
            }
        }
    }
    if (options.maxWorkers) {
        packagerOpts['max-workers'] = options.maxWorkers;
    }
    if (!internal_1.Versions.gteSdkVersion(exp, '16.0.0')) {
        delete packagerOpts.customLogReporterPath;
    }
    const userPackagerOpts = exp.packagerOpts;
    if (userPackagerOpts) {
        // The RN CLI expects rn-cli.config.js's path to be absolute. We use the
        // project root to resolve relative paths since that was the original
        // behavior of the RN CLI.
        if (userPackagerOpts.config) {
            userPackagerOpts.config = path_1.default.resolve(projectRoot, userPackagerOpts.config);
        }
        // Provide a fallback if the value isn't given
        const userSourceExts = (_a = userPackagerOpts.sourceExts) !== null && _a !== void 0 ? _a : [];
        packagerOpts = Object.assign(Object.assign(Object.assign({}, packagerOpts), userPackagerOpts), { 
            // In order to prevent people from forgetting to include the .expo extension or other things
            // NOTE(brentvatne): we should probably do away with packagerOpts soon in favor of @expo/metro-config!
            sourceExts: [...new Set([...packagerOpts.sourceExts, ...userSourceExts])] });
        if (userPackagerOpts.port !== undefined && userPackagerOpts.port !== null) {
            packagerPort = userPackagerOpts.port;
        }
    }
    const cliOpts = ['start'];
    for (const [key, val] of Object.entries(packagerOpts)) {
        // If the packager opt value is boolean, don't set
        // --[opt] [value], just set '--opt'
        if (val && typeof val === 'boolean') {
            cliOpts.push(`--${key}`);
        }
        else if (val) {
            cliOpts.push(`--${key}`, val);
        }
    }
    if (process.env.EXPO_DEBUG) {
        cliOpts.push('--verbose');
    }
    if (options.reset) {
        cliOpts.push('--reset-cache');
    }
    // Get the CLI path
    const cliPath = resolve_from_1.default(projectRoot, 'react-native/local-cli/cli.js');
    // Run the copy of Node that's embedded in Electron by setting the
    // ELECTRON_RUN_AS_NODE environment variable
    // Note: the CLI script sets up graceful-fs and sets ulimit to 4096 in the
    // child process
    const packagerProcess = child_process_1.default.fork(cliPath, cliOpts, {
        cwd: projectRoot,
        env: Object.assign(Object.assign({}, process.env), { NODE_OPTIONS: process.env.METRO_NODE_OPTIONS, REACT_NATIVE_APP_ROOT: projectRoot, ELECTRON_RUN_AS_NODE: '1' }),
        silent: true,
    });
    await internal_1.ProjectSettings.setPackagerInfoAsync(projectRoot, {
        packagerPort,
        packagerPid: packagerProcess.pid,
    }); // TODO: do we need this? don't know if it's ever called
    process.on('exit', () => {
        tree_kill_1.default(packagerProcess.pid);
    });
    if (!packagerProcess.stdout) {
        throw new Error('Expected spawned process to have a stdout stream, but none was found.');
    }
    if (!packagerProcess.stderr) {
        throw new Error('Expected spawned process to have a stderr stream, but none was found.');
    }
    packagerProcess.stdout.setEncoding('utf8');
    packagerProcess.stderr.setEncoding('utf8');
    packagerProcess.stdout.pipe(split_1.default()).on('data', data => {
        if (verbose) {
            _logPackagerOutput(projectRoot, 'info', data);
        }
    });
    packagerProcess.stderr.on('data', data => {
        if (verbose) {
            _logPackagerOutput(projectRoot, 'error', data);
        }
    });
    const exitPromise = new Promise((resolve, reject) => {
        packagerProcess.once('exit', async (code) => {
            internal_1.ProjectUtils.logDebug(projectRoot, 'expo', `Metro Bundler process exited with code ${code}`);
            if (code) {
                reject(new Error(`Metro Bundler process exited with code ${code}`));
            }
            else {
                resolve();
            }
            try {
                await internal_1.ProjectSettings.setPackagerInfoAsync(projectRoot, {
                    packagerPort: null,
                    packagerPid: null,
                });
            }
            catch (e) { }
        });
    });
    const packagerUrl = await internal_1.UrlUtils.constructBundleUrlAsync(projectRoot, {
        urlType: 'http',
        hostType: 'localhost',
    });
    await Promise.race([_waitForRunningAsync(projectRoot, `${packagerUrl}/status`), exitPromise]);
}
exports.startReactNativeServerAsync = startReactNativeServerAsync;
async function stopReactNativeServerAsync(projectRoot) {
    internal_1.assertValidProjectRoot(projectRoot);
    const packagerInfo = await internal_1.ProjectSettings.readPackagerInfoAsync(projectRoot);
    if (!packagerInfo.packagerPort || !packagerInfo.packagerPid) {
        internal_1.ProjectUtils.logDebug(projectRoot, 'expo', `No packager found for project at ${projectRoot}.`);
        return;
    }
    internal_1.ProjectUtils.logDebug(projectRoot, 'expo', `Killing packager process tree: ${packagerInfo.packagerPid}`);
    try {
        await treekillAsync(packagerInfo.packagerPid, 'SIGKILL');
    }
    catch (e) {
        internal_1.ProjectUtils.logDebug(projectRoot, 'expo', `Error stopping packager process: ${e.toString()}`);
    }
    await internal_1.ProjectSettings.setPackagerInfoAsync(projectRoot, {
        packagerPort: null,
        packagerPid: null,
    });
}
exports.stopReactNativeServerAsync = stopReactNativeServerAsync;
async function _waitForRunningAsync(projectRoot, url, retries = 300) {
    try {
        const response = await axios_1.default.request({
            url,
            responseType: 'text',
            proxy: false,
        });
        if (/packager-status:running/.test(response.data)) {
            return true;
        }
        else if (retries === 0) {
            internal_1.ProjectUtils.logError(projectRoot, 'expo', `Could not get status from Metro bundler. Server response: ${response.data}`);
        }
    }
    catch (e) {
        if (retries === 0) {
            internal_1.ProjectUtils.logError(projectRoot, 'expo', `Could not get status from Metro bundler. ${e.message}`);
        }
    }
    if (retries <= 0) {
        throw new Error('Connecting to Metro bundler failed.');
    }
    else {
        await internal_1.delayAsync(100);
        return _waitForRunningAsync(projectRoot, url, retries - 1);
    }
}
//# sourceMappingURL=startLegacyReactNativeServerAsync.js.map
"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("@expo/config");
const path = __importStar(require("path"));
const util_1 = require("util");
const internal_1 = require("../internal");
function getNgrokConfigPath() {
    return path.join(internal_1.UserSettings.dotExpoHomeDirectory(), 'ngrok.yml');
}
async function getProjectRandomnessAsync(projectRoot) {
    const ps = await internal_1.ProjectSettings.readAsync(projectRoot);
    const randomness = ps.urlRandomness;
    if (randomness) {
        return randomness;
    }
    else {
        return resetProjectRandomnessAsync(projectRoot);
    }
}
async function resetProjectRandomnessAsync(projectRoot) {
    const randomness = internal_1.UrlUtils.someRandomness();
    internal_1.ProjectSettings.setAsync(projectRoot, { urlRandomness: randomness });
    return randomness;
}
async function connectToNgrokAsync(projectRoot, ngrok, args, hostnameAsync, ngrokPid, attempts = 0) {
    const ngrokConnectAsync = util_1.promisify(ngrok.connect);
    const ngrokKillAsync = util_1.promisify(ngrok.kill);
    try {
        const configPath = getNgrokConfigPath();
        const hostname = await hostnameAsync();
        const url = await ngrokConnectAsync(Object.assign({ hostname,
            configPath }, args));
        return url;
    }
    catch (e) {
        // Attempt to connect 3 times
        if (attempts >= 2) {
            if (e.message) {
                throw new internal_1.XDLError('NGROK_ERROR', e.toString());
            }
            else {
                throw new internal_1.XDLError('NGROK_ERROR', JSON.stringify(e));
            }
        }
        if (!attempts) {
            attempts = 0;
        } // Attempt to fix the issue
        if (e.error_code && e.error_code === 103) {
            if (attempts === 0) {
                // Failed to start tunnel. Might be because url already bound to another session.
                if (ngrokPid) {
                    try {
                        process.kill(ngrokPid, 'SIGKILL');
                    }
                    catch (e) {
                        internal_1.ProjectUtils.logDebug(projectRoot, 'expo', `Couldn't kill ngrok with PID ${ngrokPid}`);
                    }
                }
                else {
                    await ngrokKillAsync();
                }
            }
            else {
                // Change randomness to avoid conflict if killing ngrok didn't help
                await resetProjectRandomnessAsync(projectRoot);
            }
        } // Wait 100ms and then try again
        await internal_1.delayAsync(100);
        return connectToNgrokAsync(projectRoot, ngrok, args, hostnameAsync, null, attempts + 1);
    }
}
const TUNNEL_TIMEOUT = 10 * 1000;
async function startTunnelsAsync(projectRoot, options = {}) {
    const ngrok = await internal_1.resolveNgrokAsync(projectRoot, options);
    const username = (await internal_1.UserManager.getCurrentUsernameAsync()) || internal_1.ANONYMOUS_USERNAME;
    internal_1.assertValidProjectRoot(projectRoot);
    const packagerInfo = await internal_1.ProjectSettings.readPackagerInfoAsync(projectRoot);
    if (!packagerInfo.packagerPort) {
        throw new internal_1.XDLError('NO_PACKAGER_PORT', `No packager found for project at ${projectRoot}.`);
    }
    if (!packagerInfo.expoServerPort) {
        throw new internal_1.XDLError('NO_EXPO_SERVER_PORT', `No Expo server found for project at ${projectRoot}.`);
    }
    const expoServerPort = packagerInfo.expoServerPort;
    await stopTunnelsAsync(projectRoot);
    if (await internal_1.Android.startAdbReverseAsync(projectRoot)) {
        internal_1.ProjectUtils.logInfo(projectRoot, 'expo', 'Successfully ran `adb reverse`. Localhost URLs should work on the connected Android device.');
    }
    const packageShortName = path.parse(projectRoot).base;
    const expRc = await config_1.readExpRcAsync(projectRoot);
    let startedTunnelsSuccessfully = false;
    // Some issues with ngrok cause it to hang indefinitely. After
    // TUNNEL_TIMEOUTms we just throw an error.
    await Promise.race([
        (async () => {
            await internal_1.delayAsync(TUNNEL_TIMEOUT);
            if (!startedTunnelsSuccessfully) {
                throw new Error('Starting tunnels timed out');
            }
        })(),
        (async () => {
            const expoServerNgrokUrl = await connectToNgrokAsync(projectRoot, ngrok, {
                authtoken: internal_1.Config.ngrok.authToken,
                port: expoServerPort,
                proto: 'http',
            }, async () => {
                const randomness = expRc.manifestTunnelRandomness
                    ? expRc.manifestTunnelRandomness
                    : await getProjectRandomnessAsync(projectRoot);
                return [
                    randomness,
                    internal_1.UrlUtils.domainify(username),
                    internal_1.UrlUtils.domainify(packageShortName),
                    internal_1.Config.ngrok.domain,
                ].join('.');
            }, packagerInfo.ngrokPid);
            const packagerNgrokUrl = await connectToNgrokAsync(projectRoot, ngrok, {
                authtoken: internal_1.Config.ngrok.authToken,
                port: packagerInfo.packagerPort,
                proto: 'http',
            }, async () => {
                const randomness = expRc.manifestTunnelRandomness
                    ? expRc.manifestTunnelRandomness
                    : await getProjectRandomnessAsync(projectRoot);
                return [
                    'packager',
                    randomness,
                    internal_1.UrlUtils.domainify(username),
                    internal_1.UrlUtils.domainify(packageShortName),
                    internal_1.Config.ngrok.domain,
                ].join('.');
            }, packagerInfo.ngrokPid);
            await internal_1.ProjectSettings.setPackagerInfoAsync(projectRoot, {
                expoServerNgrokUrl,
                packagerNgrokUrl,
                ngrokPid: ngrok.process().pid,
            });
            startedTunnelsSuccessfully = true;
            internal_1.ProjectUtils.logWithLevel(projectRoot, 'info', {
                tag: 'expo',
                _expoEventType: 'TUNNEL_READY',
            }, 'Tunnel ready.');
            ngrok.addListener('statuschange', (status) => {
                if (status === 'reconnecting') {
                    internal_1.ProjectUtils.logError(projectRoot, 'expo', 'We noticed your tunnel is having issues. ' +
                        'This may be due to intermittent problems with our tunnel provider. ' +
                        'If you have trouble connecting to your app, try to Restart the project, ' +
                        'or switch Host to LAN.');
                }
                else if (status === 'online') {
                    internal_1.ProjectUtils.logInfo(projectRoot, 'expo', 'Tunnel connected.');
                }
            });
        })(),
    ]);
}
exports.startTunnelsAsync = startTunnelsAsync;
async function stopTunnelsAsync(projectRoot) {
    internal_1.assertValidProjectRoot(projectRoot);
    const ngrok = await internal_1.resolveNgrokAsync(projectRoot, { shouldPrompt: false }).catch(() => null);
    if (!ngrok) {
        return;
    }
    const ngrokKillAsync = util_1.promisify(ngrok.kill);
    // This will kill all ngrok tunnels in the process.
    // We'll need to change this if we ever support more than one project
    // open at a time in XDE.
    const packagerInfo = await internal_1.ProjectSettings.readPackagerInfoAsync(projectRoot);
    const ngrokProcess = ngrok.process();
    const ngrokProcessPid = ngrokProcess ? ngrokProcess.pid : null;
    ngrok.removeAllListeners('statuschange');
    if (packagerInfo.ngrokPid && packagerInfo.ngrokPid !== ngrokProcessPid) {
        // Ngrok is running in some other process. Kill at the os level.
        try {
            process.kill(packagerInfo.ngrokPid);
        }
        catch (e) {
            internal_1.ProjectUtils.logDebug(projectRoot, 'expo', `Couldn't kill ngrok with PID ${packagerInfo.ngrokPid}`);
        }
    }
    else {
        // Ngrok is running from the current process. Kill using ngrok api.
        await ngrokKillAsync();
    }
    await internal_1.ProjectSettings.setPackagerInfoAsync(projectRoot, {
        expoServerNgrokUrl: null,
        packagerNgrokUrl: null,
        ngrokPid: null,
    });
    await internal_1.Android.stopAdbReverseAsync(projectRoot);
}
exports.stopTunnelsAsync = stopTunnelsAsync;
//# sourceMappingURL=ngrok.js.map
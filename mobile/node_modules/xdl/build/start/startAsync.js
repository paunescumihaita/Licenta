"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("@expo/config");
const internal_1 = require("../internal");
let serverInstance = null;
let messageSocket = null;
/**
 * Sends a message over web sockets to any connected device,
 * does nothing when the dev server is not running.
 *
 * @param method name of the command. In RN projects `reload`, and `devMenu` are available. In Expo Go, `sendDevCommand` is available.
 * @param params
 */
function broadcastMessage(method, params) {
    if (messageSocket) {
        messageSocket.broadcast(method, params);
    }
}
exports.broadcastMessage = broadcastMessage;
async function startAsync(projectRoot, _a = {}, verbose = true) {
    var _b;
    var { exp = config_1.getConfig(projectRoot).exp } = _a, options = __rest(_a, ["exp"]);
    internal_1.assertValidProjectRoot(projectRoot);
    internal_1.Analytics.logEvent('Start Project', {
        projectRoot,
        developerTool: internal_1.Config.developerTool,
        sdkVersion: (_b = exp.sdkVersion) !== null && _b !== void 0 ? _b : null,
    });
    if (options.webOnly) {
        await internal_1.Webpack.restartAsync(projectRoot, options);
        internal_1.DevSession.startSession(projectRoot, exp, 'web');
        return exp;
    }
    else if (internal_1.Env.shouldUseDevServer(exp) || options.devClient) {
        [serverInstance, , messageSocket] = await internal_1.startDevServerAsync(projectRoot, options);
        internal_1.DevSession.startSession(projectRoot, exp, 'native');
    }
    else {
        await internal_1.startExpoServerAsync(projectRoot);
        await internal_1.startReactNativeServerAsync({ projectRoot, exp, options, verbose });
        internal_1.DevSession.startSession(projectRoot, exp, 'native');
    }
    const { hostType } = await internal_1.ProjectSettings.readAsync(projectRoot);
    if (!internal_1.Config.offline && hostType === 'tunnel') {
        try {
            await internal_1.startTunnelsAsync(projectRoot);
        }
        catch (e) {
            internal_1.ProjectUtils.logDebug(projectRoot, 'expo', `Error starting tunnel ${e.message}`);
        }
    }
    return exp;
}
exports.startAsync = startAsync;
async function stopInternalAsync(projectRoot) {
    internal_1.DevSession.stopSession();
    await Promise.all([
        internal_1.Webpack.stopAsync(projectRoot),
        new Promise((resolve, reject) => {
            if (serverInstance) {
                serverInstance.close(error => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve();
                    }
                });
            }
        }),
        internal_1.stopExpoServerAsync(projectRoot),
        internal_1.stopReactNativeServerAsync(projectRoot),
        async () => {
            if (!internal_1.Config.offline) {
                try {
                    await internal_1.stopTunnelsAsync(projectRoot);
                }
                catch (e) {
                    internal_1.ProjectUtils.logDebug(projectRoot, 'expo', `Error stopping ngrok ${e.message}`);
                }
            }
        },
        await internal_1.Android.maybeStopAdbDaemonAsync(),
    ]);
}
async function forceQuitAsync(projectRoot) {
    // find RN packager and ngrok pids, attempt to kill them manually
    const { packagerPid, ngrokPid } = await internal_1.ProjectSettings.readPackagerInfoAsync(projectRoot);
    if (packagerPid) {
        try {
            process.kill(packagerPid);
        }
        catch (e) { }
    }
    if (ngrokPid) {
        try {
            process.kill(ngrokPid);
        }
        catch (e) { }
    }
    await internal_1.ProjectSettings.setPackagerInfoAsync(projectRoot, {
        expoServerPort: null,
        packagerPort: null,
        packagerPid: null,
        expoServerNgrokUrl: null,
        packagerNgrokUrl: null,
        ngrokPid: null,
        webpackServerPort: null,
    });
}
async function stopAsync(projectRoot) {
    try {
        const result = await Promise.race([
            stopInternalAsync(projectRoot),
            new Promise(resolve => setTimeout(resolve, 2000, 'stopFailed')),
        ]);
        if (result === 'stopFailed') {
            await forceQuitAsync(projectRoot);
        }
    }
    catch (error) {
        await forceQuitAsync(projectRoot);
        throw error;
    }
}
exports.stopAsync = stopAsync;
//# sourceMappingURL=startAsync.js.map
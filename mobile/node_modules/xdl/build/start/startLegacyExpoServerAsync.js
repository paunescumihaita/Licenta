"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("@expo/config");
const axios_1 = __importDefault(require("axios"));
const express_1 = __importDefault(require("express"));
const internal_1 = require("../internal");
function _isIgnorableBugReportingExtraData(body) {
    return body.length === 2 && body[0] === 'BugReporting extraData:';
}
function _isAppRegistryStartupMessage(body) {
    return (body.length === 1 &&
        (/^Running application "main" with appParams:/.test(body[0]) ||
            /^Running "main" with \{/.test(body[0])));
}
function _handleDeviceLogs(projectRoot, deviceId, deviceName, logs) {
    for (let i = 0; i < logs.length; i++) {
        const log = logs[i];
        let body = typeof log.body === 'string' ? [log.body] : log.body;
        let { level } = log;
        if (_isIgnorableBugReportingExtraData(body)) {
            level = 'debug';
        }
        if (_isAppRegistryStartupMessage(body)) {
            body = [`Running application on ${deviceName}.`];
        }
        const args = body.map((obj) => {
            if (typeof obj === 'undefined') {
                return 'undefined';
            }
            if (obj === 'null') {
                return 'null';
            }
            if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean') {
                return obj;
            }
            try {
                return JSON.stringify(obj);
            }
            catch (e) {
                return obj.toString();
            }
        });
        const logLevel = level === 'info' || level === 'warn' || level === 'error' || level === 'debug'
            ? level
            : 'info';
        internal_1.ProjectUtils.getLogger(projectRoot)[logLevel]({
            tag: 'device',
            deviceId,
            deviceName,
            groupDepth: log.groupDepth,
            shouldHide: log.shouldHide,
            includesStack: log.includesStack,
        }, ...args);
    }
}
async function startExpoServerAsync(projectRoot) {
    internal_1.assertValidProjectRoot(projectRoot);
    await stopExpoServerAsync(projectRoot);
    const app = express_1.default();
    app.use(express_1.default.json({
        limit: '10mb',
    }));
    app.use(express_1.default.urlencoded({
        limit: '10mb',
        extended: true,
    }));
    if ((internal_1.ConnectionStatus.isOffline()
        ? await internal_1.Doctor.validateWithoutNetworkAsync(projectRoot)
        : await internal_1.Doctor.validateWithNetworkAsync(projectRoot)) === internal_1.Doctor.FATAL) {
        throw new Error(`Couldn't start project. Please fix the errors and restart the project.`);
    }
    // Serve the manifest.
    const manifestHandler = internal_1.ManifestHandler.getManifestHandler(projectRoot);
    app.get('/', manifestHandler);
    app.get('/manifest', manifestHandler);
    app.get('/index.exp', manifestHandler);
    app.post('/logs', async (req, res) => {
        try {
            const deviceId = req.get('Device-Id');
            const deviceName = req.get('Device-Name');
            if (deviceId && deviceName && req.body) {
                _handleDeviceLogs(projectRoot, deviceId, deviceName, req.body);
            }
        }
        catch (e) {
            internal_1.ProjectUtils.logError(projectRoot, 'expo', `Error getting device logs: ${e} ${e.stack}`);
        }
        res.send('Success');
    });
    app.post('/shutdown', async (req, res) => {
        server.close();
        res.send('Success');
    });
    const expRc = await config_1.readExpRcAsync(projectRoot);
    const expoServerPort = expRc.manifestPort ? expRc.manifestPort : await internal_1.getFreePortAsync(19000);
    await internal_1.ProjectSettings.setPackagerInfoAsync(projectRoot, {
        expoServerPort,
    });
    let server = app.listen(expoServerPort, () => {
        const info = server.address();
        const host = info.address;
        const port = info.port;
        internal_1.ProjectUtils.logDebug(projectRoot, 'expo', `Local server listening at http://${host}:${port}`);
    });
}
exports.startExpoServerAsync = startExpoServerAsync;
async function stopExpoServerAsync(projectRoot) {
    internal_1.assertValidProjectRoot(projectRoot);
    const packagerInfo = await internal_1.ProjectSettings.readPackagerInfoAsync(projectRoot);
    if (packagerInfo && packagerInfo.expoServerPort) {
        try {
            await axios_1.default.request({
                method: 'post',
                url: `http://127.0.0.1:${packagerInfo.expoServerPort}/shutdown`,
            });
        }
        catch (e) { }
    }
    await internal_1.ProjectSettings.setPackagerInfoAsync(projectRoot, {
        expoServerPort: null,
    });
}
exports.stopExpoServerAsync = stopExpoServerAsync;
//# sourceMappingURL=startLegacyExpoServerAsync.js.map
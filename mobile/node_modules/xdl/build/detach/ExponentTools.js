"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const spawn_async_1 = __importDefault(require("@expo/spawn-async"));
const axios_1 = __importDefault(require("axios"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const internal_1 = require("../internal");
async function saveUrlToPathAsync(url, path, timeout = 20000) {
    const response = await axios_1.default.get(url, { responseType: 'stream', timeout });
    return new Promise(function (resolve, reject) {
        const stream = fs_extra_1.default.createWriteStream(path);
        stream.on('close', resolve);
        stream.on('error', reject);
        response.data.on('error', reject).pipe(stream);
    });
}
exports.saveUrlToPathAsync = saveUrlToPathAsync;
async function getManifestAsync(url, headers, options = {}) {
    const buildPhaseLogger = options.logger || internal_1.LoggerDetach.withFields({ buildPhase: 'reading manifest' });
    let response;
    try {
        response = await _retryPromise(() => axios_1.default.get(url.replace('exp://', 'http://'), { headers }));
    }
    catch (err) {
        buildPhaseLogger.error(err);
        throw new Error('Failed to fetch manifest from www');
    }
    buildPhaseLogger.info('Using manifest:', JSON.stringify(response.data, null, 2));
    return response.data;
}
exports.getManifestAsync = getManifestAsync;
async function _retryPromise(fn, retries = 5) {
    try {
        return await fn();
    }
    catch (err) {
        if (retries-- > 0) {
            return await _retryPromise(fn, retries);
        }
        else {
            throw err;
        }
    }
}
async function spawnAsyncThrowError(command, args, options = {
    stdio: 'inherit',
    cwd: process.cwd(),
}) {
    const { pipeToLogger } = options;
    if (pipeToLogger) {
        options.stdio = 'pipe';
        options.cwd = options.cwd || process.cwd();
    }
    const promise = spawn_async_1.default(command, args, options);
    if (pipeToLogger && promise.child) {
        const streams = {};
        if (pipeToLogger === true || pipeToLogger.stdout) {
            streams.stdout = promise.child.stdout;
        }
        if (pipeToLogger === true || pipeToLogger.stderr) {
            streams.stderr = promise.child.stderr;
        }
        internal_1.pipeOutputToLogger(streams, options.loggerFields, options);
    }
    return promise;
}
exports.spawnAsyncThrowError = spawnAsyncThrowError;
async function spawnAsync(command, args, options) {
    try {
        return await spawnAsyncThrowError(command, args, options);
    }
    catch (e) {
        internal_1.LoggerDetach.error(e.message);
    }
}
exports.spawnAsync = spawnAsync;
function isDirectory(dir) {
    try {
        if (fs_extra_1.default.statSync(dir).isDirectory()) {
            return true;
        }
        return false;
    }
    catch (e) {
        return false;
    }
}
exports.isDirectory = isDirectory;
async function getResolvedLocalesAsync(projectRoot, exp) {
    const locales = {};
    if (exp.locales !== undefined) {
        for (const [lang, localePath] of Object.entries(exp.locales)) {
            const s = await fs_extra_1.default.readFile(path_1.default.resolve(projectRoot, localePath), 'utf8');
            try {
                locales[lang] = JSON.parse(s);
            }
            catch (e) {
                throw new internal_1.XDLError('INVALID_JSON', JSON.stringify(e));
            }
        }
    }
    return locales;
}
exports.getResolvedLocalesAsync = getResolvedLocalesAsync;
async function regexFileAsync(regex, replace, filename) {
    const file = await fs_extra_1.default.readFile(filename);
    const fileString = file.toString();
    await fs_extra_1.default.writeFile(filename, fileString.replace(regex, replace));
}
exports.regexFileAsync = regexFileAsync;
// Matches sed /d behavior
async function deleteLinesInFileAsync(startRegex, endRegex, filename) {
    const file = await fs_extra_1.default.readFile(filename);
    const fileString = file.toString();
    const lines = fileString.split(/\r?\n/);
    const filteredLines = [];
    let inDeleteRange = false;
    for (let i = 0; i < lines.length; i++) {
        if (lines[i].match(startRegex)) {
            inDeleteRange = true;
        }
        if (!inDeleteRange) {
            filteredLines.push(lines[i]);
        }
        if (inDeleteRange && lines[i].match(endRegex)) {
            inDeleteRange = false;
        }
    }
    await fs_extra_1.default.writeFile(filename, filteredLines.join('\n'));
}
exports.deleteLinesInFileAsync = deleteLinesInFileAsync;
//# sourceMappingURL=ExponentTools.js.map
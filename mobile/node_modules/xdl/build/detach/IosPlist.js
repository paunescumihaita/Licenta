"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const plist_1 = __importDefault(require("@expo/plist"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const internal_1 = require("../internal");
const { spawnAsyncThrowError } = internal_1.ExponentTools;
function _getNormalizedPlistFilename(plistName) {
    let plistFilename;
    if (plistName.indexOf('.') !== -1) {
        plistFilename = plistName;
    }
    else {
        plistFilename = `${plistName}.plist`;
    }
    return plistFilename;
}
/**
 *  @param plistName base filename of property list. if no extension, assumes .plist
 */
async function modifyAsync(plistPath, plistName, transform) {
    const plistFilename = _getNormalizedPlistFilename(plistName);
    const configPlistName = path_1.default.join(plistPath, plistFilename);
    const configFilename = path_1.default.join(plistPath, `${plistName}.json`);
    // grab original plist as json object
    let config;
    if (process.platform === 'darwin') {
        await spawnAsyncThrowError('plutil', [
            '-convert',
            'json',
            configPlistName,
            '-o',
            configFilename,
        ]);
        const configContents = await fs_extra_1.default.readFile(configFilename, 'utf8');
        try {
            config = JSON.parse(configContents);
        }
        catch (e) {
            internal_1.LoggerDetach.info(`Error parsing ${configFilename}`, e);
            internal_1.LoggerDetach.info('The erroneous file contents was:', configContents);
            config = {};
        }
    }
    else {
        config = plist_1.default.parse(fs_extra_1.default.readFileSync(configPlistName, 'utf8'));
    }
    // apply transformation
    config = await transform(config);
    // back up old plist and swap in modified one
    fs_extra_1.default.copyFileSync(configPlistName, `${configPlistName}.bak`);
    await fs_extra_1.default.writeFile(configFilename, JSON.stringify(config));
    if (process.platform === 'darwin') {
        await spawnAsyncThrowError('plutil', [
            '-convert',
            'xml1',
            configFilename,
            '-o',
            configPlistName,
        ]);
    }
    else {
        await fs_extra_1.default.writeFile(configPlistName, plist_1.default.build(config));
    }
    return config;
}
exports.modifyAsync = modifyAsync;
async function createBlankAsync(plistPath, plistName) {
    // write empty json file
    const emptyConfig = {};
    const tmpConfigFile = path_1.default.join(plistPath, `${plistName}.json`);
    await fs_extra_1.default.writeFile(tmpConfigFile, JSON.stringify(emptyConfig));
    // convert to plist
    const plistFilename = _getNormalizedPlistFilename(plistName);
    const configPlistName = path_1.default.join(plistPath, plistFilename);
    if (process.platform === 'darwin') {
        await spawnAsyncThrowError('plutil', [
            '-convert',
            'xml1',
            tmpConfigFile,
            '-o',
            configPlistName,
        ]);
    }
    else {
        await fs_extra_1.default.writeFile(configPlistName, JSON.stringify(plist_1.default.build(emptyConfig)));
    }
    // remove tmp json file
    fs_extra_1.default.removeSync(tmpConfigFile);
}
exports.createBlankAsync = createBlankAsync;
async function cleanBackupAsync(plistPath, plistName, restoreOriginal = true) {
    const plistFilename = _getNormalizedPlistFilename(plistName);
    const configPlistName = path_1.default.join(plistPath, plistFilename);
    const configFilename = path_1.default.join(plistPath, `${plistName}.json`);
    const backupPlistPath = `${configPlistName}.bak`;
    if (restoreOriginal && (await fs_extra_1.default.pathExists(backupPlistPath))) {
        await fs_extra_1.default.copy(backupPlistPath, configPlistName);
    }
    await fs_extra_1.default.remove(backupPlistPath);
    await fs_extra_1.default.remove(configFilename);
}
exports.cleanBackupAsync = cleanBackupAsync;
//# sourceMappingURL=IosPlist.js.map
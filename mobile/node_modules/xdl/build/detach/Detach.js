"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("@expo/config");
const json_file_1 = __importDefault(require("@expo/json-file"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const glob_1 = require("glob");
const path_1 = __importDefault(require("path"));
const internal_1 = require("../internal");
const SERVICE_CONTEXT_PROJECT_NAME = 'exponent-view-template';
async function ensureBuildConstantsExistsIOSAsync(configFilePath) {
    // EXBuildConstants is included in newer ExpoKit projects.
    // create it if it doesn't exist.
    const doesBuildConstantsExist = fs_extra_1.default.existsSync(path_1.default.join(configFilePath, 'EXBuildConstants.plist'));
    if (!doesBuildConstantsExist) {
        await internal_1.IosPlist.createBlankAsync(configFilePath, 'EXBuildConstants');
        internal_1.LoggerDetach.info('Created `EXBuildConstants.plist` because it did not exist yet');
    }
}
async function _getIosExpoKitVersionThrowErrorAsync(iosProjectDirectory) {
    let expoKitVersion = '';
    const podfileLockPath = path_1.default.join(iosProjectDirectory, 'Podfile.lock');
    try {
        const podfileLock = await fs_extra_1.default.readFile(podfileLockPath, 'utf8');
        const expoKitVersionRegex = /ExpoKit\/Core\W?\(([0-9.]+)\)/gi;
        const match = expoKitVersionRegex.exec(podfileLock);
        if (!match) {
            throw new Error('ExpoKit/Core not found');
        }
        expoKitVersion = match[1];
    }
    catch (e) {
        throw new Error(`Unable to read ExpoKit version from Podfile.lock. Make sure your project depends on ExpoKit. (${e})`);
    }
    return expoKitVersion;
}
async function readNullableConfigJsonAsync(projectDir) {
    try {
        return config_1.getConfig(projectDir);
    }
    catch (_a) {
        return null;
    }
}
async function prepareDetachedBuildIosAsync(projectDir, args) {
    const config = await readNullableConfigJsonAsync(projectDir);
    if (config && config.exp.name !== SERVICE_CONTEXT_PROJECT_NAME) {
        return prepareDetachedUserContextIosAsync(projectDir, config.exp, args);
    }
    else {
        return prepareDetachedServiceContextIosAsync(projectDir, args);
    }
}
async function prepareDetachedServiceContextIosAsync(projectDir, args) {
    // service context
    // TODO: very brittle hack: the paths here are hard coded to match the single workspace
    // path generated inside IosShellApp. When we support more than one path, this needs to
    // be smarter.
    const expoRootDir = path_1.default.join(projectDir, '..', '..');
    const workspaceSourcePath = path_1.default.join(projectDir, 'ios');
    const buildFlags = internal_1.StandaloneBuildFlags.createIos('Release', { workspaceSourcePath });
    // @ts-ignore missing 9th argument
    const context = internal_1.StandaloneContext.createServiceContext(expoRootDir, null, null, null, 
    /* testEnvironment */ 'none', buildFlags, null, null);
    const { iosProjectDirectory, supportingDirectory } = internal_1.IosWorkspace.getPaths(context);
    const expoKitVersion = await _getIosExpoKitVersionThrowErrorAsync(iosProjectDirectory);
    // use prod api keys if available
    const prodApiKeys = await _readDefaultApiKeysAsync(path_1.default.join(context.data.expoSourcePath, '__internal__', 'keys.json'));
    const { exp } = config_1.getConfig(expoRootDir, { skipSDKVersionRequirement: true });
    await internal_1.IosPlist.modifyAsync(supportingDirectory, 'EXBuildConstants', constantsConfig => {
        // verify that we are actually in a service context and not a misconfigured project
        const contextType = constantsConfig.STANDALONE_CONTEXT_TYPE;
        if (contextType !== 'service') {
            throw new Error('Unable to configure a project which has no app.json and also no STANDALONE_CONTEXT_TYPE.');
        }
        constantsConfig.EXPO_RUNTIME_VERSION = expoKitVersion;
        constantsConfig.API_SERVER_ENDPOINT =
            process.env.ENVIRONMENT === 'staging'
                ? 'https://staging.exp.host/--/api/v2/'
                : 'https://exp.host/--/api/v2/';
        if (prodApiKeys) {
            constantsConfig.DEFAULT_API_KEYS = prodApiKeys;
        }
        if (exp && exp.sdkVersion) {
            constantsConfig.TEMPORARY_SDK_VERSION = exp.sdkVersion;
        }
        return constantsConfig;
    });
}
async function _readDefaultApiKeysAsync(jsonFilePath) {
    if (fs_extra_1.default.existsSync(jsonFilePath)) {
        const keys = {};
        const allKeys = await new json_file_1.default(jsonFilePath).readAsync();
        const validKeys = ['AMPLITUDE_KEY', 'GOOGLE_MAPS_IOS_API_KEY'];
        for (const key in allKeys) {
            if (allKeys.hasOwnProperty(key) && validKeys.includes(key)) {
                keys[key] = allKeys[key];
            }
        }
        return keys;
    }
    return null;
}
async function prepareDetachedUserContextIosAsync(projectDir, exp, args) {
    const context = internal_1.StandaloneContext.createUserContext(projectDir, exp);
    const { iosProjectDirectory, supportingDirectory } = internal_1.IosWorkspace.getPaths(context);
    internal_1.LoggerDetach.info(`Preparing iOS build at ${iosProjectDirectory}...`);
    // These files cause @providesModule naming collisions
    // but are not available until after `pod install` has run.
    const podsDirectory = path_1.default.join(iosProjectDirectory, 'Pods');
    if (!internal_1.ExponentTools.isDirectory(podsDirectory)) {
        throw new Error(`Can't find directory ${podsDirectory}, make sure you've run pod install.`);
    }
    const rnPodDirectory = path_1.default.join(podsDirectory, 'React');
    if (internal_1.ExponentTools.isDirectory(rnPodDirectory)) {
        const rnFilesToDelete = glob_1.sync('**/*.@(js|json)', {
            absolute: true,
            cwd: rnPodDirectory,
        });
        if (rnFilesToDelete) {
            for (let i = 0; i < rnFilesToDelete.length; i++) {
                await fs_extra_1.default.unlink(rnFilesToDelete[i]);
            }
        }
    }
    // insert expo development url into iOS config
    if (!args.skipXcodeConfig) {
        // populate EXPO_RUNTIME_VERSION from ExpoKit pod version
        const expoKitVersion = await _getIosExpoKitVersionThrowErrorAsync(iosProjectDirectory);
        // populate development url
        const devUrl = await internal_1.UrlUtils.constructManifestUrlAsync(projectDir);
        // populate default api keys
        const defaultApiKeys = await _readDefaultApiKeysAsync(path_1.default.join(podsDirectory, 'ExpoKit', 'template-files', 'keys.json'));
        await ensureBuildConstantsExistsIOSAsync(supportingDirectory);
        await internal_1.IosPlist.modifyAsync(supportingDirectory, 'EXBuildConstants', constantsConfig => {
            constantsConfig.developmentUrl = devUrl;
            constantsConfig.EXPO_RUNTIME_VERSION = expoKitVersion;
            if (defaultApiKeys) {
                constantsConfig.DEFAULT_API_KEYS = defaultApiKeys;
            }
            if (exp.sdkVersion) {
                constantsConfig.TEMPORARY_SDK_VERSION = exp.sdkVersion;
            }
            return constantsConfig;
        });
    }
}
async function prepareDetachedBuildAsync(projectDir, args) {
    if (args.platform === 'ios') {
        await prepareDetachedBuildIosAsync(projectDir, args);
    }
    else {
        const expoBuildConstantsMatches = glob_1.sync('android/**/DetachBuildConstants.java', {
            absolute: true,
            cwd: projectDir,
        });
        if (expoBuildConstantsMatches && expoBuildConstantsMatches.length) {
            const expoBuildConstants = expoBuildConstantsMatches[0];
            const devUrl = await internal_1.UrlUtils.constructManifestUrlAsync(projectDir);
            await internal_1.ExponentTools.regexFileAsync(/DEVELOPMENT_URL = "[^"]*";/, `DEVELOPMENT_URL = "${devUrl}";`, expoBuildConstants);
        }
    }
}
exports.prepareDetachedBuildAsync = prepareDetachedBuildAsync;
// args.dest: string,
// This is the path where assets will be copied to. It should be
// `$CONFIGURATION_BUILD_DIR/$UNLOCALIZED_RESOURCES_FOLDER_PATH` on iOS
// (see `exponent-view-template.xcodeproj/project.pbxproj` for an example)
// and `$buildDir/intermediates/assets/$targetPath` on Android (see
// `android/app/expo.gradle` for an example).
async function bundleAssetsAsync(projectDir, args) {
    const options = await readNullableConfigJsonAsync(projectDir);
    if (!options || options.exp.name === SERVICE_CONTEXT_PROJECT_NAME) {
        // Don't run assets bundling for the service context.
        return;
    }
    const { exp } = options;
    const bundledManifestPath = internal_1.EmbeddedAssets.getEmbeddedManifestPath(args.platform, projectDir, exp);
    if (!bundledManifestPath) {
        internal_1.LoggerDetach.warn(`Skipped assets bundling because the '${args.platform}.publishManifestPath' key is not specified in the app manifest.`);
        return;
    }
    let manifest;
    try {
        manifest = JSON.parse(await fs_extra_1.default.readFile(bundledManifestPath, 'utf8'));
    }
    catch (ex) {
        throw new Error(`Error reading the manifest file. Make sure the path '${bundledManifestPath}' is correct.\n\nError: ${ex.message}`);
    }
    if (!manifest || !Object.keys(manifest).length) {
        throw new Error(`The manifest at '${bundledManifestPath}' was empty or invalid.`);
    }
    await internal_1.AssetBundle.bundleAsync(null, manifest.bundledAssets, args.dest, getExportUrl(manifest));
}
exports.bundleAssetsAsync = bundleAssetsAsync;
/**
 * This function extracts the exported public URL that is set in the manifest
 * when the developer runs `expo export --public-url x`. We use this to ensure
 * that we fetch the resources from the appropriate place when doing builds
 * against self-hosted apps.
 */
function getExportUrl(manifest) {
    const { bundleUrl } = manifest;
    if (bundleUrl.includes(internal_1.AssetBundle.DEFAULT_CDN_HOST)) {
        return null;
    }
    try {
        const bundleUrlParts = bundleUrl.split('/');
        return bundleUrlParts.slice(0, bundleUrlParts.length - 2).join('/');
    }
    catch (e) {
        throw Error(`Expected bundleUrl to be of the format https://domain/bundles/bundle-hash-id, ${bundleUrl} does not follow this format.`);
    }
}
//# sourceMappingURL=Detach.js.map
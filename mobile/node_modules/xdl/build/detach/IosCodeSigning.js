"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = __importDefault(require("crypto"));
const minimatch_1 = __importDefault(require("minimatch"));
function validateProvisioningProfile(plistData, { distCertFingerprint, bundleIdentifier, }) {
    _ensureDeveloperCertificateIsValid(plistData, distCertFingerprint);
    _ensureBundleIdentifierIsValid(plistData, bundleIdentifier);
}
exports.validateProvisioningProfile = validateProvisioningProfile;
function _ensureDeveloperCertificateIsValid(plistData, distCertFingerprint) {
    const devCertBase64 = plistData.DeveloperCertificates[0];
    const devCertFingerprint = _genDerCertFingerprint(devCertBase64);
    if (devCertFingerprint !== distCertFingerprint) {
        throw new Error('validateProvisioningProfile: provisioning profile is not associated with uploaded distribution certificate');
    }
}
function _genDerCertFingerprint(certBase64) {
    const certBuffer = Buffer.from(certBase64, 'base64');
    return crypto_1.default.createHash('sha1').update(certBuffer).digest('hex').toUpperCase();
}
function _ensureBundleIdentifierIsValid(plistData, expectedBundleIdentifier) {
    var _a;
    const actualApplicationIdentifier = plistData.Entitlements['application-identifier'];
    const actualBundleIdentifier = (_a = /\.(.+)/.exec(actualApplicationIdentifier)) === null || _a === void 0 ? void 0 : _a[1];
    if (!actualBundleIdentifier || !minimatch_1.default(expectedBundleIdentifier, actualBundleIdentifier)) {
        throw new Error(`validateProvisioningProfile: wrong bundleIdentifier found in provisioning profile; expected: ${expectedBundleIdentifier}, found (in provisioning profile): ${actualBundleIdentifier}`);
    }
}
//# sourceMappingURL=IosCodeSigning.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bunyan_1 = __importDefault(require("@expo/bunyan"));
const isEmpty_1 = __importDefault(require("lodash/isEmpty"));
const isPlainObject_1 = __importDefault(require("lodash/isPlainObject"));
var LogLevel;
(function (LogLevel) {
    LogLevel["trace"] = "trace";
    LogLevel["debug"] = "debug";
    LogLevel["info"] = "info";
    LogLevel["warn"] = "warn";
    LogLevel["error"] = "error";
    LogLevel["fatal"] = "fatal";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
class Logger {
    constructor(bunyanGetter, extraFields) {
        this.loggerObj = bunyan_1.default.createLogger({ name: 'xdl-detach' });
        this.loggerGetter = bunyanGetter;
        this.extraFields = extraFields;
    }
    configure(loggerObj) {
        this.loggerObj = loggerObj;
    }
    withFields(extraFields) {
        const getter = this.loggerGetter || (() => this.loggerObj);
        return new Logger(getter, Object.assign(Object.assign({}, this.extraFields), extraFields));
    }
    trace(...all) {
        this.logLine(LogLevel.trace, ...all);
    }
    debug(...all) {
        this.logLine(LogLevel.debug, ...all);
    }
    info(...all) {
        this.logLine(LogLevel.info, ...all);
    }
    warn(...all) {
        this.logLine(LogLevel.warn, ...all);
    }
    error(...all) {
        this.logLine(LogLevel.error, ...all);
    }
    fatal(...all) {
        this.logLine(LogLevel.fatal, ...all);
    }
    logLine(level, ...args) {
        const argsToLog = [...args];
        const extraFieldsFromArgsExist = isPlainObject_1.default(args[0]);
        const extraFieldsFromArgs = extraFieldsFromArgsExist ? args[0] : {};
        if (extraFieldsFromArgsExist) {
            argsToLog.shift();
        }
        const extraFields = Object.assign(Object.assign({}, extraFieldsFromArgs), this.extraFields);
        if (!isEmpty_1.default(extraFields)) {
            argsToLog.unshift(extraFields);
        }
        if (this.loggerGetter) {
            const loggerObj = this.loggerGetter();
            loggerObj[level](...argsToLog);
        }
        else {
            this.loggerObj[level](...argsToLog);
        }
    }
}
exports.Logger = Logger;
const LoggerDetach = new Logger();
exports.default = LoggerDetach;
function pipeOutputToLogger({ stdout, stderr } = {
    stdout: null,
    stderr: null,
}, extraFields = {}, { stdoutOnly = false, loggerLineTransformer, } = {}) {
    if (stdout) {
        stdout.on('data', chunk => logMultiline(chunk, Object.assign(Object.assign({}, extraFields), { source: 'stdout' }), loggerLineTransformer));
    }
    if (stderr) {
        const source = stdoutOnly ? 'stdout' : 'stderr';
        stderr.on('data', chunk => logMultiline(chunk, Object.assign(Object.assign({}, extraFields), { source }), loggerLineTransformer));
    }
}
exports.pipeOutputToLogger = pipeOutputToLogger;
function logMultiline(data, extraFields, loggerLineTransformer) {
    if (!data) {
        return;
    }
    const lines = String(data).split('\n');
    lines.forEach(line => {
        const lineToPrint = loggerLineTransformer ? loggerLineTransformer(line) : line;
        if (lineToPrint) {
            const args = [lineToPrint];
            if (!isEmpty_1.default(extraFields)) {
                args.unshift(extraFields);
            }
            LoggerDetach.info(...args);
        }
    });
}
//# sourceMappingURL=Logger.js.map
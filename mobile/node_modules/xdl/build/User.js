"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const camelCase_1 = __importDefault(require("lodash/camelCase"));
const isEmpty_1 = __importDefault(require("lodash/isEmpty"));
const snakeCase_1 = __importDefault(require("lodash/snakeCase"));
const internal_1 = require("./internal");
exports.ANONYMOUS_USERNAME = 'anonymous';
class UserManagerInstance {
    constructor() {
        this._currentUser = null;
        this._getSessionLock = new internal_1.Semaphore();
    }
    static getGlobalInstance() {
        if (!__globalInstance) {
            __globalInstance = new UserManagerInstance();
        }
        return __globalInstance;
    }
    initialize() {
        this._currentUser = null;
        this._getSessionLock = new internal_1.Semaphore();
    }
    /**
     * Logs in a user for a given login type.
     *
     * Valid login types are:
     *  - "user-pass": Username and password authentication
     *
     * If the login type is "user-pass", we directly make the request to www
     * to login a user.
     */
    async loginAsync(loginType, loginArgs) {
        if (loginType === 'user-pass') {
            if (!loginArgs) {
                throw new Error(`The 'user-pass' login type requires a username and password.`);
            }
            const apiAnonymous = internal_1.ApiV2.clientForUser();
            const loginResp = await apiAnonymous.postAsync('auth/loginAsync', {
                username: loginArgs.username,
                password: loginArgs.password,
                otp: loginArgs.otp,
            });
            if (loginResp.error) {
                throw new internal_1.XDLError('INVALID_USERNAME_PASSWORD', loginResp['error_description']);
            }
            const user = await this._getProfileAsync({
                currentConnection: 'Username-Password-Authentication',
                sessionSecret: loginResp.sessionSecret,
            });
            return user;
        }
        else {
            throw new Error(`Invalid login type provided. Must be 'user-pass'.`);
        }
    }
    async registerAsync(userData, user = null) {
        let actor = user;
        if (!actor) {
            actor = await this.getCurrentUserAsync();
        }
        if (actor) {
            await this.logoutAsync();
            actor = null;
        }
        try {
            // Create or update the profile
            let registeredUser = await this.createOrUpdateUserAsync({
                connection: 'Username-Password-Authentication',
                email: userData.email,
                givenName: userData.givenName,
                familyName: userData.familyName,
                username: userData.username,
                password: userData.password,
            });
            registeredUser = await this.loginAsync('user-pass', {
                username: userData.username,
                password: userData.password,
            });
            return registeredUser;
        }
        catch (e) {
            console.error(e);
            throw new internal_1.XDLError('REGISTRATION_ERROR', 'Error registering user: ' + e.message);
        }
    }
    /**
     * Ensure user is logged in and has a valid token.
     *
     * If there are any issues with the login, this method throws.
     */
    async ensureLoggedInAsync() {
        if (internal_1.Config.offline) {
            throw new internal_1.XDLError('NETWORK_REQUIRED', "Can't verify user without network access");
        }
        let user = await this.getCurrentUserAsync({ silent: true });
        if (!user && this._interactiveAuthenticationCallbackAsync) {
            user = await this._interactiveAuthenticationCallbackAsync();
        }
        if (!user) {
            throw new internal_1.XDLError('NOT_LOGGED_IN', 'Not logged in');
        }
        return user;
    }
    setInteractiveAuthenticationCallback(callback) {
        this._interactiveAuthenticationCallbackAsync = callback;
    }
    async _readUserData() {
        let auth = await internal_1.UserSettings.getAsync('auth', null);
        if (isEmpty_1.default(auth)) {
            // XXX(ville):
            // We sometimes read an empty string from ~/.expo/state.json,
            // even though it has valid credentials in it.
            // We don't know why.
            // An empty string can't be parsed as JSON, so an empty default object is returned.
            // In this case, retrying usually helps.
            auth = await internal_1.UserSettings.getAsync('auth', null);
        }
        if (typeof auth === 'undefined') {
            return null;
        }
        return auth;
    }
    /**
     * Get the current user based on the available token.
     * If there is no current token, returns null.
     */
    async getCurrentUserAsync(options) {
        await this._getSessionLock.acquire();
        try {
            const currentUser = this._currentUser;
            // If user is cached and there is an accessToken or sessionSecret, return the user
            if (currentUser && (currentUser.accessToken || currentUser.sessionSecret)) {
                return currentUser;
            }
            if (internal_1.Config.offline) {
                return null;
            }
            const data = await this._readUserData();
            const accessToken = internal_1.UserSettings.accessToken();
            // No token, no session, no current user. Need to login
            if (!accessToken && !(data === null || data === void 0 ? void 0 : data.sessionSecret)) {
                return null;
            }
            try {
                if (accessToken) {
                    return await this._getProfileAsync({
                        accessToken,
                        currentConnection: 'Access-Token-Authentication',
                    });
                }
                return await this._getProfileAsync({
                    currentConnection: data === null || data === void 0 ? void 0 : data.currentConnection,
                    sessionSecret: data === null || data === void 0 ? void 0 : data.sessionSecret,
                });
            }
            catch (e) {
                if (!(options && options.silent)) {
                    internal_1.Logger.global.warn('Fetching the user profile failed');
                    internal_1.Logger.global.warn(e);
                }
                if (e.code === 'UNAUTHORIZED_ERROR') {
                    return null;
                }
                throw e;
            }
        }
        finally {
            this._getSessionLock.release();
        }
    }
    /**
     * Get the current user and check if it's a robot.
     * If the user is not a robot, it will throw an error.
     */
    async getCurrentUserOnlyAsync() {
        const user = await this.getCurrentUserAsync();
        if (user && user.kind !== 'user') {
            throw new internal_1.XDLError('ROBOT_ACCOUNT_ERROR', 'This action is not supported for robot users.');
        }
        return user;
    }
    /**
     * Get the current user and check if it's a robot.
     * If the user is not a robot, it will throw an error.
     */
    async getCurrentRobotUserOnlyAsync() {
        const user = await this.getCurrentUserAsync();
        if (user && user.kind !== 'robot') {
            throw new internal_1.XDLError('USER_ACCOUNT_ERROR', 'This action is not supported for normal users.');
        }
        return user;
    }
    async getCurrentUsernameAsync() {
        const token = internal_1.UserSettings.accessToken();
        if (token) {
            const user = await this.getCurrentUserAsync();
            if (user === null || user === void 0 ? void 0 : user.username) {
                return user.username;
            }
        }
        const data = await this._readUserData();
        if (data === null || data === void 0 ? void 0 : data.username) {
            return data.username;
        }
        return null;
    }
    async getSessionAsync() {
        const token = internal_1.UserSettings.accessToken();
        if (token) {
            return { accessToken: token };
        }
        const data = await this._readUserData();
        if (data === null || data === void 0 ? void 0 : data.sessionSecret) {
            return { sessionSecret: data.sessionSecret };
        }
        return null;
    }
    /**
     * Create or update a user.
     */
    async createOrUpdateUserAsync(userData) {
        let currentUser = this._currentUser;
        if (!currentUser) {
            // attempt to get the current user
            currentUser = await this.getCurrentUserAsync();
        }
        if ((currentUser === null || currentUser === void 0 ? void 0 : currentUser.kind) === 'robot') {
            throw new internal_1.XDLError('ROBOT_ACCOUNT_ERROR', 'This action is not available for robot users');
        }
        const api = internal_1.ApiV2.clientForUser(currentUser);
        const { user: updatedUser } = await api.postAsync('auth/createOrUpdateUser', {
            userData: _prepareAuth0Profile(userData),
        });
        this._currentUser = Object.assign(Object.assign(Object.assign({}, this._currentUser), _parseAuth0Profile(updatedUser)), { kind: 'user' });
        return this._currentUser;
    }
    /**
     * Logout
     */
    async logoutAsync() {
        var _a, _b;
        if (((_a = this._currentUser) === null || _a === void 0 ? void 0 : _a.kind) === 'robot') {
            throw new internal_1.XDLError('ROBOT_ACCOUNT_ERROR', 'This action is not available for robot users');
        }
        // Only send logout events events for users without access tokens
        if (this._currentUser && !((_b = this._currentUser) === null || _b === void 0 ? void 0 : _b.accessToken)) {
            internal_1.Analytics.logEvent('Logout', {
                userId: this._currentUser.userId,
                username: this._currentUser.username,
                currentConnection: this._currentUser.currentConnection,
            });
        }
        this._currentUser = null;
        // Delete saved auth info
        await internal_1.UserSettings.deleteKeyAsync('auth');
    }
    /**
     * Forgot Password
     */
    async forgotPasswordAsync(usernameOrEmail) {
        const apiAnonymous = internal_1.ApiV2.clientForUser();
        return apiAnonymous.postAsync('auth/forgotPasswordAsync', {
            usernameOrEmail,
        });
    }
    /**
     * Get profile given token data. Errors if token is not valid or if no
     * user profile is returned.
     *
     * This method is called by all public authentication methods of `UserManager`
     * except `logoutAsync`. Therefore, we use this method as a way to:
     *  - update the UserSettings store with the current token and user id
     *  - update UserManager._currentUser
     *  - Fire login analytics events
     *
     * Also updates UserManager._currentUser.
     *
     * @private
     */
    async _getProfileAsync({ currentConnection, sessionSecret, accessToken, }) {
        let user;
        const api = internal_1.ApiV2.clientForUser({
            sessionSecret,
            accessToken,
        });
        user = await api.getAsync('auth/userInfo');
        if (!user) {
            throw new Error('Unable to fetch user.');
        }
        user = Object.assign(Object.assign({}, _parseAuth0Profile(user)), { 
            // We need to inherit the "robot" type only, the rest is considered "user" but returned as "person".
            kind: user.user_type === 'robot' ? 'robot' : 'user', currentConnection,
            sessionSecret,
            accessToken });
        // Create a "username" to use in current terminal UI (e.g. expo whoami)
        if (user.kind === 'robot') {
            user.username = user.givenName ? `${user.givenName} (robot)` : 'robot';
        }
        // note: do not persist the authorization token, must be env-var only
        if (!accessToken) {
            await internal_1.UserSettings.setAsync('auth', {
                userId: user.userId,
                username: user.username,
                currentConnection,
                sessionSecret,
            });
        }
        // If no currentUser, or currentUser.id differs from profiles
        // user id, that means we have a new login
        if ((!this._currentUser || this._currentUser.userId !== user.userId) &&
            user.username &&
            user.username !== '') {
            if (!accessToken) {
                // Only send login events for users without access tokens
                internal_1.Analytics.logEvent('Login', {
                    userId: user.userId,
                    currentConnection: user.currentConnection,
                    username: user.username,
                });
            }
            internal_1.Analytics.setUserProperties(user.username, {
                userId: user.userId,
                currentConnection: user.currentConnection,
                username: user.username,
                userType: user.kind,
            });
        }
        this._currentUser = user;
        return user;
    }
}
exports.UserManagerInstance = UserManagerInstance;
let __globalInstance;
exports.default = UserManagerInstance.getGlobalInstance();
/** Private Methods **/
function _parseAuth0Profile(rawProfile) {
    if (!rawProfile || typeof rawProfile !== 'object') {
        return rawProfile;
    }
    return Object.keys(rawProfile).reduce((p, key) => {
        p[camelCase_1.default(key)] = _parseAuth0Profile(rawProfile[key]);
        return p;
    }, {});
}
function _prepareAuth0Profile(niceProfile) {
    if (typeof niceProfile !== 'object') {
        return niceProfile;
    }
    return Object.keys(niceProfile).reduce((p, key) => {
        p[snakeCase_1.default(key)] = _prepareAuth0Profile(niceProfile[key]);
        return p;
    }, {});
}
//# sourceMappingURL=User.js.map
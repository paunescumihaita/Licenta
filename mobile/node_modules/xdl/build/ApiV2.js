"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const concat_stream_1 = __importDefault(require("concat-stream"));
const merge_1 = __importDefault(require("lodash/merge"));
const querystring_1 = __importDefault(require("querystring"));
const internal_1 = require("./internal");
exports.MAX_CONTENT_LENGTH = 100 /* MB */ * 1024 * 1024;
exports.MAX_BODY_LENGTH = 100 /* MB */ * 1024 * 1024;
// These aren't constants because some commands switch between staging and prod
function _rootBaseUrl() {
    return `${internal_1.Config.api.scheme}://${internal_1.Config.api.host}`;
}
function _apiBaseUrl() {
    let rootBaseUrl = _rootBaseUrl();
    if (internal_1.Config.api.port) {
        rootBaseUrl += ':' + internal_1.Config.api.port;
    }
    return rootBaseUrl + '/--/api/v2';
}
async function _convertFormDataToBuffer(formData) {
    return new Promise(resolve => {
        formData.pipe(concat_stream_1.default({ encoding: 'buffer' }, data => resolve({ data })));
    });
}
class ApiV2Error extends Error {
    constructor(message, code = 'UNKNOWN') {
        super(message);
        this.name = 'ApiV2Error';
        this._isApiError = true;
        this.code = code;
    }
}
exports.ApiV2Error = ApiV2Error;
class ApiV2Client {
    constructor(options = {}) {
        this.sessionSecret = null;
        this.accessToken = null;
        if (options.accessToken) {
            this.accessToken = options.accessToken;
        }
        if (options.sessionSecret) {
            this.sessionSecret = options.sessionSecret;
        }
    }
    static clientForUser(user) {
        if (user) {
            return new ApiV2Client(user);
        }
        return new ApiV2Client();
    }
    static setClientName(name) {
        ApiV2Client.exponentClient = name;
    }
    async getAsync(methodName, args = {}, extraOptions, returnEntireResponse = false) {
        return this._requestAsync(methodName, {
            httpMethod: 'get',
            queryParameters: args,
        }, extraOptions, returnEntireResponse);
    }
    async postAsync(methodName, data, extraOptions, returnEntireResponse = false) {
        return this._requestAsync(methodName, {
            httpMethod: 'post',
            body: data,
        }, extraOptions, returnEntireResponse);
    }
    async putAsync(methodName, data, extraOptions, returnEntireResponse = false) {
        return this._requestAsync(methodName, {
            httpMethod: 'put',
            body: data,
        }, extraOptions, returnEntireResponse);
    }
    async patchAsync(methodName, data, extraOptions, returnEntireResponse = false) {
        return this._requestAsync(methodName, {
            httpMethod: 'patch',
            body: data,
        }, extraOptions, returnEntireResponse);
    }
    async deleteAsync(methodName, args = {}, extraOptions, returnEntireResponse = false) {
        return this._requestAsync(methodName, {
            httpMethod: 'delete',
            queryParameters: args,
        }, extraOptions, returnEntireResponse);
    }
    async uploadFormDataAsync(methodName, formData) {
        const options = { httpMethod: 'put' };
        const { data } = await _convertFormDataToBuffer(formData);
        const uploadOptions = {
            headers: formData.getHeaders(),
            data,
        };
        return await this._requestAsync(methodName, options, undefined, false, uploadOptions);
    }
    async _requestAsync(methodName, options, extraRequestOptions = {}, returnEntireResponse = false, uploadOptions) {
        var _a, _b, _c;
        const url = `${_apiBaseUrl()}/${methodName}`;
        let reqOptions = {
            url,
            method: options.httpMethod,
            headers: {
                'Exponent-Client': ApiV2Client.exponentClient,
            },
        };
        // Handle auth method, prioritizing authorization tokens before session secrets
        if (this.accessToken) {
            reqOptions.headers['Authorization'] = `Bearer ${this.accessToken}`;
        }
        else if (this.sessionSecret) {
            reqOptions.headers['Expo-Session'] = this.sessionSecret;
        }
        // Handle qs
        if (options.queryParameters) {
            reqOptions.params = options.queryParameters;
            reqOptions.paramsSerializer = querystring_1.default.stringify;
        }
        // Handle body
        if (options.body) {
            reqOptions.data = options.body;
        }
        if (!extraRequestOptions.hasOwnProperty('timeout') && internal_1.ConnectionStatus.isOffline()) {
            reqOptions.timeout = 1;
        }
        reqOptions = merge_1.default({}, reqOptions, extraRequestOptions, uploadOptions, {
            maxContentLength: exports.MAX_CONTENT_LENGTH,
            maxBodyLength: exports.MAX_BODY_LENGTH,
        });
        let response;
        let result;
        try {
            response = await axios_1.default.request(reqOptions);
            result = response.data;
        }
        catch (e) {
            if ((_c = (_b = (_a = e === null || e === void 0 ? void 0 : e.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.errors) === null || _c === void 0 ? void 0 : _c.length) {
                result = e.response.data;
            }
            else {
                throw e;
            }
        }
        if (result.errors && result.errors.length) {
            const responseError = result.errors[0];
            const error = new ApiV2Error(responseError.message, responseError.code);
            error.serverStack = responseError.stack;
            error.details = responseError.details;
            error.metadata = responseError.metadata;
            throw error;
        }
        return returnEntireResponse ? response : result.data;
    }
}
exports.default = ApiV2Client;
ApiV2Client.exponentClient = 'xdl';
//# sourceMappingURL=ApiV2.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const form_data_1 = __importDefault(require("form-data"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const chunk_1 = __importDefault(require("lodash/chunk"));
const get_1 = __importDefault(require("lodash/get"));
const set_1 = __importDefault(require("lodash/set"));
const uniqBy_1 = __importDefault(require("lodash/uniqBy"));
const md5hex_1 = __importDefault(require("md5hex"));
const minimatch_1 = __importDefault(require("minimatch"));
const path_1 = __importDefault(require("path"));
const url_join_1 = __importDefault(require("url-join"));
const internal_1 = require("./internal");
const EXPO_CDN = 'https://d1wp6m56sqw74a.cloudfront.net';
async function resolveGoogleServicesFile(projectRoot, manifest) {
    var _a, _b;
    if ((_a = manifest.android) === null || _a === void 0 ? void 0 : _a.googleServicesFile) {
        const contents = await fs_extra_1.default.readFile(path_1.default.resolve(projectRoot, manifest.android.googleServicesFile), 'utf8');
        manifest.android.googleServicesFile = contents;
    }
    if ((_b = manifest.ios) === null || _b === void 0 ? void 0 : _b.googleServicesFile) {
        const contents = await fs_extra_1.default.readFile(path_1.default.resolve(projectRoot, manifest.ios.googleServicesFile), 'base64');
        manifest.ios.googleServicesFile = contents;
    }
}
exports.resolveGoogleServicesFile = resolveGoogleServicesFile;
/**
 * Get all fields in the manifest that match assets, then filter the ones that aren't set.
 *
 * @param manifest
 * @returns Asset fields that the user has set like ["icon", "splash.image", ...]
 */
async function getAssetFieldPathsForManifestAsync(manifest) {
    // String array like ["icon", "notification.icon", "loading.icon", "loading.backgroundImage", "ios.icon", ...]
    const sdkAssetFieldPaths = await internal_1.ExpSchema.getAssetSchemasAsync(manifest.sdkVersion);
    return sdkAssetFieldPaths.filter(assetSchema => get_1.default(manifest, assetSchema));
}
async function resolveManifestAssets({ projectRoot, manifest, resolver, strict = false, }) {
    try {
        // Asset fields that the user has set like ["icon", "splash.image"]
        const assetSchemas = await getAssetFieldPathsForManifestAsync(manifest);
        // Get the URLs
        const urls = await Promise.all(assetSchemas.map(async (manifestField) => {
            const pathOrURL = get_1.default(manifest, manifestField);
            if (pathOrURL.match(/^https?:\/\/(.*)$/)) {
                // It's a remote URL
                return pathOrURL;
            }
            else if (fs_extra_1.default.existsSync(path_1.default.resolve(projectRoot, pathOrURL))) {
                return await resolver(pathOrURL);
            }
            else {
                const err = new Error('Could not resolve local asset.');
                err.localAssetPath = pathOrURL;
                err.manifestField = manifestField;
                throw err;
            }
        }));
        // Set the corresponding URL fields
        assetSchemas.forEach((manifestField, index) => set_1.default(manifest, `${manifestField}Url`, urls[index]));
    }
    catch (e) {
        let logMethod = internal_1.ProjectUtils.logWarning;
        if (strict) {
            logMethod = internal_1.ProjectUtils.logError;
        }
        if (e.localAssetPath) {
            logMethod(projectRoot, 'expo', `Unable to resolve asset "${e.localAssetPath}" from "${e.manifestField}" in your app.json or app.config.js`);
        }
        else {
            logMethod(projectRoot, 'expo', `Warning: Unable to resolve manifest assets. Icons might not work. ${e.message}.`);
        }
        if (strict) {
            throw new Error('Resolving assets failed.');
        }
    }
}
exports.resolveManifestAssets = resolveManifestAssets;
/**
 * Configures exp, preparing it for asset export
 *
 * @modifies {exp}
 *
 */
async function _configureExpForAssets(projectRoot, exp, assets) {
    // Add google services file if it exists
    await resolveGoogleServicesFile(projectRoot, exp);
    // Convert asset patterns to a list of asset strings that match them.
    // Assets strings are formatted as `asset_<hash>.<type>` and represent
    // the name that the file will have in the app bundle. The `asset_` prefix is
    // needed because android doesn't support assets that start with numbers.
    if (exp.assetBundlePatterns) {
        const fullPatterns = exp.assetBundlePatterns.map((p) => path_1.default.join(projectRoot, p));
        // Only log the patterns in debug mode, if they aren't already defined in the app.json, then all files will be targeted.
        internal_1.Logger.global.info('\nProcessing asset bundle patterns:');
        fullPatterns.forEach(p => internal_1.Logger.global.info('- ' + p));
        // The assets returned by the RN packager has duplicates so make sure we
        // only bundle each once.
        const bundledAssets = new Set();
        for (const asset of assets) {
            const file = asset.files && asset.files[0];
            const shouldBundle = '__packager_asset' in asset &&
                asset.__packager_asset &&
                file &&
                fullPatterns.some((p) => minimatch_1.default(file, p));
            internal_1.ProjectUtils.logDebug(projectRoot, 'expo', `${shouldBundle ? 'Include' : 'Exclude'} asset ${file}`);
            if (shouldBundle) {
                asset.fileHashes.forEach(hash => bundledAssets.add('asset_' + hash + ('type' in asset && asset.type ? '.' + asset.type : '')));
            }
        }
        exp.bundledAssets = [...bundledAssets];
        delete exp.assetBundlePatterns;
    }
    return exp;
}
async function publishAssetsAsync(options) {
    return exportAssetsAsync(Object.assign(Object.assign({}, options), { hostedUrl: EXPO_CDN, assetPath: '~assets' }));
}
exports.publishAssetsAsync = publishAssetsAsync;
async function exportAssetsAsync({ projectRoot, exp, hostedUrl, assetPath, outputDir, bundles, experimentalBundle, }) {
    internal_1.Logger.global.info('Analyzing assets');
    let assets;
    if (experimentalBundle) {
        assert_1.default(outputDir, 'outputDir must be specified when exporting to EAS');
        assets = uniqBy_1.default([...bundles.android.assets, ...bundles.ios.assets], asset => asset.hash);
    }
    else {
        const assetCdnPath = url_join_1.default(hostedUrl, assetPath);
        assets = await collectAssets(projectRoot, exp, assetCdnPath, bundles);
    }
    internal_1.Logger.global.info('Saving assets');
    if (assets.length > 0 && assets[0].fileHashes) {
        if (outputDir) {
            await saveAssetsAsync(projectRoot, assets, outputDir);
        }
        else {
            // No output directory defined, use remote url.
            await uploadAssetsAsync(projectRoot, assets);
        }
    }
    else {
        internal_1.Logger.global.info({ quiet: true }, 'No assets to upload, skipped.');
    }
    // Updates the manifest to reflect additional asset bundling + configs
    await _configureExpForAssets(projectRoot, exp, assets);
    return { exp, assets };
}
exports.exportAssetsAsync = exportAssetsAsync;
/**
 * Collect list of assets missing on host
 *
 * @param paths asset paths found locally that need to be uploaded.
 */
async function fetchMissingAssetsAsync(paths) {
    const user = await internal_1.UserManager.ensureLoggedInAsync();
    const api = internal_1.ApiV2.clientForUser(user);
    const result = await api.postAsync('assets/metadata', { keys: paths });
    const metas = result.metadata;
    const missing = paths.filter(key => !metas[key].exists);
    return missing;
}
function logAssetTask(projectRoot, action, pathName) {
    internal_1.ProjectUtils.logDebug(projectRoot, 'expo', `${action} ${pathName}`);
    const relativePath = pathName.replace(projectRoot, '');
    internal_1.Logger.global.info({ quiet: true }, `${action} ${relativePath}`);
}
// TODO(jesse): Add analytics for upload
async function uploadAssetsAsync(projectRoot, assets) {
    // Collect paths by key, also effectively handles duplicates in the array
    const paths = collectAssetPaths(assets);
    const missing = await fetchMissingAssetsAsync(Object.keys(paths));
    if (missing.length === 0) {
        internal_1.Logger.global.info({ quiet: true }, `No assets changed, skipped.`);
        return;
    }
    const keyChunks = chunk_1.default(missing, 5);
    // Upload them in chunks of 5 to prevent network and system issues.
    for (const keys of keyChunks) {
        const formData = new form_data_1.default();
        for (const key of keys) {
            const pathName = paths[key];
            logAssetTask(projectRoot, 'uploading', pathName);
            formData.append(key, fs_extra_1.default.createReadStream(pathName), pathName);
        }
        // TODO: Document what's going on
        const user = await internal_1.UserManager.ensureLoggedInAsync();
        const api = internal_1.ApiV2.clientForUser(user);
        await api.uploadFormDataAsync('assets/upload', formData);
    }
}
function collectAssetPaths(assets) {
    // Collect paths by key, also effectively handles duplicates in the array
    const paths = {};
    assets.forEach(asset => {
        asset.files.forEach((path, index) => {
            paths[asset.fileHashes[index]] = path;
        });
    });
    return paths;
}
async function saveAssetsAsync(projectRoot, assets, outputDir) {
    // Collect paths by key, also effectively handles duplicates in the array
    const paths = collectAssetPaths(assets);
    // save files one chunk at a time
    const keyChunks = chunk_1.default(Object.keys(paths), 5);
    for (const keys of keyChunks) {
        const promises = [];
        for (const key of keys) {
            const pathName = paths[key];
            logAssetTask(projectRoot, 'saving', pathName);
            const assetPath = path_1.default.resolve(outputDir, 'assets', key);
            // copy file over to assetPath
            promises.push(fs_extra_1.default.copy(pathName, assetPath));
        }
        await Promise.all(promises);
    }
    internal_1.Logger.global.info('Files successfully saved.');
}
/**
 * Collects all the assets declared in the android app, ios app and manifest
 *
 * @param {string} hostedAssetPrefix
 *    The path where assets are hosted (ie) http://xxx.cloudfront.com/assets/
 *
 * @modifies {exp} Replaces relative asset paths in the manifest with hosted URLS
 *
 */
async function collectAssets(projectRoot, exp, hostedAssetPrefix, bundles) {
    // Resolve manifest assets to their hosted URL and add them to the list of assets to
    // be uploaded. Modifies exp.
    const manifestAssets = [];
    await resolveManifestAssets({
        projectRoot,
        manifest: exp,
        async resolver(assetPath) {
            const absolutePath = path_1.default.resolve(projectRoot, assetPath);
            const contents = await fs_extra_1.default.readFile(absolutePath);
            const hash = md5hex_1.default(contents);
            manifestAssets.push({ files: [absolutePath], fileHashes: [hash], hash });
            return url_join_1.default(hostedAssetPrefix, hash);
        },
        strict: true,
    });
    return [...bundles.ios.assets, ...bundles.android.assets, ...manifestAssets];
}
//# sourceMappingURL=ProjectAssets.js.map
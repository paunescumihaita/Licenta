"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("@expo/config");
const config_plugins_1 = require("@expo/config-plugins");
const osascript = __importStar(require("@expo/osascript"));
const spawn_async_1 = __importDefault(require("@expo/spawn-async"));
const chalk_1 = __importDefault(require("chalk"));
const child_process_1 = __importStar(require("child_process"));
const trim_1 = __importDefault(require("lodash/trim"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const progress_1 = __importDefault(require("progress"));
const prompts_1 = __importDefault(require("prompts"));
const semver_1 = __importDefault(require("semver"));
const internal_1 = require("./internal");
let _lastUrl = null;
let _isAdbOwner = null;
const BEGINNING_OF_ADB_ERROR_MESSAGE = 'error: ';
const CANT_START_ACTIVITY_ERROR = 'Activity not started, unable to resolve Intent';
const INSTALL_WARNING_TIMEOUT = 60 * 1000;
const EMULATOR_MAX_WAIT_TIMEOUT = 60 * 1000 * 3;
function whichEmulator() {
    if (process.env.ANDROID_HOME) {
        return `${process.env.ANDROID_HOME}/emulator/emulator`;
    }
    return 'emulator';
}
function whichADB() {
    if (process.env.ANDROID_HOME) {
        return `${process.env.ANDROID_HOME}/platform-tools/adb`;
    }
    return 'adb';
}
/**
 * Returns a list of emulator names.
 */
async function getEmulatorsAsync() {
    try {
        const { stdout } = await spawn_async_1.default(whichEmulator(), ['-list-avds']);
        return stdout
            .split(os_1.default.EOL)
            .filter(Boolean)
            .map(name => ({
            name,
            type: 'emulator',
            // unsure from this
            isBooted: false,
            isAuthorized: true,
        }));
    }
    catch (_a) {
        return [];
    }
}
/**
 * Return the Emulator name for an emulator ID, this can be used to determine if an emulator is booted.
 *
 * @param emulatorId a value like `emulator-5554` from `abd devices`
 */
async function getAbdNameForEmulatorIdAsync(emulatorId) {
    var _a;
    return ((_a = trim_1.default(await getAdbOutputAsync(['-s', emulatorId, 'emu', 'avd', 'name']))
        .split(/\r?\n/)
        .shift()) !== null && _a !== void 0 ? _a : null);
}
async function getAllAvailableDevicesAsync() {
    const bootedDevices = await getAttachedDevicesAsync();
    const data = await getEmulatorsAsync();
    const connectedNames = bootedDevices.map(({ name }) => name);
    const offlineEmulators = data
        .filter(({ name }) => !connectedNames.includes(name))
        .map(({ name, type }) => {
        return {
            name,
            type,
            isBooted: false,
            // TODO: Are emulators always authorized?
            isAuthorized: true,
        };
    });
    const allDevices = bootedDevices.concat(offlineEmulators);
    if (!allDevices.length) {
        const genymotionMessage = `https://developer.android.com/studio/run/device.html#developer-device-options. If you are using Genymotion go to Settings -> ADB, select "Use custom Android SDK tools", and point it at your Android SDK directory.`;
        throw new Error(`No Android connected device found, and no emulators could be started automatically.\nPlease connect a device or create an emulator (https://docs.expo.io/workflow/android-studio-emulator).\nThen follow the instructions here to enable USB debugging:\n${genymotionMessage}`);
    }
    return allDevices;
}
exports.getAllAvailableDevicesAsync = getAllAvailableDevicesAsync;
/**
 * Returns true when a device's splash screen animation has stopped.
 * This can be used to detect when a device is fully booted and ready to use.
 *
 * @param pid
 */
async function isBootAnimationCompleteAsync(pid) {
    try {
        const props = await getPropertyDataForDeviceAsync({ pid }, PROP_BOOT_ANIMATION_STATE);
        return !!props[PROP_BOOT_ANIMATION_STATE].match(/stopped/);
    }
    catch (_a) {
        return false;
    }
}
async function startEmulatorAsync(device) {
    internal_1.Logger.global.info(`\u203A Attempting to open emulator: ${device.name}`);
    // Start a process to open an emulator
    const emulatorProcess = child_process_1.default.spawn(whichEmulator(), [
        `@${device.name}`,
    ], {
        stdio: 'ignore',
        detached: true,
    });
    emulatorProcess.unref();
    return new Promise((resolve, reject) => {
        const waitTimer = setInterval(async () => {
            const bootedDevices = await getAttachedDevicesAsync();
            const connected = bootedDevices.find(({ name }) => name === device.name);
            if (connected) {
                const isBooted = await isBootAnimationCompleteAsync(connected.pid);
                if (isBooted) {
                    stopWaiting();
                    resolve(connected);
                }
            }
        }, 1000);
        // Reject command after timeout
        const maxTimer = setTimeout(() => {
            const manualCommand = `${whichEmulator()} @${device.name}`;
            stopWaitingAndReject(`It took too long to start the Android emulator: ${device.name}. You can try starting the emulator manually from the terminal with: ${manualCommand}`);
        }, EMULATOR_MAX_WAIT_TIMEOUT);
        const stopWaiting = () => {
            clearTimeout(maxTimer);
            clearInterval(waitTimer);
        };
        const stopWaitingAndReject = (message) => {
            stopWaiting();
            reject(new Error(message));
            clearInterval(waitTimer);
        };
        emulatorProcess.on('error', ({ message }) => stopWaitingAndReject(message));
        emulatorProcess.on('exit', () => {
            const manualCommand = `${whichEmulator()} @${device.name}`;
            stopWaitingAndReject(`The emulator (${device.name}) quit before it finished opening. You can try starting the emulator manually from the terminal with: ${manualCommand}`);
        });
    });
}
// TODO: This is very expensive for some operations.
async function getAttachedDevicesAsync() {
    const output = await getAdbOutputAsync(['devices', '-l']);
    const splitItems = output.trim().replace(/\n$/, '').split(os_1.default.EOL);
    // First line is `"List of devices attached"`, remove it
    // @ts-ignore: todo
    const attachedDevices = splitItems
        .slice(1, splitItems.length)
        .map(line => {
        // unauthorized: ['FA8251A00719', 'unauthorized', 'usb:338690048X', 'transport_id:5']
        // authorized: ['FA8251A00719', 'device', 'usb:336592896X', 'product:walleye', 'model:Pixel_2', 'device:walleye', 'transport_id:4']
        // emulator: ['emulator-5554', 'offline', 'transport_id:1']
        const props = line.split(' ').filter(Boolean);
        const isAuthorized = props[1] !== 'unauthorized';
        const type = line.includes('emulator') ? 'emulator' : 'device';
        return { props, type, isAuthorized };
    })
        .filter(({ props: [pid] }) => !!pid);
    const devicePromises = attachedDevices.map(async (props) => {
        var _a;
        const { type, props: [pid, ...deviceInfo], isAuthorized, } = props;
        let name = null;
        if (type === 'device') {
            if (isAuthorized) {
                // Possibly formatted like `model:Pixel_2`
                // Transform to `Pixel_2`
                const modelItem = deviceInfo.find(info => info.includes('model:'));
                if (modelItem) {
                    name = modelItem.replace('model:', '');
                }
            }
            // unauthorized devices don't have a name available to read
            if (!name) {
                // Device FA8251A00719
                name = `Device ${pid}`;
            }
        }
        else {
            // Given an emulator pid, get the emulator name which can be used to start the emulator later.
            name = (_a = (await getAbdNameForEmulatorIdAsync(pid))) !== null && _a !== void 0 ? _a : '';
        }
        return {
            pid,
            name,
            type,
            isAuthorized,
            isBooted: true,
        };
    });
    return Promise.all(devicePromises);
}
exports.getAttachedDevicesAsync = getAttachedDevicesAsync;
function isPlatformSupported() {
    return (process.platform === 'darwin' || process.platform === 'win32' || process.platform === 'linux');
}
exports.isPlatformSupported = isPlatformSupported;
async function adbAlreadyRunning(adb) {
    try {
        const result = await spawn_async_1.default(adb, ['start-server']);
        const lines = trim_1.default(result.stderr).split(/\r?\n/);
        return lines.includes('* daemon started successfully') === false;
    }
    catch (e) {
        let errorMessage = trim_1.default(e.stderr || e.stdout);
        if (errorMessage.startsWith(BEGINNING_OF_ADB_ERROR_MESSAGE)) {
            errorMessage = errorMessage.substring(BEGINNING_OF_ADB_ERROR_MESSAGE.length);
        }
        throw new Error(errorMessage);
    }
}
async function getAdbOutputAsync(args) {
    await internal_1.Binaries.addToPathAsync('adb');
    const adb = whichADB();
    if (_isAdbOwner === null) {
        const alreadyRunning = await adbAlreadyRunning(adb);
        _isAdbOwner = alreadyRunning === false;
    }
    if (internal_1.Env.isDebug()) {
        internal_1.Logger.global.info([adb, ...args].join(' '));
    }
    try {
        const result = await spawn_async_1.default(adb, args);
        return result.stdout;
    }
    catch (e) {
        // TODO: Support heap corruption for adb 29 (process exits with code -1073740940) (windows and linux)
        let errorMessage = (e.stderr || e.stdout || e.message).trim();
        if (errorMessage.startsWith(BEGINNING_OF_ADB_ERROR_MESSAGE)) {
            errorMessage = errorMessage.substring(BEGINNING_OF_ADB_ERROR_MESSAGE.length);
        }
        throw new Error(errorMessage);
    }
}
exports.getAdbOutputAsync = getAdbOutputAsync;
async function getAdbFileOutputAsync(args, encoding) {
    await internal_1.Binaries.addToPathAsync('adb');
    const adb = whichADB();
    if (_isAdbOwner === null) {
        const alreadyRunning = await adbAlreadyRunning(adb);
        _isAdbOwner = alreadyRunning === false;
    }
    try {
        return await child_process_1.execFileSync(adb, args, {
            encoding,
        });
    }
    catch (e) {
        let errorMessage = (e.stderr || e.stdout || e.message).trim();
        if (errorMessage.startsWith(BEGINNING_OF_ADB_ERROR_MESSAGE)) {
            errorMessage = errorMessage.substring(BEGINNING_OF_ADB_ERROR_MESSAGE.length);
        }
        throw new Error(errorMessage);
    }
}
exports.getAdbFileOutputAsync = getAdbFileOutputAsync;
async function _isDeviceAuthorizedAsync(device) {
    // TODO: Get the latest version of the device in case isAuthorized changes.
    return device.isAuthorized;
}
async function isInstalledAsync(device, androidPackage) {
    const packages = await getAdbOutputAsync(adbPidArgs(device.pid, 'shell', 'pm', 'list', 'packages', androidPackage));
    const lines = packages.split(/\r?\n/);
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line === `package:${androidPackage}`) {
            return true;
        }
    }
    return false;
}
// Expo installed
async function _isExpoInstalledAsync(device) {
    return await isInstalledAsync(device, 'host.exp.exponent');
}
async function ensureDevClientInstalledAsync(device, applicationId) {
    if (!(await isInstalledAsync(device, applicationId))) {
        throw new Error(`The development client (${applicationId}) for this project is not installed. ` +
            `Please build and install the client on the simulator first.\n${internal_1.learnMore('https://docs.expo.io/clients/distribution-for-android/')}`);
    }
}
async function getExpoVersionAsync(device) {
    const info = await getAdbOutputAsync(adbPidArgs(device.pid, 'shell', 'dumpsys', 'package', 'host.exp.exponent'));
    const regex = /versionName=([0-9.]+)/;
    const regexMatch = regex.exec(info);
    if (!regexMatch || regexMatch.length < 2) {
        return null;
    }
    return regexMatch[1];
}
async function isClientOutdatedAsync(device, sdkVersion) {
    var _a;
    const versions = await internal_1.Versions.versionsAsync();
    const clientForSdk = await getClientForSDK(sdkVersion);
    const latestVersionForSdk = (_a = clientForSdk === null || clientForSdk === void 0 ? void 0 : clientForSdk.version) !== null && _a !== void 0 ? _a : versions.androidVersion;
    const installedVersion = await getExpoVersionAsync(device);
    return !installedVersion || semver_1.default.lt(installedVersion, latestVersionForSdk);
}
async function installExpoAsync({ device, url, version, }) {
    const bar = new progress_1.default('Downloading the Expo Go app [:bar] :percent :etas', {
        total: 100,
        width: 64,
    });
    let warningTimer;
    const setWarningTimer = () => {
        if (warningTimer) {
            clearTimeout(warningTimer);
        }
        return setTimeout(() => {
            internal_1.Logger.global.info('');
            internal_1.Logger.global.info('This download is taking longer than expected. You can also try downloading the clients from the website at https://expo.io/tools');
        }, INSTALL_WARNING_TIMEOUT);
    };
    internal_1.Logger.notifications.info({ code: internal_1.NotificationCode.START_LOADING });
    warningTimer = setWarningTimer();
    const path = await internal_1.downloadApkAsync(url, progress => bar.tick(1, progress));
    internal_1.Logger.notifications.info({ code: internal_1.NotificationCode.STOP_LOADING });
    if (version) {
        internal_1.Logger.global.info(`Installing Expo Go ${version} on device`);
    }
    else {
        internal_1.Logger.global.info(`Installing Expo Go on device`);
    }
    internal_1.Logger.notifications.info({ code: internal_1.NotificationCode.START_LOADING });
    warningTimer = setWarningTimer();
    const result = await installOnDeviceAsync(device, { binaryPath: path });
    internal_1.Logger.notifications.info({ code: internal_1.NotificationCode.STOP_LOADING });
    clearTimeout(warningTimer);
    return result;
}
exports.installExpoAsync = installExpoAsync;
async function installOnDeviceAsync(device, { binaryPath }) {
    return await getAdbOutputAsync(adbPidArgs(device.pid, 'install', '-r', '-d', binaryPath));
}
exports.installOnDeviceAsync = installOnDeviceAsync;
async function isDeviceBootedAsync({ name, } = {}) {
    var _a, _b;
    const devices = await getAttachedDevicesAsync();
    if (!name) {
        return (_a = devices[0]) !== null && _a !== void 0 ? _a : null;
    }
    return (_b = devices.find(device => device.name === name)) !== null && _b !== void 0 ? _b : null;
}
exports.isDeviceBootedAsync = isDeviceBootedAsync;
async function uninstallExpoAsync(device) {
    internal_1.Logger.global.info('Uninstalling Expo Go from Android device.');
    // we need to check if its installed, else we might bump into "Failure [DELETE_FAILED_INTERNAL_ERROR]"
    const isInstalled = await _isExpoInstalledAsync(device);
    if (!isInstalled) {
        return;
    }
    try {
        return await getAdbOutputAsync(adbPidArgs(device.pid, 'uninstall', 'host.exp.exponent'));
    }
    catch (e) {
        internal_1.Logger.global.error('Could not uninstall Expo Go from your device, please uninstall Expo Go manually and try again.');
        throw e;
    }
}
exports.uninstallExpoAsync = uninstallExpoAsync;
async function upgradeExpoAsync(options) {
    const { url, version } = options || {};
    try {
        const devices = await getAttachedDevicesAsync();
        if (!devices.length) {
            throw new Error('no devices connected');
        }
        const device = await attemptToStartEmulatorOrAssertAsync(devices[0]);
        if (!device) {
            return false;
        }
        await uninstallExpoAsync(device);
        await installExpoAsync({ device, url, version });
        if (_lastUrl) {
            internal_1.Logger.global.info(`Opening ${_lastUrl} in Expo.`);
            await getAdbOutputAsync([
                'shell',
                'am',
                'start',
                '-a',
                'android.intent.action.VIEW',
                '-d',
                _lastUrl,
            ]);
            _lastUrl = null;
        }
        return true;
    }
    catch (e) {
        internal_1.Logger.global.error(e.message);
        return false;
    }
}
exports.upgradeExpoAsync = upgradeExpoAsync;
async function _openUrlAsync({ pid, url, applicationId, }) {
    // NOTE(brentvatne): temporary workaround! launch Expo Go first, then
    // launch the project!
    // https://github.com/expo/expo/issues/7772
    // adb shell monkey -p host.exp.exponent -c android.intent.category.LAUNCHER 1
    const openClient = await getAdbOutputAsync(adbPidArgs(pid, 'shell', 'monkey', '-p', applicationId, '-c', 'android.intent.category.LAUNCHER', '1'));
    if (openClient.includes(CANT_START_ACTIVITY_ERROR)) {
        throw new Error(openClient.substring(openClient.indexOf('Error: ')));
    }
    const openProject = await getAdbOutputAsync(adbPidArgs(pid, 'shell', 'am', 'start', '-a', 'android.intent.action.VIEW', '-d', url));
    if (openProject.includes(CANT_START_ACTIVITY_ERROR)) {
        throw new Error(openProject.substring(openProject.indexOf('Error: ')));
    }
    return openProject;
}
function getUnixPID(port) {
    return child_process_1.execFileSync('lsof', [`-i:${port}`, '-P', '-t', '-sTCP:LISTEN'], {
        encoding: 'utf8',
        stdio: ['pipe', 'pipe', 'ignore'],
    })
        .split('\n')[0]
        .trim();
}
async function activateEmulatorWindowAsync(device) {
    var _a;
    if (
    // only mac is supported for now.
    process.platform !== 'darwin' ||
        // can only focus emulators
        device.type !== 'emulator') {
        return;
    }
    // Google Emulator ID: `emulator-5554` -> `5554`
    const androidPid = (_a = device.pid.match(/-(\d+)/)) === null || _a === void 0 ? void 0 : _a[1];
    if (!androidPid) {
        return;
    }
    // Unix PID
    const pid = getUnixPID(androidPid);
    try {
        await osascript.execAsync(`
  tell application "System Events"
    set frontmost of the first process whose unix id is ${pid} to true
  end tell`);
    }
    catch (_b) {
        // noop -- this feature is very specific and subject to failure.
    }
}
exports.activateEmulatorWindowAsync = activateEmulatorWindowAsync;
async function openAppAsync(device, { packageName, mainActivity, }) {
    const targetActivityURI = mainActivity.includes('.')
        ? mainActivity
        : [packageName, mainActivity].filter(Boolean).join('/.');
    const openProject = await getAdbOutputAsync(adbPidArgs(device.pid, 'shell', 'am', 'start', 
    // FLAG_ACTIVITY_SINGLE_TOP -- If set, the activity will not be launched if it is already running at the top of the history stack.
    '-f', '0x20000000', '-n', targetActivityURI));
    if (openProject.includes(CANT_START_ACTIVITY_ERROR)) {
        throw new Error(openProject.substring(openProject.indexOf('Error: ')));
    }
    await activateEmulatorWindowAsync(device);
    return openProject;
}
exports.openAppAsync = openAppAsync;
async function attemptToStartEmulatorOrAssertAsync(device) {
    // TODO: Add a light-weight method for checking since a device could disconnect.
    if (!(await isDeviceBootedAsync(device))) {
        device = await startEmulatorAsync(device);
    }
    if (!(await _isDeviceAuthorizedAsync(device))) {
        logUnauthorized(device);
        return null;
    }
    return device;
}
exports.attemptToStartEmulatorOrAssertAsync = attemptToStartEmulatorOrAssertAsync;
function logUnauthorized(device) {
    internal_1.Logger.global.warn(`\nThis computer is not authorized for developing on ${chalk_1.default.bold(device.name)}. ${chalk_1.default.dim(internal_1.learnMore('https://expo.fyi/authorize-android-device'))}`);
}
// Keep a list of simulator UDIDs so we can prevent asking multiple times if a user wants to upgrade.
// This can prevent annoying interactions when they don't want to upgrade for whatever reason.
const hasPromptedToUpgrade = {};
async function openUrlAsync({ url, device, isDetached = false, sdkVersion, devClient = false, exp, projectRoot, }) {
    var _a;
    try {
        const bootedDevice = await attemptToStartEmulatorOrAssertAsync(device);
        if (!bootedDevice) {
            return;
        }
        await activateEmulatorWindowAsync(bootedDevice);
        device = bootedDevice;
        let installedExpo = false;
        let clientApplicationId = 'host.exp.exponent';
        if (devClient) {
            const applicationId = await config_plugins_1.AndroidConfig.Package.getApplicationIdAsync(projectRoot);
            if (!applicationId) {
                // TODO(ville): possibly need to compare Gradle project with app.json/config.ts
                // and show a helpful error message, if there's a mismatch.
                throw new Error(`Could not find applicationId in ${config_plugins_1.AndroidConfig.Paths.getAppBuildGradle(projectRoot)}`);
            }
            else {
                clientApplicationId = applicationId;
            }
            await ensureDevClientInstalledAsync(device, clientApplicationId);
        }
        else if (!isDetached) {
            let shouldInstall = !(await _isExpoInstalledAsync(device));
            const promptKey = (_a = device.pid) !== null && _a !== void 0 ? _a : 'unknown';
            if (!shouldInstall &&
                !hasPromptedToUpgrade[promptKey] &&
                (await isClientOutdatedAsync(device, sdkVersion))) {
                // Only prompt once per device, per run.
                hasPromptedToUpgrade[promptKey] = true;
                const confirm = await internal_1.Prompts.confirmAsync({
                    initial: true,
                    message: `Expo Go on ${device.name} (${device.type}) is outdated, would you like to upgrade?`,
                });
                if (confirm) {
                    await uninstallExpoAsync(device);
                    shouldInstall = true;
                }
            }
            if (shouldInstall) {
                const androidClient = await getClientForSDK(sdkVersion);
                await installExpoAsync(Object.assign({ device }, androidClient));
                installedExpo = true;
            }
            _lastUrl = url;
            // _checkExpoUpToDateAsync(); // let this run in background
        }
        internal_1.Logger.global.info(`Opening ${chalk_1.default.underline(url)} on ${chalk_1.default.bold(device.name)}`);
        try {
            await _openUrlAsync({ pid: device.pid, url, applicationId: clientApplicationId });
        }
        catch (e) {
            if (isDetached) {
                e.message = `Error running app. Have you installed the app already using Android Studio? Since you are detached you must build manually. ${e.message}`;
            }
            else {
                e.message = `Error running app. ${e.message}`;
            }
            throw e;
        }
        if (device.type === 'emulator') {
            // TODO: Bring the emulator window to the front.
        }
        internal_1.Analytics.logEvent('Open Url on Device', {
            platform: 'android',
            installedExpo,
        });
    }
    catch (e) {
        e.message = `Error running adb: ${e.message}`;
        throw e;
    }
}
async function getClientForSDK(sdkVersionString) {
    if (!sdkVersionString) {
        return null;
    }
    const sdkVersion = (await internal_1.Versions.sdkVersionsAsync())[sdkVersionString];
    if (!sdkVersion) {
        return null;
    }
    return {
        url: sdkVersion.androidClientUrl,
        version: sdkVersion.androidClientVersion,
    };
}
async function openProjectAsync({ projectRoot, shouldPrompt, devClient = false, device, }) {
    try {
        await startAdbReverseAsync(projectRoot);
        const projectUrl = await internal_1.UrlUtils.constructDeepLinkAsync(projectRoot);
        const { exp } = config_1.getConfig(projectRoot, {
            skipSDKVersionRequirement: true,
        });
        if (device) {
            const booted = await attemptToStartEmulatorOrAssertAsync(device);
            if (!booted) {
                return { success: false, error: 'escaped' };
            }
            device = booted;
        }
        else {
            const devices = await getAllAvailableDevicesAsync();
            let booted = devices[0];
            if (shouldPrompt) {
                booted = await promptForDeviceAsync(devices);
            }
            if (!booted) {
                return { success: false, error: 'escaped' };
            }
            device = booted;
        }
        await openUrlAsync({
            url: projectUrl,
            device,
            isDetached: !!exp.isDetached,
            sdkVersion: exp.sdkVersion,
            devClient,
            exp,
            projectRoot,
        });
        return { success: true, url: projectUrl };
    }
    catch (e) {
        internal_1.Logger.global.error(`Couldn't start project on Android: ${e.message}`);
        return { success: false, error: e };
    }
}
exports.openProjectAsync = openProjectAsync;
async function openWebProjectAsync({ projectRoot, shouldPrompt, }) {
    try {
        await startAdbReverseAsync(projectRoot);
        const projectUrl = await internal_1.Webpack.getUrlAsync(projectRoot);
        if (projectUrl === null) {
            return {
                success: false,
                error: `The web project has not been started yet`,
            };
        }
        const devices = await getAllAvailableDevicesAsync();
        let device = devices[0];
        if (shouldPrompt) {
            device = await promptForDeviceAsync(devices);
        }
        if (!device) {
            return { success: false, error: 'escaped' };
        }
        await openUrlAsync({ url: projectUrl, device, isDetached: true, projectRoot });
        return { success: true, url: projectUrl };
    }
    catch (e) {
        internal_1.Logger.global.error(`Couldn't open the web project on Android: ${e.message}`);
        return { success: false, error: e };
    }
}
exports.openWebProjectAsync = openWebProjectAsync;
// Adb reverse
async function startAdbReverseAsync(projectRoot) {
    const packagerInfo = await internal_1.ProjectSettings.readPackagerInfoAsync(projectRoot);
    const expRc = await config_1.readExpRcAsync(projectRoot);
    const userDefinedAdbReversePorts = expRc.extraAdbReversePorts || [];
    const adbReversePorts = [
        packagerInfo.packagerPort,
        packagerInfo.expoServerPort,
        ...userDefinedAdbReversePorts,
    ].filter(Boolean);
    const devices = await getAttachedDevicesAsync();
    for (const device of devices) {
        for (const port of adbReversePorts) {
            if (!(await adbReverse({ device, port }))) {
                return false;
            }
        }
    }
    return true;
}
exports.startAdbReverseAsync = startAdbReverseAsync;
async function stopAdbReverseAsync(projectRoot) {
    const packagerInfo = await internal_1.ProjectSettings.readPackagerInfoAsync(projectRoot);
    const expRc = await config_1.readExpRcAsync(projectRoot);
    const userDefinedAdbReversePorts = expRc.extraAdbReversePorts || [];
    const adbReversePorts = [
        packagerInfo.packagerPort,
        packagerInfo.expoServerPort,
        ...userDefinedAdbReversePorts,
    ].filter(Boolean);
    const devices = await getAttachedDevicesAsync();
    for (const device of devices) {
        for (const port of adbReversePorts) {
            await adbReverseRemove({ device, port });
        }
    }
}
exports.stopAdbReverseAsync = stopAdbReverseAsync;
async function adbReverse({ device, port }) {
    if (!(await _isDeviceAuthorizedAsync(device))) {
        return false;
    }
    try {
        await getAdbOutputAsync(adbPidArgs(device.pid, 'reverse', `tcp:${port}`, `tcp:${port}`));
        return true;
    }
    catch (e) {
        internal_1.Logger.global.warn(`Couldn't adb reverse: ${e.message}`);
        return false;
    }
}
async function adbReverseRemove({ device, port, }) {
    if (!(await _isDeviceAuthorizedAsync(device))) {
        return false;
    }
    try {
        await getAdbOutputAsync(adbPidArgs(device.pid, 'reverse', '--remove', `tcp:${port}`));
        return true;
    }
    catch (e) {
        // Don't send this to warn because we call this preemptively sometimes
        internal_1.Logger.global.debug(`Couldn't adb reverse remove: ${e.message}`);
        return false;
    }
}
function adbPidArgs(pid, ...options) {
    const args = [];
    if (pid) {
        args.push('-s', pid);
    }
    return args.concat(options);
}
const splashScreenDPIConstraints = [
    {
        dpi: 'mdpi',
        sizeMultiplier: 1,
    },
    {
        dpi: 'hdpi',
        sizeMultiplier: 1.5,
    },
    {
        dpi: 'xhdpi',
        sizeMultiplier: 2,
    },
    {
        dpi: 'xxhdpi',
        sizeMultiplier: 3,
    },
    {
        dpi: 'xxxhdpi',
        sizeMultiplier: 4,
    },
];
/**
 * Checks whether `resizeMode` is set to `native` and if `true` analyzes provided images for splashscreen
 * providing `Logger` feedback upon problems.
 * @param projectRoot - directory of the expo project
 * @since SDK33
 */
async function checkSplashScreenImages(projectRoot) {
    var _a, _b, _c, _d, _e, _f, _g;
    const { exp } = config_1.getConfig(projectRoot);
    // return before SDK33
    if (!internal_1.Versions.gteSdkVersion(exp, '33.0.0')) {
        return;
    }
    const splashScreenMode = (_e = (_c = (_b = (_a = exp.android) === null || _a === void 0 ? void 0 : _a.splash) === null || _b === void 0 ? void 0 : _b.resizeMode) !== null && _c !== void 0 ? _c : (_d = exp.splash) === null || _d === void 0 ? void 0 : _d.resizeMode) !== null && _e !== void 0 ? _e : 'contain';
    // only mode `native` is handled by this check
    if (splashScreenMode === 'contain' || splashScreenMode === 'cover') {
        return;
    }
    const generalSplashImagePath = (_f = exp.splash) === null || _f === void 0 ? void 0 : _f.image;
    if (!generalSplashImagePath) {
        internal_1.Logger.global.warn(`Couldn't read '${chalk_1.default.italic('splash.image')}' from ${chalk_1.default.italic('app.json')}. Provide asset that would serve as baseline splash image.`);
        return;
    }
    const generalSplashImage = await internal_1.ImageUtils.getImageDimensionsAsync(projectRoot, generalSplashImagePath);
    if (!generalSplashImage) {
        internal_1.Logger.global.warn(`Couldn't read dimensions of provided splash image '${chalk_1.default.italic(generalSplashImagePath)}'. Does the file exist?`);
        return;
    }
    const androidSplash = (_g = exp.android) === null || _g === void 0 ? void 0 : _g.splash;
    const androidSplashImages = [];
    for (const { dpi, sizeMultiplier } of splashScreenDPIConstraints) {
        const imageRelativePath = androidSplash === null || androidSplash === void 0 ? void 0 : androidSplash[dpi];
        if (imageRelativePath) {
            const splashImage = await internal_1.ImageUtils.getImageDimensionsAsync(projectRoot, imageRelativePath);
            if (!splashImage) {
                internal_1.Logger.global.warn(`Couldn't read dimensions of provided splash image '${chalk_1.default.italic(imageRelativePath)}'. Does the file exist?`);
                continue;
            }
            const { width, height } = splashImage;
            const expectedWidth = sizeMultiplier * generalSplashImage.width;
            const expectedHeight = sizeMultiplier * generalSplashImage.height;
            androidSplashImages.push({
                dpi,
                width,
                height,
                expectedWidth,
                expectedHeight,
                sizeMatches: width === expectedWidth && height === expectedHeight,
            });
        }
    }
    if (androidSplashImages.length === 0) {
        internal_1.Logger.global
            .warn(`Splash resizeMode is set to 'native', but you haven't provided any images for different DPIs.
Be aware that your splash image will be used as xxxhdpi asset and its ${chalk_1.default.bold('actual size will be different')} depending on device's DPI.
See https://docs.expo.io/guides/splash-screens/#splash-screen-api-limitations-on-android for more information`);
        return;
    }
    if (androidSplashImages.some(({ sizeMatches }) => !sizeMatches)) {
        internal_1.Logger.global
            .warn(`Splash resizeMode is set to 'native' and you've provided different images for different DPIs,
but their sizes mismatch expected ones: [dpi: provided (expected)] ${androidSplashImages
            .map(({ dpi, width, height, expectedWidth, expectedHeight }) => `${dpi}: ${width}x${height} (${expectedWidth}x${expectedHeight})`)
            .join(', ')}
See https://docs.expo.io/guides/splash-screens/#splash-screen-api-limitations-on-android for more information`);
    }
}
exports.checkSplashScreenImages = checkSplashScreenImages;
async function maybeStopAdbDaemonAsync() {
    if (_isAdbOwner !== true) {
        return false;
    }
    try {
        await getAdbOutputAsync(['kill-server']);
        return true;
    }
    catch (_a) {
        return false;
    }
}
exports.maybeStopAdbDaemonAsync = maybeStopAdbDaemonAsync;
function nameStyleForDevice(device) {
    const isActive = device.isBooted;
    if (!isActive) {
        // Use no style changes for a disconnected device that is available to be opened.
        return (text) => text;
    }
    // A device that is connected and ready to be used should be bolded to match iOS.
    if (device.isAuthorized) {
        return chalk_1.default.bold;
    }
    // Devices that are unauthorized and connected cannot be used, but they are connected so gray them out.
    return (text) => chalk_1.default.bold(chalk_1.default.gray(text));
}
async function promptForDeviceAsync(devices) {
    // TODO: provide an option to add or download more simulators
    // Pause interactions on the TerminalUI
    internal_1.Prompts.pauseInteractions();
    const { value } = await prompts_1.default({
        type: 'autocomplete',
        name: 'value',
        limit: 11,
        message: 'Select a device/emulator',
        choices: devices.map(item => {
            const format = nameStyleForDevice(item);
            const type = item.isAuthorized ? item.type : 'unauthorized';
            return {
                title: `${format(item.name)} ${chalk_1.default.dim(`(${type})`)}`,
                value: item.name,
            };
        }),
        suggest: (input, choices) => {
            const regex = new RegExp(input, 'i');
            return choices.filter((choice) => regex.test(choice.title));
        },
    });
    // Resume interactions on the TerminalUI
    internal_1.Prompts.resumeInteractions();
    const device = value ? devices.find(({ name }) => name === value) : null;
    if ((device === null || device === void 0 ? void 0 : device.isAuthorized) === false) {
        logUnauthorized(device);
        return null;
    }
    return device;
}
exports.promptForDeviceAsync = promptForDeviceAsync;
var DeviceABI;
(function (DeviceABI) {
    // The arch specific android target platforms are soft-deprecated.
    // Instead of using TargetPlatform as a combination arch + platform
    // the code will be updated to carry arch information in [DarwinArch]
    // and [AndroidArch].
    DeviceABI["arm"] = "arm";
    DeviceABI["arm64"] = "arm64";
    DeviceABI["x64"] = "x64";
    DeviceABI["x86"] = "x86";
    DeviceABI["armeabiV7a"] = "armeabi-v7a";
    DeviceABI["armeabi"] = "armeabi";
    DeviceABI["universal"] = "universal";
})(DeviceABI = exports.DeviceABI || (exports.DeviceABI = {}));
const deviceProperties = {};
const PROP_SDK_VERSION = 'ro.build.version.release';
// Can sometimes be null
const PROP_API_VERSION = 'ro.build.version.sdk';
// http://developer.android.com/ndk/guides/abis.html
const PROP_CPU_NAME = 'ro.product.cpu.abi';
const PROP_CPU_ABILIST_NAME = 'ro.product.cpu.abilist';
const PROP_BOOT_ANIMATION_STATE = 'init.svc.bootanim';
const LOWEST_SUPPORTED_EXPO_API_VERSION = 21;
/**
 * @returns string like '11' (i.e. Android 11)
 */
async function getDeviceSDKVersionAsync(device) {
    return await getPropertyForDeviceAsync(device, PROP_SDK_VERSION);
}
exports.getDeviceSDKVersionAsync = getDeviceSDKVersionAsync;
/**
 * @returns number like `30` (i.e. API 30)
 */
async function getDeviceAPIVersionAsync(device) {
    var _a;
    const sdkVersion = (_a = (await getPropertyForDeviceAsync(device, PROP_API_VERSION))) !== null && _a !== void 0 ? _a : LOWEST_SUPPORTED_EXPO_API_VERSION;
    return parseInt(sdkVersion, 10);
}
exports.getDeviceAPIVersionAsync = getDeviceAPIVersionAsync;
/**
 *
 * @returns app/android/app/build/outputs/apk
 */
function getAPKDirectory(projectRoot) {
    return path_1.default.join(projectRoot, 'android', 'app', 'build', 'outputs', 'apk');
}
exports.getAPKDirectory = getAPKDirectory;
async function getDeviceABIsAsync(device) {
    const cpuAbilist = await getPropertyForDeviceAsync(device, PROP_CPU_ABILIST_NAME);
    if (cpuAbilist) {
        return cpuAbilist.trim().split(',');
    }
    const abi = (await getPropertyForDeviceAsync(device, PROP_CPU_NAME));
    return [abi];
}
exports.getDeviceABIsAsync = getDeviceABIsAsync;
async function getPropertyForDeviceAsync(device, name, shouldRefresh) {
    if (shouldRefresh) {
        delete deviceProperties[device.name];
    }
    if (deviceProperties[device.name] == null) {
        try {
            deviceProperties[device.name] = await getPropertyDataForDeviceAsync(device);
        }
        catch (error) {
            // TODO: Ensure error has message and not stderr
            internal_1.Logger.global.error(`Failed to get properties for device "${device.name}" (${device.pid}): ${error.message}`);
        }
    }
    return deviceProperties[device.name][name];
}
exports.getPropertyForDeviceAsync = getPropertyForDeviceAsync;
async function getPropertyDataForDeviceAsync(device, prop) {
    // @ts-ignore
    const propCommand = adbPidArgs(...[device.pid, 'shell', 'getprop', prop].filter(Boolean));
    try {
        // Prevent reading as UTF8.
        const results = (await getAdbFileOutputAsync(propCommand, 'latin1')).toString('latin1');
        // Like:
        // [wifi.direct.interface]: [p2p-dev-wlan0]
        // [wifi.interface]: [wlan0]
        if (prop) {
            return {
                [prop]: results,
            };
        }
        return parseAdbDeviceProperties(results);
    }
    catch (error) {
        // TODO: Ensure error has message and not stderr
        throw new Error(`Failed to get properties for device (${device.pid}): ${error.message}`);
    }
}
function parseAdbDeviceProperties(devicePropertiesString) {
    const properties = {};
    const propertyExp = /\[(.*?)\]: \[(.*?)\]/gm;
    for (const match of devicePropertiesString.matchAll(propertyExp)) {
        properties[match[1]] = match[2];
    }
    return properties;
}
exports.parseAdbDeviceProperties = parseAdbDeviceProperties;
//# sourceMappingURL=Android.js.map
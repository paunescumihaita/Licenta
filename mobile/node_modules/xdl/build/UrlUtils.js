"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("@expo/config");
const joi_1 = __importDefault(require("@hapi/joi"));
const assert_1 = __importDefault(require("assert"));
const os_1 = __importDefault(require("os"));
const querystring_1 = __importDefault(require("querystring"));
const resolve_from_1 = __importDefault(require("resolve-from"));
const url_1 = __importDefault(require("url"));
const internal_1 = require("./internal");
async function constructBundleUrlAsync(projectRoot, opts, requestHostname) {
    return await constructUrlAsync(projectRoot, opts, true, requestHostname);
}
exports.constructBundleUrlAsync = constructBundleUrlAsync;
async function constructDeepLinkAsync(projectRoot, opts, requestHostname) {
    const { devClient } = await internal_1.ProjectSettings.getPackagerOptsAsync(projectRoot);
    if (devClient) {
        return constructDevClientUrlAsync(projectRoot, opts, requestHostname);
    }
    else {
        return constructManifestUrlAsync(projectRoot, opts, requestHostname);
    }
}
exports.constructDeepLinkAsync = constructDeepLinkAsync;
async function constructManifestUrlAsync(projectRoot, opts, requestHostname) {
    return await constructUrlAsync(projectRoot, opts !== null && opts !== void 0 ? opts : null, false, requestHostname);
}
exports.constructManifestUrlAsync = constructManifestUrlAsync;
async function constructDevClientUrlAsync(projectRoot, opts, requestHostname) {
    const { scheme } = await internal_1.ProjectSettings.getPackagerOptsAsync(projectRoot);
    if (!scheme || typeof scheme !== 'string') {
        throw new internal_1.XDLError('NO_DEV_CLIENT_SCHEME', 'No scheme specified for development client');
    }
    const protocol = resolveProtocol(projectRoot, { scheme, urlType: 'custom' });
    const manifestUrl = await constructManifestUrlAsync(projectRoot, Object.assign(Object.assign({}, opts), { urlType: 'http' }), requestHostname);
    return `${protocol}://expo-development-client/?url=${encodeURIComponent(manifestUrl)}`;
}
exports.constructDevClientUrlAsync = constructDevClientUrlAsync;
// gets the base manifest URL and removes the scheme
async function constructHostUriAsync(projectRoot, requestHostname) {
    const urlString = await constructUrlAsync(projectRoot, null, false, requestHostname);
    // we need to use node's legacy urlObject api since the newer one doesn't like empty protocols
    const urlObj = url_1.default.parse(urlString);
    urlObj.protocol = '';
    urlObj.slashes = false;
    return url_1.default.format(urlObj);
}
exports.constructHostUriAsync = constructHostUriAsync;
async function constructLogUrlAsync(projectRoot, requestHostname) {
    const baseUrl = await constructUrlAsync(projectRoot, { urlType: 'http' }, false, requestHostname);
    return `${baseUrl}/logs`;
}
exports.constructLogUrlAsync = constructLogUrlAsync;
async function constructUrlWithExtensionAsync(projectRoot, entryPoint, ext, requestHostname, metroQueryOptions) {
    const defaultOpts = {
        dev: false,
        minify: true,
    };
    metroQueryOptions = metroQueryOptions || defaultOpts;
    let bundleUrl = await constructBundleUrlAsync(projectRoot, {
        hostType: 'localhost',
        urlType: 'http',
    }, requestHostname);
    const mainModulePath = stripJSExtension(entryPoint);
    bundleUrl += `/${mainModulePath}.${ext}`;
    const queryParams = constructBundleQueryParams(projectRoot, metroQueryOptions);
    return `${bundleUrl}?${queryParams}`;
}
exports.constructUrlWithExtensionAsync = constructUrlWithExtensionAsync;
async function constructPublishUrlAsync(projectRoot, entryPoint, requestHostname, metroQueryOptions) {
    return await constructUrlWithExtensionAsync(projectRoot, entryPoint, 'bundle', requestHostname, metroQueryOptions);
}
exports.constructPublishUrlAsync = constructPublishUrlAsync;
async function constructSourceMapUrlAsync(projectRoot, entryPoint, requestHostname) {
    return await constructUrlWithExtensionAsync(projectRoot, entryPoint, 'map', requestHostname);
}
exports.constructSourceMapUrlAsync = constructSourceMapUrlAsync;
async function constructAssetsUrlAsync(projectRoot, entryPoint, requestHostname) {
    return await constructUrlWithExtensionAsync(projectRoot, entryPoint, 'assets', requestHostname);
}
exports.constructAssetsUrlAsync = constructAssetsUrlAsync;
async function constructDebuggerHostAsync(projectRoot, requestHostname) {
    return await constructUrlAsync(projectRoot, {
        urlType: 'no-protocol',
    }, true, requestHostname);
}
exports.constructDebuggerHostAsync = constructDebuggerHostAsync;
function constructBundleQueryParams(projectRoot, opts) {
    const { exp } = config_1.getConfig(projectRoot);
    return constructBundleQueryParamsWithConfig(projectRoot, opts, exp);
}
exports.constructBundleQueryParams = constructBundleQueryParams;
function constructBundleQueryParamsWithConfig(projectRoot, opts, exp) {
    const queryParams = {
        dev: !!opts.dev,
        hot: false,
    };
    if ('strict' in opts) {
        queryParams.strict = !!opts.strict;
    }
    if ('minify' in opts) {
        // TODO: Maybe default this to true if dev is false
        queryParams.minify = !!opts.minify;
    }
    // No special requirements after SDK 33 (Jun 5 2019)
    if (internal_1.Versions.gteSdkVersion(exp, '33.0.0')) {
        return querystring_1.default.stringify(queryParams);
    }
    // TODO: Remove this ...
    // SDK11 to SDK32 require us to inject hashAssetFiles through the params, but this is not
    // needed with SDK33+
    const supportsAssetPlugins = internal_1.Versions.gteSdkVersion(exp, '11.0.0');
    const usesAssetPluginsQueryParam = supportsAssetPlugins && internal_1.Versions.lteSdkVersion(exp, '32.0.0');
    if (usesAssetPluginsQueryParam) {
        // Use an absolute path here so that we can not worry about symlinks/relative requires
        const pluginModule = resolve_from_1.default(projectRoot, 'expo/tools/hashAssetFiles');
        queryParams.assetPlugin = encodeURIComponent(pluginModule);
    }
    else if (!supportsAssetPlugins) {
        // Only sdk-10.1.0+ supports the assetPlugin parameter. We use only the
        // major version in the sdkVersion field, so check for 11.0.0 to be sure.
        queryParams.includeAssetFileHashes = true;
    }
    return querystring_1.default.stringify(queryParams);
}
exports.constructBundleQueryParamsWithConfig = constructBundleQueryParamsWithConfig;
async function constructWebAppUrlAsync(projectRoot, options = {}) {
    var _a;
    const packagerInfo = await internal_1.ProjectSettings.readPackagerInfoAsync(projectRoot);
    if (!packagerInfo.webpackServerPort) {
        return null;
    }
    const { https, hostType } = await internal_1.ProjectSettings.readAsync(projectRoot);
    const host = ((_a = options.hostType) !== null && _a !== void 0 ? _a : hostType) === 'localhost' ? 'localhost' : internal_1.ip.address();
    let urlType = 'http';
    if (https === true) {
        urlType = 'https';
    }
    return `${urlType}://${host}:${packagerInfo.webpackServerPort}`;
}
exports.constructWebAppUrlAsync = constructWebAppUrlAsync;
function assertValidOptions(opts) {
    const schema = joi_1.default.object().keys({
        devClient: joi_1.default.boolean().optional(),
        scheme: joi_1.default.string().optional().allow(null),
        // Replaced by `scheme`
        urlType: joi_1.default.any().valid('exp', 'http', 'redirect', 'no-protocol').allow(null),
        lanType: joi_1.default.any().valid('ip', 'hostname'),
        hostType: joi_1.default.any().valid('localhost', 'lan', 'tunnel'),
        dev: joi_1.default.boolean(),
        strict: joi_1.default.boolean(),
        minify: joi_1.default.boolean(),
        https: joi_1.default.boolean().optional(),
        urlRandomness: joi_1.default.string().optional().allow(null),
    });
    const { error } = schema.validate(opts);
    if (error) {
        throw new internal_1.XDLError('INVALID_OPTIONS', error.toString());
    }
    return opts;
}
async function ensureOptionsAsync(projectRoot, opts) {
    if (opts) {
        assertValidOptions(opts);
    }
    const defaultOpts = await internal_1.ProjectSettings.getPackagerOptsAsync(projectRoot);
    if (!opts) {
        return Object.assign({ urlType: null }, defaultOpts);
    }
    const optionsWithDefaults = Object.assign(Object.assign({}, defaultOpts), opts);
    return assertValidOptions(optionsWithDefaults);
}
function resolveProtocol(projectRoot, _a) {
    var { urlType } = _a, options = __rest(_a, ["urlType"]);
    if (urlType === 'http') {
        return 'http';
    }
    else if (urlType === 'no-protocol') {
        return null;
    }
    else if (urlType === 'custom') {
        return options.scheme;
    }
    let protocol = 'exp';
    const { exp } = config_1.getConfig(projectRoot);
    // We only use these values from the config
    const { scheme, detach, sdkVersion } = exp;
    if (detach) {
        // Normalize schemes and filter invalid schemes.
        const schemes = (Array.isArray(scheme) ? scheme : [scheme]).filter((scheme) => typeof scheme === 'string' && !!scheme);
        // Get the first valid scheme.
        const firstScheme = schemes[0];
        if (firstScheme && internal_1.Versions.gteSdkVersion({ sdkVersion }, '27.0.0')) {
            protocol = firstScheme;
        }
        else if (detach.scheme) {
            // must keep this fallback in place for older projects
            // and those detached with an older version of xdl
            protocol = detach.scheme;
        }
    }
    return protocol;
}
async function constructUrlAsync(projectRoot, incomingOpts, isPackager, requestHostname) {
    const opts = await ensureOptionsAsync(projectRoot, incomingOpts);
    const packagerInfo = await internal_1.ProjectSettings.readPackagerInfoAsync(projectRoot);
    let protocol = resolveProtocol(projectRoot, opts);
    let hostname;
    let port;
    const proxyURL = isPackager
        ? process.env.EXPO_PACKAGER_PROXY_URL
        : process.env.EXPO_MANIFEST_PROXY_URL;
    if (proxyURL) {
        const parsedProxyURL = url_1.default.parse(proxyURL);
        hostname = parsedProxyURL.hostname;
        port = parsedProxyURL.port;
        if (parsedProxyURL.protocol === 'https:') {
            if (protocol === 'http') {
                protocol = 'https';
            }
            if (!port) {
                port = '443';
            }
        }
    }
    else if (opts.hostType === 'localhost' || requestHostname === 'localhost') {
        hostname = '127.0.0.1';
        port = isPackager ? packagerInfo.packagerPort : packagerInfo.expoServerPort;
    }
    else if (opts.hostType === 'lan' || internal_1.Config.offline) {
        if (process.env.EXPO_PACKAGER_HOSTNAME) {
            hostname = process.env.EXPO_PACKAGER_HOSTNAME.trim();
        }
        else if (process.env.REACT_NATIVE_PACKAGER_HOSTNAME) {
            hostname = process.env.REACT_NATIVE_PACKAGER_HOSTNAME.trim();
        }
        else if (opts.lanType === 'ip') {
            if (requestHostname) {
                hostname = requestHostname;
            }
            else {
                hostname = internal_1.ip.address();
            }
        }
        else {
            // Some old versions of OSX work with hostname but not local ip address.
            hostname = os_1.default.hostname();
        }
        port = isPackager ? packagerInfo.packagerPort : packagerInfo.expoServerPort;
    }
    else {
        const ngrokUrl = isPackager ? packagerInfo.packagerNgrokUrl : packagerInfo.expoServerNgrokUrl;
        if (!ngrokUrl || typeof ngrokUrl !== 'string') {
            // TODO: if you start with --tunnel flag then this warning will always
            // show up right before the tunnel starts...
            internal_1.ProjectUtils.logWarning(projectRoot, 'expo', 'Tunnel URL not found (it might not be ready yet), falling back to LAN URL.', 'tunnel-url-not-found');
            return constructUrlAsync(projectRoot, Object.assign(Object.assign({}, opts), { hostType: 'lan' }), isPackager, requestHostname);
        }
        else {
            internal_1.ProjectUtils.clearNotification(projectRoot, 'tunnel-url-not-found');
            const pnu = url_1.default.parse(ngrokUrl);
            hostname = pnu.hostname;
            port = pnu.port;
        }
    }
    const url_ = joinURLComponents({ protocol, hostname, port });
    if (opts.urlType === 'redirect') {
        return createRedirectURL(url_);
    }
    return url_;
}
exports.constructUrlAsync = constructUrlAsync;
function createRedirectURL(url) {
    return `https://exp.host/--/to-exp/${encodeURIComponent(url)}`;
}
function joinURLComponents({ protocol, hostname, port, }) {
    assert_1.default(hostname, 'hostname cannot be inferred.');
    // Android HMR breaks without this port 80
    const validPort = port !== null && port !== void 0 ? port : '80';
    const validProtocol = protocol ? `${protocol}://` : '';
    return `${validProtocol}${hostname}:${validPort}`;
}
function stripJSExtension(entryPoint) {
    return entryPoint.replace(/\.js$/, '');
}
exports.stripJSExtension = stripJSExtension;
function randomIdentifier(length = 6) {
    const alphabet = '23456789qwertyuipasdfghjkzxcvbnm';
    let result = '';
    for (let i = 0; i < length; i++) {
        const j = Math.floor(Math.random() * alphabet.length);
        const c = alphabet.substr(j, 1);
        result += c;
    }
    return result;
}
exports.randomIdentifier = randomIdentifier;
function sevenDigitIdentifier() {
    return `${randomIdentifier(3)}-${randomIdentifier(4)}`;
}
exports.sevenDigitIdentifier = sevenDigitIdentifier;
function randomIdentifierForUser(username) {
    return `${username}-${randomIdentifier(3)}-${randomIdentifier(2)}`;
}
exports.randomIdentifierForUser = randomIdentifierForUser;
function someRandomness() {
    return [randomIdentifier(2), randomIdentifier(3)].join('-');
}
exports.someRandomness = someRandomness;
function domainify(s) {
    return s
        .toLowerCase()
        .replace(/[^a-z0-9-]/g, '-')
        .replace(/^-+/, '')
        .replace(/-+$/, '');
}
exports.domainify = domainify;
function isHttps(urlString) {
    return isURL(urlString, { protocols: ['https'] });
}
exports.isHttps = isHttps;
function isURL(urlString, { protocols, requireProtocol }) {
    try {
        // eslint-disable-next-line
        new url_1.default.URL(urlString);
        const parsed = url_1.default.parse(urlString);
        if (!parsed.protocol && !requireProtocol) {
            return true;
        }
        return protocols
            ? parsed.protocol
                ? protocols.map(x => `${x.toLowerCase()}:`).includes(parsed.protocol)
                : false
            : true;
    }
    catch (err) {
        return false;
    }
}
exports.isURL = isURL;
//# sourceMappingURL=UrlUtils.js.map
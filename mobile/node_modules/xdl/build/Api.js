"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const concat_stream_1 = __importDefault(require("concat-stream"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const internal_1 = require("./internal");
const TIMER_DURATION = 30000;
const TIMEOUT = 3600000;
let exponentClient = 'xdl';
class ApiError extends Error {
    constructor(code, message) {
        super(message);
        this.name = 'ApiError';
        this._isApiError = true;
        this.code = code;
    }
}
// These aren't constants because some commands switch between staging and prod
function _rootBaseUrl() {
    return `${internal_1.Config.api.scheme}://${internal_1.Config.api.host}`;
}
function _apiBaseUrl() {
    let rootBaseUrl = _rootBaseUrl();
    if (internal_1.Config.api.port) {
        rootBaseUrl += ':' + internal_1.Config.api.port;
    }
    return rootBaseUrl + '/--/api';
}
async function _callMethodAsync(url, method = 'get', requestBody, requestOptions, returnEntireResponse = false) {
    const clientId = await internal_1.Session.clientIdAsync();
    const session = await internal_1.UserManager.getSessionAsync();
    const skipValidationToken = process.env['EXPO_SKIP_MANIFEST_VALIDATION_TOKEN'];
    const headers = {
        'Exp-ClientId': clientId,
        'Exponent-Client': exponentClient,
    };
    if (skipValidationToken) {
        headers['Exp-Skip-Manifest-Validation-Token'] = skipValidationToken;
    }
    // Handle auth method, prioritizing authorization tokens before session secrets
    if (session === null || session === void 0 ? void 0 : session.accessToken) {
        headers['Authorization'] = `Bearer ${session.accessToken}`;
    }
    else if (session === null || session === void 0 ? void 0 : session.sessionSecret) {
        headers['Expo-Session'] = session.sessionSecret;
    }
    let options = {
        url,
        method,
        headers,
        maxContentLength: internal_1.API_V2_MAX_CONTENT_LENGTH,
        maxBodyLength: internal_1.API_V2_MAX_BODY_LENGTH,
    };
    if (requestBody) {
        options = Object.assign(Object.assign({}, options), { data: requestBody });
    }
    if (requestOptions.formData) {
        const { formData } = requestOptions, rest = __rest(requestOptions, ["formData"]);
        const convertedFormData = await _convertFormDataToBuffer(formData);
        const { data } = convertedFormData;
        options.headers = Object.assign(Object.assign({}, options.headers), formData.getHeaders());
        options = Object.assign(Object.assign(Object.assign({}, options), { data }), rest);
    }
    else {
        options = Object.assign(Object.assign({}, options), requestOptions);
    }
    if (!requestOptions.hasOwnProperty('timeout') && internal_1.ConnectionStatus.isOffline()) {
        options.timeout = 1;
    }
    const response = await axios_1.default.request(options);
    if (!response) {
        throw new Error('Unexpected error: Request failed.');
    }
    const responseBody = response.data;
    let responseObj;
    if (typeof responseBody === 'string') {
        try {
            responseObj = JSON.parse(responseBody);
        }
        catch (e) {
            throw new internal_1.XDLError('INVALID_JSON', 'Invalid JSON returned from API: ' + e + '. Response body: ' + responseBody);
        }
    }
    else {
        responseObj = responseBody;
    }
    if (responseObj.err) {
        const err = new ApiError(responseObj.code || 'API_ERROR', 'API Response Error: ' + responseObj.err);
        err.serverError = responseObj.err;
        throw err;
    }
    else {
        return returnEntireResponse ? response : responseObj;
    }
}
async function _convertFormDataToBuffer(formData) {
    return new Promise(resolve => {
        formData.pipe(concat_stream_1.default({ encoding: 'buffer' }, data => resolve({ data })));
    });
}
async function _downloadAsync(url, outputPath, progressFunction, retryFunction) {
    let promptShown = false;
    let currentProgress = 0;
    const { cancel, token } = axios_1.default.CancelToken.source();
    let warningTimer = setTimeout(() => {
        if (retryFunction) {
            retryFunction(cancel);
        }
        promptShown = true;
    }, TIMER_DURATION);
    const tmpPath = `${outputPath}.download`;
    const config = {
        timeout: TIMEOUT,
        responseType: 'stream',
        cancelToken: token,
    };
    const response = await axios_1.default(url, config);
    await new Promise(resolve => {
        const totalDownloadSize = response.data.headers['content-length'];
        let downloadProgress = 0;
        response.data
            .on('data', (chunk) => {
            downloadProgress += chunk.length;
            const roundedProgress = Math.floor((downloadProgress / totalDownloadSize) * 100);
            if (currentProgress !== roundedProgress) {
                currentProgress = roundedProgress;
                clearTimeout(warningTimer);
                if (!promptShown) {
                    warningTimer = setTimeout(() => {
                        if (retryFunction) {
                            retryFunction(cancel);
                        }
                        promptShown = true;
                    }, TIMER_DURATION);
                }
                if (progressFunction) {
                    progressFunction(roundedProgress);
                }
            }
        })
            .on('end', () => {
            clearTimeout(warningTimer);
            if (progressFunction && currentProgress !== 100) {
                progressFunction(100);
            }
            resolve();
        })
            .pipe(fs_extra_1.default.createWriteStream(tmpPath));
    });
    await fs_extra_1.default.rename(tmpPath, outputPath);
}
/** @deprecated use ApiV2, got or GraphQL depending on use case. */
class ApiClient {
    static setClientName(name) {
        exponentClient = name;
    }
    static async callMethodAsync(methodName, args, method, requestBody, requestOptions = {}, returnEntireResponse = false) {
        const url = _apiBaseUrl() +
            '/' +
            encodeURIComponent(methodName) +
            '/' +
            encodeURIComponent(JSON.stringify(args));
        return _callMethodAsync(url, method, requestBody, requestOptions, returnEntireResponse);
    }
    static async callPathAsync(path, method, requestBody, requestOptions = {}) {
        const url = _rootBaseUrl() + path;
        return _callMethodAsync(url, method, requestBody, requestOptions);
    }
    static async downloadAsync(url, outputPath, { extract = false } = {}, progressFunction, retryFunction) {
        if (extract) {
            const dotExpoHomeDirectory = internal_1.UserSettings.dotExpoHomeDirectory();
            const tmpPath = path_1.default.join(dotExpoHomeDirectory, 'tmp-download-file');
            await _downloadAsync(url, tmpPath, progressFunction);
            await internal_1.Extract.extractAsync(tmpPath, outputPath);
            fs_extra_1.default.removeSync(tmpPath);
        }
        else {
            await _downloadAsync(url, outputPath, progressFunction, retryFunction);
        }
    }
}
exports.default = ApiClient;
ApiClient.host = internal_1.Config.api.host;
ApiClient.port = internal_1.Config.api.port || 80;
//# sourceMappingURL=Api.js.map
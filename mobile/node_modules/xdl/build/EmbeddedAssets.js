"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("@expo/config");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const semver_1 = __importDefault(require("semver"));
const internal_1 = require("./internal");
async function configureAsync(config) {
    await _maybeWriteArtifactsToDiskAsync(config);
    await _maybeConfigureExpoKitEmbeddedAssetsAsync(config);
    await _maybeConfigureExpoUpdatesEmbeddedAssetsAsync(config);
}
exports.configureAsync = configureAsync;
function getEmbeddedManifestPath(platform, projectRoot, exp) {
    if (platform === 'ios') {
        return exp.ios && exp.ios.publishManifestPath
            ? exp.ios.publishManifestPath
            : _getDefaultEmbeddedManifestPath(platform, projectRoot, exp);
    }
    else if (platform === 'android') {
        return exp.android && exp.android.publishManifestPath
            ? exp.android.publishManifestPath
            : _getDefaultEmbeddedManifestPath(platform, projectRoot, exp);
    }
    return _getDefaultEmbeddedManifestPath(platform, projectRoot, exp);
}
exports.getEmbeddedManifestPath = getEmbeddedManifestPath;
function _getDefaultEmbeddedManifestPath(platform, projectRoot, exp) {
    return path_1.default.join(_getDefaultEmbeddedAssetDir(platform, projectRoot, exp), 'app.manifest');
}
function _getDefaultEmbeddedBundlePath(platform, projectRoot, exp) {
    return path_1.default.join(_getDefaultEmbeddedAssetDir(platform, projectRoot, exp), 'app.bundle');
}
function _getDefaultEmbeddedAssetDir(platform, projectRoot, exp) {
    if (platform === 'ios') {
        const { iosSupportingDirectory } = getIOSPaths(projectRoot);
        return iosSupportingDirectory;
    }
    else if (platform === 'android') {
        return path_1.default.join(projectRoot, 'android', 'app', 'src', 'main', 'assets');
    }
    else {
        throw new Error('Embedding assets is not supported for platform ' + platform);
    }
}
function shouldEmbedAssetsForExpoUpdates(projectRoot, exp, pkg, target) {
    var _a;
    if (!((_a = pkg.dependencies) === null || _a === void 0 ? void 0 : _a['expo-updates']) || target !== 'bare') {
        return false;
    }
    // semver.coerce can return null
    const expoUpdatesVersion = semver_1.default.coerce(pkg.dependencies['expo-updates']);
    // expo-updates 0.1.x relies on expo-cli automatically embedding the manifest and bundle
    if (expoUpdatesVersion && semver_1.default.satisfies(expoUpdatesVersion, '~0.1.0')) {
        return true;
    }
    // We also want to support developers who had expo-updates 0.1.x and upgraded but still rely on
    // expo-cli's automatic embedding. If the files already exist we can assume we need to update them
    if (fs_extra_1.default.existsSync(_getDefaultEmbeddedBundlePath('android', projectRoot, exp)) ||
        fs_extra_1.default.existsSync(_getDefaultEmbeddedManifestPath('android', projectRoot, exp)) ||
        fs_extra_1.default.existsSync(_getDefaultEmbeddedBundlePath('ios', projectRoot, exp)) ||
        fs_extra_1.default.existsSync(_getDefaultEmbeddedManifestPath('ios', projectRoot, exp))) {
        return true;
    }
    return false;
}
exports.shouldEmbedAssetsForExpoUpdates = shouldEmbedAssetsForExpoUpdates;
async function _maybeWriteArtifactsToDiskAsync(config) {
    var _a, _b, _c, _d, _e, _f;
    const { projectRoot, pkg, exp, iosManifest, iosBundle, iosSourceMap, androidManifest, androidBundle, androidSourceMap, target, } = config;
    let androidBundlePath;
    let androidManifestPath;
    let androidSourceMapPath;
    let iosBundlePath;
    let iosManifestPath;
    let iosSourceMapPath;
    if (shouldEmbedAssetsForExpoUpdates(projectRoot, exp, pkg, target)) {
        const defaultAndroidDir = _getDefaultEmbeddedAssetDir('android', projectRoot, exp);
        const defaultIosDir = _getDefaultEmbeddedAssetDir('ios', projectRoot, exp);
        await fs_extra_1.default.ensureDir(defaultIosDir);
        await fs_extra_1.default.ensureDir(defaultAndroidDir);
        androidBundlePath = _getDefaultEmbeddedBundlePath('android', projectRoot, exp);
        androidManifestPath = _getDefaultEmbeddedManifestPath('android', projectRoot, exp);
        iosBundlePath = _getDefaultEmbeddedBundlePath('ios', projectRoot, exp);
        iosManifestPath = _getDefaultEmbeddedManifestPath('ios', projectRoot, exp);
        if (!fs_extra_1.default.existsSync(iosBundlePath) || !fs_extra_1.default.existsSync(iosManifestPath)) {
            internal_1.Logger.global.warn('Creating app.manifest and app.bundle inside of your ios/<project>/Supporting directory.\nBe sure to add these files to your Xcode project. More info at https://expo.fyi/embedded-assets');
        }
    }
    // allow custom overrides
    if ((_a = exp.android) === null || _a === void 0 ? void 0 : _a.publishBundlePath) {
        androidBundlePath = exp.android.publishBundlePath;
    }
    if ((_b = exp.android) === null || _b === void 0 ? void 0 : _b.publishManifestPath) {
        androidManifestPath = exp.android.publishManifestPath;
    }
    if ((_c = exp.android) === null || _c === void 0 ? void 0 : _c.publishSourceMapPath) {
        androidSourceMapPath = exp.android.publishSourceMapPath;
    }
    if ((_d = exp.ios) === null || _d === void 0 ? void 0 : _d.publishBundlePath) {
        iosBundlePath = exp.ios.publishBundlePath;
    }
    if ((_e = exp.ios) === null || _e === void 0 ? void 0 : _e.publishManifestPath) {
        iosManifestPath = exp.ios.publishManifestPath;
    }
    if ((_f = exp.ios) === null || _f === void 0 ? void 0 : _f.publishSourceMapPath) {
        iosSourceMapPath = exp.ios.publishSourceMapPath;
    }
    if (androidBundlePath) {
        await internal_1.writeArtifactSafelyAsync(projectRoot, 'android.publishBundlePath', androidBundlePath, androidBundle);
    }
    if (androidManifestPath) {
        await internal_1.writeArtifactSafelyAsync(projectRoot, 'android.publishManifestPath', androidManifestPath, JSON.stringify(androidManifest));
    }
    if (androidSourceMapPath && androidSourceMap) {
        await internal_1.writeArtifactSafelyAsync(projectRoot, 'android.publishSourceMapPath', androidSourceMapPath, androidSourceMap);
    }
    if (iosBundlePath) {
        await internal_1.writeArtifactSafelyAsync(projectRoot, 'ios.publishBundlePath', iosBundlePath, iosBundle);
    }
    if (iosManifestPath) {
        await internal_1.writeArtifactSafelyAsync(projectRoot, 'ios.publishManifestPath', iosManifestPath, JSON.stringify(iosManifest));
    }
    if (iosSourceMapPath && iosSourceMap) {
        await internal_1.writeArtifactSafelyAsync(projectRoot, 'ios.publishSourceMapPath', iosSourceMapPath, iosSourceMap);
    }
}
async function _maybeConfigureExpoKitEmbeddedAssetsAsync(config) {
    const { projectRoot, exp, releaseChannel, androidManifestUrl, androidManifest } = config;
    const context = internal_1.StandaloneContext.createUserContext(projectRoot, exp);
    const { supportingDirectory } = internal_1.IosWorkspace.getPaths(context);
    // iOS ExpoKit
    if (releaseChannel && fs_extra_1.default.existsSync(path_1.default.join(supportingDirectory, 'EXShell.plist'))) {
        // This is an ExpoKit app, set properties in EXShell.plist
        await internal_1.IosPlist.modifyAsync(supportingDirectory, 'EXShell', (shellPlist) => {
            shellPlist.releaseChannel = releaseChannel;
            return shellPlist;
        });
    }
    // Android ExpoKit
    const constantsPath = path_1.default.join(projectRoot, 'android', 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java');
    if (fs_extra_1.default.existsSync(constantsPath)) {
        // This is an ExpoKit app
        // We need to add EmbeddedResponse instances on Android to tell the runtime
        // that the shell app manifest and bundle is packaged.
        await internal_1.ExponentTools.deleteLinesInFileAsync(`START EMBEDDED RESPONSES`, `END EMBEDDED RESPONSES`, constantsPath);
        await internal_1.ExponentTools.regexFileAsync('// ADD EMBEDDED RESPONSES HERE', `
      // ADD EMBEDDED RESPONSES HERE
      // START EMBEDDED RESPONSES
      embeddedResponses.add(new Constants.EmbeddedResponse("${androidManifestUrl}", "assets://shell-app-manifest.json", "application/json"));
      embeddedResponses.add(new Constants.EmbeddedResponse("${androidManifest.bundleUrl}", "assets://shell-app.bundle", "application/javascript"));
      // END EMBEDDED RESPONSES`, constantsPath);
        if (releaseChannel) {
            await internal_1.ExponentTools.regexFileAsync(/RELEASE_CHANNEL = "[^"]*"/, `RELEASE_CHANNEL = "${releaseChannel}"`, constantsPath);
        }
    }
}
async function _maybeConfigureExpoUpdatesEmbeddedAssetsAsync(config) {
    var _a;
    if (!((_a = config.pkg.dependencies) === null || _a === void 0 ? void 0 : _a['expo-updates']) || config.target === 'managed') {
        return;
    }
    let isLikelyFirstPublish = false;
    const { projectRoot, exp, releaseChannel, iosManifestUrl, androidManifestUrl } = config;
    const { iosSupportingDirectory: supportingDirectory } = getIOSPaths(projectRoot);
    // iOS expo-updates
    if (fs_extra_1.default.existsSync(path_1.default.join(supportingDirectory, 'Expo.plist'))) {
        // This is an app with expo-updates installed, set properties in Expo.plist
        await internal_1.IosPlist.modifyAsync(supportingDirectory, 'Expo', (configPlist) => {
            if (configPlist.EXUpdatesURL === 'YOUR-APP-URL-HERE') {
                isLikelyFirstPublish = true;
            }
            configPlist.EXUpdatesURL = iosManifestUrl;
            configPlist.EXUpdatesSDKVersion = exp.sdkVersion;
            if (releaseChannel) {
                configPlist.EXUpdatesReleaseChannel = releaseChannel;
            }
            return configPlist;
        });
        await internal_1.IosPlist.cleanBackupAsync(supportingDirectory, 'Expo', false);
    }
    // Android expo-updates
    const androidManifestXmlPath = path_1.default.join(projectRoot, 'android', 'app', 'src', 'main', 'AndroidManifest.xml');
    const androidManifestXmlFile = fs_extra_1.default.readFileSync(androidManifestXmlPath, 'utf8');
    const expoUpdateUrlRegex = /<meta-data[^>]+"expo.modules.updates.EXPO_UPDATE_URL"[^>]+\/>/;
    const expoSdkVersionRegex = /<meta-data[^>]+"expo.modules.updates.EXPO_SDK_VERSION"[^>]+\/>/;
    const expoReleaseChannelRegex = /<meta-data[^>]+"expo.modules.updates.EXPO_RELEASE_CHANNEL"[^>]+\/>/;
    const expoUpdateUrlTag = `<meta-data android:name="expo.modules.updates.EXPO_UPDATE_URL" android:value="${androidManifestUrl}" />`;
    const expoSdkVersionTag = `<meta-data android:name="expo.modules.updates.EXPO_SDK_VERSION" android:value="${exp.sdkVersion}" />`;
    const expoReleaseChannelTag = `<meta-data android:name="expo.modules.updates.EXPO_RELEASE_CHANNEL" android:value="${releaseChannel}" />`;
    const tagsToInsert = [];
    if (androidManifestXmlFile.search(expoUpdateUrlRegex) < 0) {
        tagsToInsert.push(expoUpdateUrlTag);
    }
    if (androidManifestXmlFile.search(expoSdkVersionRegex) < 0) {
        tagsToInsert.push(expoSdkVersionTag);
    }
    if (releaseChannel && androidManifestXmlFile.search(expoReleaseChannelRegex) < 0) {
        tagsToInsert.push(expoReleaseChannelTag);
    }
    if (tagsToInsert.length) {
        // try to insert the meta-data tags that aren't found
        await internal_1.ExponentTools.regexFileAsync(/<activity\s+android:name=".MainActivity"/, `${tagsToInsert.join('\n      ')}

  <activity
    android:name=".MainActivity"`, androidManifestXmlPath);
    }
    await internal_1.ExponentTools.regexFileAsync(expoUpdateUrlRegex, expoUpdateUrlTag, androidManifestXmlPath);
    await internal_1.ExponentTools.regexFileAsync(expoSdkVersionRegex, expoSdkVersionTag, androidManifestXmlPath);
    if (releaseChannel) {
        await internal_1.ExponentTools.regexFileAsync(expoReleaseChannelRegex, expoReleaseChannelTag, androidManifestXmlPath);
    }
    if (isLikelyFirstPublish) {
        internal_1.Logger.global.warn('🚀 It looks like this your first publish for this project! ' +
            "We've automatically set some configuration values in Expo.plist and AndroidManifest.xml. " +
            "You'll need to make a new build with these changes before you can download the update " +
            'you just published.');
    }
}
/** The code below here is duplicated from expo-cli currently **/
// TODO: come up with a better solution for using app.json expo.name in various places
function sanitizedName(name) {
    return name
        .replace(/[\W_]+/g, '')
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '');
}
// TODO: it's silly and kind of fragile that we look at app config to determine
// the ios project paths. Overall this function needs to be revamped, just a
// placeholder for now! Make this more robust when we support applying config
// at any time (currently it's only applied on eject).
function getIOSPaths(projectRoot) {
    const { exp } = config_1.getConfig(projectRoot, { skipSDKVersionRequirement: true });
    const projectName = exp.name;
    if (!projectName) {
        throw new Error('Your project needs a name in app.json/app.config.js.');
    }
    const iosProjectDirectory = path_1.default.join(projectRoot, 'ios', sanitizedName(projectName));
    const iosSupportingDirectory = path_1.default.join(projectRoot, 'ios', sanitizedName(projectName), 'Supporting');
    const iconPath = path_1.default.join(iosProjectDirectory, 'Assets.xcassets', 'AppIcon.appiconset');
    return {
        projectName,
        iosProjectDirectory,
        iosSupportingDirectory,
        iconPath,
    };
}
exports.getIOSPaths = getIOSPaths;
//# sourceMappingURL=EmbeddedAssets.js.map
"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("@expo/config");
const devcert = __importStar(require("@expo/devcert"));
const package_manager_1 = require("@expo/package-manager");
const chalk_1 = __importDefault(require("chalk"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const getenv_1 = __importDefault(require("getenv"));
const path = __importStar(require("path"));
const WebpackDevServerUtils_1 = require("react-dev-utils/WebpackDevServerUtils");
const formatWebpackMessages_1 = __importDefault(require("react-dev-utils/formatWebpackMessages"));
const openBrowser_1 = __importDefault(require("react-dev-utils/openBrowser"));
const webpack_1 = __importDefault(require("webpack"));
const webpack_dev_server_1 = __importDefault(require("webpack-dev-server"));
const internal_1 = require("./internal");
const WEBPACK_LOG_TAG = 'expo';
let webpackDevServerInstance = null;
let webpackServerPort = null;
async function restartAsync(projectRoot, options = {}) {
    await stopAsync(projectRoot);
    return await startAsync(projectRoot, options);
}
exports.restartAsync = restartAsync;
let devServerInfo = null;
function printConnectionInstructions(projectRoot, options = {}) {
    if (!devServerInfo)
        return;
    internal_1.WebpackCompiler.printInstructions(projectRoot, Object.assign({ appName: devServerInfo.appName, urls: devServerInfo.urls, showInDevtools: false }, options));
}
exports.printConnectionInstructions = printConnectionInstructions;
async function clearWebCacheAsync(projectRoot, mode) {
    const cacheFolder = path.join(projectRoot, '.expo', 'web', 'cache', mode);
    internal_1.ProjectUtils.logInfo(projectRoot, WEBPACK_LOG_TAG, chalk_1.default.dim(`Clearing ${mode} cache directory...`));
    try {
        await fs_extra_1.default.remove(cacheFolder);
    }
    catch (_a) { }
}
async function broadcastMessage(message, data) {
    if (webpackDevServerInstance && webpackDevServerInstance instanceof webpack_dev_server_1.default) {
        webpackDevServerInstance.sockWrite(webpackDevServerInstance.sockets, message, data);
    }
}
exports.broadcastMessage = broadcastMessage;
async function startAsync(projectRoot, options = {}, deprecatedVerbose) {
    if (typeof deprecatedVerbose !== 'undefined') {
        throw new internal_1.XDLError('WEBPACK_DEPRECATED', 'startAsync(root, options, verbose): The `verbose` option is deprecated.');
    }
    const serverName = 'Webpack';
    if (webpackDevServerInstance) {
        internal_1.ProjectUtils.logError(projectRoot, WEBPACK_LOG_TAG, chalk_1.default.red(`${serverName} is already running.`));
        return null;
    }
    const fullOptions = transformCLIOptions(options);
    const env = await getWebpackConfigEnvFromBundlingOptionsAsync(projectRoot, fullOptions);
    if (fullOptions.clear) {
        await clearWebCacheAsync(projectRoot, env.mode);
    }
    if (env.https) {
        if (!process.env.SSL_CRT_FILE || !process.env.SSL_KEY_FILE) {
            const ssl = await getSSLCertAsync({
                name: 'localhost',
                directory: projectRoot,
            });
            if (ssl) {
                process.env.SSL_CRT_FILE = ssl.certPath;
                process.env.SSL_KEY_FILE = ssl.keyPath;
            }
        }
    }
    const config = await createWebpackConfigAsync(env, fullOptions);
    const port = await getAvailablePortAsync({
        projectRoot,
        defaultPort: options.port,
    });
    webpackServerPort = port;
    internal_1.ProjectUtils.logInfo(projectRoot, WEBPACK_LOG_TAG, `Starting ${serverName} on port ${webpackServerPort} in ${chalk_1.default.underline(env.mode)} mode.`);
    const protocol = env.https ? 'https' : 'http';
    const urls = WebpackDevServerUtils_1.prepareUrls(protocol, '::', webpackServerPort);
    const useYarn = package_manager_1.isUsingYarn(projectRoot);
    const appName = await getProjectNameAsync(projectRoot);
    const nonInteractive = validateBoolOption('nonInteractive', options.nonInteractive, !process.stdout.isTTY);
    devServerInfo = {
        urls,
        protocol,
        useYarn,
        appName,
        nonInteractive,
        port: webpackServerPort,
    };
    const server = await new Promise(resolve => {
        // Create a webpack compiler that is configured with custom messages.
        const compiler = internal_1.WebpackCompiler.createWebpackCompiler({
            projectRoot,
            appName,
            config,
            urls,
            nonInteractive,
            webpackFactory: webpack_1.default,
            onFinished: () => resolve(server),
        });
        const server = new webpack_dev_server_1.default(compiler, config.devServer);
        // Launch WebpackDevServer.
        server.listen(port, internal_1.WebpackEnvironment.HOST, error => {
            if (error) {
                internal_1.ProjectUtils.logError(projectRoot, WEBPACK_LOG_TAG, error.message);
            }
            if (typeof options.onWebpackFinished === 'function') {
                options.onWebpackFinished(error);
            }
        });
        webpackDevServerInstance = server;
    });
    await internal_1.ProjectSettings.setPackagerInfoAsync(projectRoot, {
        webpackServerPort,
    });
    const host = internal_1.ip.address();
    const url = `${protocol}://${host}:${port}`;
    return {
        url,
        server,
        port,
        protocol,
        host,
    };
}
exports.startAsync = startAsync;
async function stopAsync(projectRoot) {
    if (webpackDevServerInstance) {
        await new Promise(res => {
            if (webpackDevServerInstance) {
                internal_1.ProjectUtils.logInfo(projectRoot, WEBPACK_LOG_TAG, '\u203A Stopping Webpack server');
                webpackDevServerInstance.close(res);
            }
        });
        webpackDevServerInstance = null;
        devServerInfo = null;
        webpackServerPort = null;
        await internal_1.ProjectSettings.setPackagerInfoAsync(projectRoot, {
            webpackServerPort: null,
        });
    }
}
exports.stopAsync = stopAsync;
async function openAsync(projectRoot, options) {
    if (!webpackDevServerInstance) {
        await startAsync(projectRoot, options);
    }
    await openProjectAsync(projectRoot);
}
exports.openAsync = openAsync;
async function compileWebAppAsync(projectRoot, compiler) {
    // We generate the stats.json file in the webpack-config
    const { warnings } = await new Promise((resolve, reject) => compiler.run((error, stats) => {
        let messages;
        if (error) {
            if (!error.message) {
                return reject(error);
            }
            messages = formatWebpackMessages_1.default({
                errors: [error.message],
                warnings: [],
                _showErrors: true,
                _showWarnings: true,
            });
        }
        else {
            messages = formatWebpackMessages_1.default(stats.toJson({ all: false, warnings: true, errors: true }));
        }
        if (messages.errors.length) {
            // Only keep the first error. Others are often indicative
            // of the same problem, but confuse the reader with noise.
            if (messages.errors.length > 1) {
                messages.errors.length = 1;
            }
            return reject(new Error(messages.errors.join('\n\n')));
        }
        if (getenv_1.default.boolish('EXPO_WEB_BUILD_STRICT', false) &&
            getenv_1.default.boolish('CI', false) &&
            messages.warnings.length) {
            internal_1.ProjectUtils.logWarning(projectRoot, WEBPACK_LOG_TAG, chalk_1.default.yellow('\nTreating warnings as errors because `process.env.CI = true` and `process.env.EXPO_WEB_BUILD_STRICT = true`. \n' +
                'Most CI servers set it automatically.\n'));
            return reject(new Error(messages.warnings.join('\n\n')));
        }
        resolve({
            warnings: messages.warnings,
        });
    }));
    return { warnings };
}
exports.compileWebAppAsync = compileWebAppAsync;
async function bundleWebAppAsync(projectRoot, config) {
    const compiler = webpack_1.default(config);
    try {
        const { warnings } = await compileWebAppAsync(projectRoot, compiler);
        if (warnings.length) {
            internal_1.ProjectUtils.logWarning(projectRoot, WEBPACK_LOG_TAG, chalk_1.default.yellow('Compiled with warnings.\n'));
            internal_1.ProjectUtils.logWarning(projectRoot, WEBPACK_LOG_TAG, warnings.join('\n\n'));
        }
        else {
            internal_1.ProjectUtils.logInfo(projectRoot, WEBPACK_LOG_TAG, chalk_1.default.green('Compiled successfully.\n'));
        }
    }
    catch (error) {
        internal_1.ProjectUtils.logError(projectRoot, WEBPACK_LOG_TAG, chalk_1.default.red('Failed to compile.\n'));
        throw error;
    }
}
exports.bundleWebAppAsync = bundleWebAppAsync;
async function bundleAsync(projectRoot, options) {
    var _a;
    const fullOptions = transformCLIOptions(Object.assign({}, options));
    const env = await getWebpackConfigEnvFromBundlingOptionsAsync(projectRoot, Object.assign(Object.assign({}, fullOptions), { 
        // Force production
        mode: 'production' }));
    if (typeof env.offline === 'undefined') {
        try {
            const expoConfig = config_1.getConfig(projectRoot, { skipSDKVersionRequirement: true });
            // If offline isn't defined, check the version and keep offline enabled for SDK 38 and prior
            if (expoConfig.exp.sdkVersion)
                if (internal_1.Versions.lteSdkVersion(expoConfig.exp, '38.0.0')) {
                    env.offline = true;
                }
        }
        catch (_b) {
            // Ignore the error thrown by projects without an Expo config.
        }
    }
    if (fullOptions.clear) {
        await clearWebCacheAsync(projectRoot, env.mode);
    }
    const config = await createWebpackConfigAsync(env, fullOptions);
    await bundleWebAppAsync(projectRoot, config);
    const hasSWPlugin = (_a = config.plugins) === null || _a === void 0 ? void 0 : _a.find(item => {
        var _a;
        return ((_a = item === null || item === void 0 ? void 0 : item.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'GenerateSW';
    });
    if (!hasSWPlugin) {
        internal_1.ProjectUtils.logInfo(projectRoot, WEBPACK_LOG_TAG, chalk_1.default.green(`Offline (PWA) support is not enabled in this build. ${chalk_1.default.dim(internal_1.learnMore('https://expo.fyi/enabling-web-service-workers'))}\n`));
    }
}
exports.bundleAsync = bundleAsync;
async function getProjectNameAsync(projectRoot) {
    var _a;
    const { exp } = config_1.getConfig(projectRoot, {
        skipSDKVersionRequirement: true,
    });
    const webName = (_a = config_1.getNameFromConfig(exp).webName) !== null && _a !== void 0 ? _a : exp.name;
    return webName;
}
exports.getProjectNameAsync = getProjectNameAsync;
function isRunning() {
    return !!webpackDevServerInstance;
}
exports.isRunning = isRunning;
function getServer(projectRoot) {
    if (webpackDevServerInstance == null) {
        internal_1.ProjectUtils.logError(projectRoot, WEBPACK_LOG_TAG, 'Webpack is not running.');
    }
    return webpackDevServerInstance;
}
exports.getServer = getServer;
function getPort() {
    return webpackServerPort;
}
exports.getPort = getPort;
/**
 * Get the URL for the running instance of Webpack dev server.
 *
 * @param projectRoot
 */
async function getUrlAsync(projectRoot) {
    const devServer = getServer(projectRoot);
    if (!devServer) {
        return null;
    }
    const host = internal_1.ip.address();
    const protocol = await getProtocolAsync(projectRoot);
    return `${protocol}://${host}:${webpackServerPort}`;
}
exports.getUrlAsync = getUrlAsync;
async function getProtocolAsync(projectRoot) {
    // TODO: Bacon: Handle when not in expo
    const { https } = await internal_1.ProjectSettings.readAsync(projectRoot);
    return https === true ? 'https' : 'http';
}
async function getAvailablePortAsync(options) {
    try {
        const defaultPort = 'defaultPort' in options && options.defaultPort
            ? options.defaultPort
            : internal_1.WebpackEnvironment.DEFAULT_PORT;
        const port = await internal_1.choosePortAsync(options.projectRoot, defaultPort, 'host' in options && options.host ? options.host : internal_1.WebpackEnvironment.HOST);
        if (!port) {
            throw new Error(`Port ${defaultPort} not available.`);
        }
        return port;
    }
    catch (error) {
        throw new internal_1.XDLError('NO_PORT_FOUND', error.message);
    }
}
function setMode(mode) {
    process.env.BABEL_ENV = mode;
    process.env.NODE_ENV = mode;
}
function validateBoolOption(name, value, defaultValue) {
    if (typeof value === 'undefined') {
        value = defaultValue;
    }
    if (typeof value !== 'boolean') {
        throw new internal_1.XDLError('WEBPACK_INVALID_OPTION', `'${name}' option must be a boolean.`);
    }
    return value;
}
function transformCLIOptions(options) {
    // Transform the CLI flags into more explicit values
    return Object.assign(Object.assign({}, options), { isImageEditingEnabled: options.pwa });
}
async function createWebpackConfigAsync(env, options = {}) {
    setMode(env.mode);
    let config;
    if (options.unimodulesOnly) {
        const { withUnimodules } = require('@expo/webpack-config/addons');
        config = withUnimodules({}, env);
    }
    else {
        config = await invokeWebpackConfigAsync(env);
    }
    return config;
}
async function applyOptionsToProjectSettingsAsync(projectRoot, options) {
    const newSettings = {};
    // Change settings before reading them
    if (typeof options.https === 'boolean') {
        newSettings.https = options.https;
    }
    if (Object.keys(newSettings).length) {
        await internal_1.ProjectSettings.setAsync(projectRoot, newSettings);
    }
    return await internal_1.ProjectSettings.readAsync(projectRoot);
}
async function getWebpackConfigEnvFromBundlingOptionsAsync(projectRoot, options) {
    const { dev, https } = await applyOptionsToProjectSettingsAsync(projectRoot, options);
    const mode = typeof options.mode === 'string' ? options.mode : dev ? 'development' : 'production';
    const isImageEditingEnabled = validateBoolOption('isImageEditingEnabled', options.isImageEditingEnabled, true);
    return Object.assign({ projectRoot, pwa: isImageEditingEnabled, isImageEditingEnabled,
        mode,
        https }, (options.webpackEnv || {}));
}
async function getSSLCertAsync({ name, directory, }) {
    console.log(chalk_1.default.magenta `Ensuring auto SSL certificate is created (you might need to re-run with sudo)`);
    try {
        const result = await devcert.certificateFor(name);
        if (result) {
            const { key, cert } = result;
            const folder = path.join(directory, '.expo', 'web', 'development', 'ssl');
            await fs_extra_1.default.ensureDir(folder);
            const keyPath = path.join(folder, `key-${name}.pem`);
            await fs_extra_1.default.writeFile(keyPath, key);
            const certPath = path.join(folder, `cert-${name}.pem`);
            await fs_extra_1.default.writeFile(certPath, cert);
            return {
                keyPath,
                certPath,
            };
        }
        return result;
    }
    catch (error) {
        console.log(`Error creating SSL certificates: ${error}`);
    }
    return false;
}
function applyEnvironmentVariables(config) {
    // Use EXPO_DEBUG_WEB=true to enable debugging features for cases where the prod build
    // has errors that aren't caught in development mode.
    // Related: https://github.com/expo/expo-cli/issues/614
    if (internal_1.WebpackEnvironment.isDebugModeEnabled() && config.mode === 'production') {
        console.log(chalk_1.default.bgYellow.black('Bundling the project in debug mode.'));
        const output = config.output || {};
        const optimization = config.optimization || {};
        // Enable line to line mapped mode for all/specified modules.
        // Line to line mapped mode uses a simple SourceMap where each line of the generated source is mapped to the same line of the original source.
        // It’s a performance optimization. Only use it if your performance need to be better and you are sure that input lines match which generated lines.
        // true enables it for all modules (not recommended)
        output.devtoolLineToLine = true;
        // Add comments that describe the file import/exports.
        // This will make it easier to debug.
        output.pathinfo = true;
        // Instead of numeric ids, give modules readable names for better debugging.
        optimization.namedModules = true;
        // Instead of numeric ids, give chunks readable names for better debugging.
        optimization.namedChunks = true;
        // Readable ids for better debugging.
        // @ts-ignore Property 'moduleIds' does not exist.
        optimization.moduleIds = 'named';
        // if optimization.namedChunks is enabled optimization.chunkIds is set to 'named'.
        // This will manually enable it just to be safe.
        // @ts-ignore Property 'chunkIds' does not exist.
        optimization.chunkIds = 'named';
        if (optimization.splitChunks) {
            optimization.splitChunks.name = true;
        }
        Object.assign(config, { output, optimization });
    }
    return config;
}
async function invokeWebpackConfigAsync(env, argv) {
    // Check if the project has a webpack.config.js in the root.
    const projectWebpackConfig = path.resolve(env.projectRoot, 'webpack.config.js');
    let config;
    if (fs_extra_1.default.existsSync(projectWebpackConfig)) {
        const webpackConfig = require(projectWebpackConfig);
        if (typeof webpackConfig === 'function') {
            config = await webpackConfig(env, argv);
        }
        else {
            config = webpackConfig;
        }
    }
    else {
        // Fallback to the default expo webpack config.
        const createExpoWebpackConfigAsync = require('@expo/webpack-config');
        config = await createExpoWebpackConfigAsync(env, argv);
    }
    return applyEnvironmentVariables(config);
}
exports.invokeWebpackConfigAsync = invokeWebpackConfigAsync;
async function openProjectAsync(projectRoot) {
    try {
        const url = await internal_1.UrlUtils.constructWebAppUrlAsync(projectRoot, { hostType: 'localhost' });
        if (!url) {
            throw new Error('Webpack Dev Server is not running');
        }
        openBrowser_1.default(url);
        return { success: true, url };
    }
    catch (e) {
        internal_1.Logger.global.error(`Couldn't start project on web: ${e.message}`);
        return { success: false, error: e };
    }
}
exports.openProjectAsync = openProjectAsync;
//# sourceMappingURL=Webpack.js.map
{"version":3,"file":"Utils.js","sourceRoot":"","sources":["../src/Utils.ts"],"names":[],"mappings":";;AAAA,6BAA0B;AAE1B,SAAgB,QAAQ,CAAC,MAAc,EAAE,IAAY,EAAE,UAAe,EAAE;IACtE,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QACrC,SAAG,CAAC,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC,GAAQ,EAAE,EAAE;YACtC,IAAI,GAAG,EAAE;gBACP,MAAM,CAAC,GAAG,CAAC,CAAC;aACb;iBAAM;gBACL,OAAO,EAAE,CAAC;aACX;QACH,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC;AAVD,4BAUC;AAED,MAAa,SAAS;IAAtB;QACE,UAAK,GAA6B,EAAE,CAAC;QACrC,cAAS,GAAG,CAAC,CAAC;IA6BhB,CAAC;IA3BC,KAAK,CAAC,OAAO;QACX,IAAI,IAAI,CAAC,SAAS,GAAG,CAAC,EAAE;YACtB,IAAI,CAAC,SAAS,IAAI,CAAC,CAAC;YACpB,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;SAC9B;QAED,6FAA6F;QAC7F,0DAA0D;QAC1D,OAAO,IAAI,OAAO,CAAC,QAAQ,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;IAC5D,CAAC;IAED,OAAO;QACL,IAAI,CAAC,SAAS,IAAI,CAAC,CAAC;QAEpB,IAAI,IAAI,CAAC,SAAS,GAAG,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;YAC/C,MAAM,IAAI,KAAK,CAAC,mEAAmE,CAAC,CAAC;SACtF;aAAM,IAAI,IAAI,CAAC,SAAS,KAAK,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;YACxD,qFAAqF;YACrF,yEAAyE;YACzE,IAAI,CAAC,SAAS,IAAI,CAAC,CAAC;YAEpB,MAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;YACxC,IAAI,YAAY,EAAE;gBAChB,YAAY,CAAC,IAAI,CAAC,CAAC;aACpB;SACF;IACH,CAAC;CACF;AA/BD,8BA+BC","sourcesContent":["import { ncp } from 'ncp';\n\nexport function ncpAsync(source: string, dest: string, options: any = {}) {\n  return new Promise((resolve, reject) => {\n    ncp(source, dest, options, (err: any) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nexport class Semaphore {\n  queue: ((v: boolean) => void)[] = [];\n  available = 1;\n\n  async acquire(): Promise<boolean> {\n    if (this.available > 0) {\n      this.available -= 1;\n      return Promise.resolve(true);\n    }\n\n    // If there is no permit available, we return a promise that resolves once the semaphore gets\n    // signaled enough times that \"available\" is equal to one.\n    return new Promise(resolver => this.queue.push(resolver));\n  }\n\n  release() {\n    this.available += 1;\n\n    if (this.available > 1 && this.queue.length > 0) {\n      throw new Error('this.available should never be > 0 when there is someone waiting.');\n    } else if (this.available === 1 && this.queue.length > 0) {\n      // If there is someone else waiting, immediately consume the permit that was released\n      // at the beginning of this function and let the waiting function resume.\n      this.available -= 1;\n\n      const nextResolver = this.queue.shift();\n      if (nextResolver) {\n        nextResolver(true);\n      }\n    }\n  }\n}\n"]}
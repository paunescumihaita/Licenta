"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = __importDefault(require("fs-extra"));
const hasbin_1 = __importDefault(require("hasbin"));
const path_1 = __importDefault(require("path"));
const internal_1 = require("./internal");
exports.OSX_SOURCE_PATH = path_1.default.join(__dirname, '..', 'binaries', 'osx');
function _hasbinAsync(name) {
    return new Promise((resolve, reject) => {
        hasbin_1.default(name, result => {
            resolve(result);
        });
    });
}
function getBinariesPath() {
    if (process.platform === 'darwin') {
        return path_1.default.join(__dirname, '..', 'binaries', 'osx');
    }
    else if (process.platform === 'win32') {
        return path_1.default.join(__dirname, '..', 'binaries', 'windows');
    }
    else if (process.platform === 'linux') {
        return path_1.default.join(__dirname, '..', 'binaries', 'linux');
    }
    else {
        throw new internal_1.XDLError('PLATFORM_NOT_SUPPORTED', 'Platform not supported.');
    }
}
exports.getBinariesPath = getBinariesPath;
async function addToPathAsync(name) {
    if (await _hasbinAsync(name)) {
        return;
    }
    // Users can set {ignoreBundledBinaries: ["watchman"]} to tell us to never use our version
    const ignoreBundledBinaries = await internal_1.UserSettings.getAsync('ignoreBundledBinaries', []);
    if (ignoreBundledBinaries.includes(name)) {
        return;
    }
    const binariesPath = path_1.default.join(getBinariesPath(), name);
    _prependToPath(binariesPath);
}
exports.addToPathAsync = addToPathAsync;
function _prependToPath(newPath) {
    let currentPath = process.env.PATH ? process.env.PATH : '';
    if (currentPath.length > 0) {
        const delimiter = process.platform === 'win32' ? ';' : ':';
        currentPath = `${delimiter}${currentPath}`;
    }
    process.env.PATH = `${newPath}${currentPath}`;
}
async function writePathToUserSettingsAsync() {
    await internal_1.UserSettings.setAsync('PATH', process.env.PATH);
    // Used in detach app
    const pathFile = path_1.default.join(internal_1.UserSettings.dotExpoHomeDirectory(), 'PATH');
    await fs_extra_1.default.writeFile(pathFile, process.env.PATH);
}
exports.writePathToUserSettingsAsync = writePathToUserSettingsAsync;
function _isDirectory(dir) {
    try {
        if (fs_extra_1.default.statSync(dir).isDirectory()) {
            return true;
        }
        return false;
    }
    catch (e) {
        return false;
    }
}
function isXcodeInstalled() {
    return _isDirectory('/Applications/Xcode.app/');
}
exports.isXcodeInstalled = isXcodeInstalled;
//# sourceMappingURL=Binaries.js.map
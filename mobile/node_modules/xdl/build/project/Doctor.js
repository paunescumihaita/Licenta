"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("@expo/config");
const schemer_1 = __importStar(require("@expo/schemer"));
const spawn_async_1 = __importDefault(require("@expo/spawn-async"));
const getenv_1 = __importDefault(require("getenv"));
const is_reachable_1 = __importDefault(require("is-reachable"));
const resolve_from_1 = __importDefault(require("resolve-from"));
const semver_1 = __importDefault(require("semver"));
const internal_1 = require("../internal");
exports.NO_ISSUES = 0;
exports.WARNING = 1;
exports.ERROR = 2;
exports.FATAL = 3;
const MIN_WATCHMAN_VERSION = '4.6.0';
const MIN_NPM_VERSION = '3.0.0';
const CORRECT_NPM_VERSION = 'latest';
const WARN_NPM_VERSION_RANGES = ['>= 5.0.0 < 5.7.0'];
const BAD_NPM_VERSION_RANGES = ['>= 5.0.0 <= 5.0.3'];
const EXPO_NO_DOCTOR = getenv_1.default.boolish('EXPO_NO_DOCTOR', false);
function _isNpmVersionWithinRanges(npmVersion, ranges) {
    return ranges.some(range => semver_1.default.satisfies(npmVersion, range));
}
async function _checkNpmVersionAsync(projectRoot) {
    try {
        try {
            const yarnVersionResponse = await spawn_async_1.default('yarnpkg', ['--version']);
            if (yarnVersionResponse.status === 0) {
                return exports.NO_ISSUES;
            }
        }
        catch (e) { }
        const npmVersionResponse = await spawn_async_1.default('npm', ['--version']);
        const npmVersion = npmVersionResponse.stdout.trim();
        if (semver_1.default.lt(npmVersion, MIN_NPM_VERSION) ||
            _isNpmVersionWithinRanges(npmVersion, BAD_NPM_VERSION_RANGES)) {
            internal_1.ProjectUtils.logError(projectRoot, 'expo', `Error: You are using npm version ${npmVersion}. We recommend the latest version ${CORRECT_NPM_VERSION}. To install it, run 'npm i -g npm@${CORRECT_NPM_VERSION}'.`, 'doctor-npm-version');
            return exports.WARNING;
        }
        else if (_isNpmVersionWithinRanges(npmVersion, WARN_NPM_VERSION_RANGES)) {
            internal_1.ProjectUtils.logWarning(projectRoot, 'expo', `Warning: You are using npm version ${npmVersion}. There may be bugs in this version, use it at your own risk. We recommend version ${CORRECT_NPM_VERSION}.`, 'doctor-npm-version');
        }
        else {
            internal_1.ProjectUtils.clearNotification(projectRoot, 'doctor-npm-version');
        }
    }
    catch (e) {
        internal_1.ProjectUtils.logWarning(projectRoot, 'expo', `Warning: Could not determine npm version. Make sure your version is >= ${MIN_NPM_VERSION} - we recommend ${CORRECT_NPM_VERSION}.`, 'doctor-npm-version');
        return exports.WARNING;
    }
    return exports.NO_ISSUES;
}
async function _checkWatchmanVersionAsync(projectRoot) {
    // There's no point in checking any of this stuff if watchman isn't supported on this platform
    if (!internal_1.Watchman.isPlatformSupported()) {
        internal_1.ProjectUtils.clearNotification(projectRoot, 'doctor-watchman-version');
        return;
    }
    const watchmanVersion = await internal_1.Watchman.unblockAndGetVersionAsync(projectRoot);
    // If we can't get the watchman version, `getVersionAsync` will return `null`
    if (!watchmanVersion) {
        // watchman is probably just not installed
        internal_1.ProjectUtils.clearNotification(projectRoot, 'doctor-watchman-version');
        return;
    }
    if (semver_1.default.lt(watchmanVersion, MIN_WATCHMAN_VERSION)) {
        let warningMessage = `Warning: You are using an old version of watchman (v${watchmanVersion}). This may cause problems for you.\n\nWe recommend that you either uninstall watchman (and XDE will try to use a copy it is bundled with) or upgrade watchman to a newer version, at least v${MIN_WATCHMAN_VERSION}.`;
        // Add a note about homebrew if the user is on a Mac
        if (process.platform === 'darwin') {
            warningMessage += `\n\nIf you are using homebrew, try:\nbrew uninstall watchman; brew install watchman`;
        }
        internal_1.ProjectUtils.logWarning(projectRoot, 'expo', warningMessage, 'doctor-watchman-version');
    }
    else {
        internal_1.ProjectUtils.clearNotification(projectRoot, 'doctor-watchman-version');
    }
}
async function validateWithSchema(projectRoot, _a, schema, configName, validateAssets) {
    var { 
    // Extract internal from the config object.
    _internal } = _a, exp = __rest(_a, ["_internal"]);
    let schemaErrorMessage;
    let assetsErrorMessage;
    const validator = new schemer_1.default(schema, { rootDir: projectRoot });
    // Validate the schema itself
    try {
        await validator.validateSchemaAsync(exp);
    }
    catch (e) {
        if (e instanceof schemer_1.SchemerError) {
            schemaErrorMessage = `Error: Problem${e.errors.length > 1 ? 's' : ''} validating fields in ${configName}. See https://docs.expo.io/workflow/configuration/`;
            schemaErrorMessage += e.errors.map(formatValidationError).join('');
        }
    }
    if (validateAssets) {
        try {
            await validator.validateAssetsAsync(exp);
        }
        catch (e) {
            if (e instanceof schemer_1.SchemerError) {
                assetsErrorMessage = `Error: Problem${e.errors.length > 1 ? '' : 's'} validating asset fields in ${configName}. See ${internal_1.Config.helpUrl}`;
                assetsErrorMessage += e.errors.map(formatValidationError).join('');
            }
        }
    }
    return { schemaErrorMessage, assetsErrorMessage };
}
function formatValidationError(validationError) {
    return `\n â€¢ ${validationError.fieldPath ? 'Field: ' + validationError.fieldPath + ' - ' : ''}${validationError.message}.`;
}
async function _validateExpJsonAsync(exp, pkg, projectRoot, allowNetwork, skipSDKVersionRequirement) {
    if (!exp || !pkg) {
        // getConfig already logged an error
        return exports.FATAL;
    }
    try {
        await _checkWatchmanVersionAsync(projectRoot);
    }
    catch (e) {
        internal_1.ProjectUtils.logWarning(projectRoot, 'expo', `Warning: Problem checking watchman version. ${e.message}.`, 'doctor-problem-checking-watchman-version');
    }
    internal_1.ProjectUtils.clearNotification(projectRoot, 'doctor-problem-checking-watchman-version');
    const sdkVersion = exp.sdkVersion;
    const configName = config_1.configFilename(projectRoot);
    // Warn if sdkVersion is UNVERSIONED
    if (sdkVersion === 'UNVERSIONED' && !process.env.EXPO_SKIP_MANIFEST_VALIDATION_TOKEN) {
        internal_1.ProjectUtils.logError(projectRoot, 'expo', `Error: Using unversioned Expo SDK. Do not publish until you set sdkVersion in ${configName}`, 'doctor-unversioned');
        return exports.ERROR;
    }
    internal_1.ProjectUtils.clearNotification(projectRoot, 'doctor-unversioned');
    const sdkVersions = await internal_1.Versions.sdkVersionsAsync();
    if (!sdkVersions) {
        internal_1.ProjectUtils.logError(projectRoot, 'expo', `Error: Couldn't connect to SDK versions server`, 'doctor-versions-endpoint-failed');
        return exports.ERROR;
    }
    internal_1.ProjectUtils.clearNotification(projectRoot, 'doctor-versions-endpoint-failed');
    if (!skipSDKVersionRequirement && (!sdkVersion || !sdkVersions[sdkVersion])) {
        internal_1.ProjectUtils.logError(projectRoot, 'expo', `Error: Invalid sdkVersion. Valid options are ${Object.keys(sdkVersions).join(', ')}`, 'doctor-invalid-sdk-version');
        return exports.ERROR;
    }
    internal_1.ProjectUtils.clearNotification(projectRoot, 'doctor-invalid-sdk-version');
    // Skip validation if the correct token is set in env
    if (sdkVersion && sdkVersion !== 'UNVERSIONED') {
        try {
            const schema = await internal_1.ExpSchema.getSchemaAsync(sdkVersion);
            const { schemaErrorMessage, assetsErrorMessage } = await validateWithSchema(projectRoot, exp, schema, configName, allowNetwork);
            if (schemaErrorMessage) {
                internal_1.ProjectUtils.logError(projectRoot, 'expo', schemaErrorMessage, 'doctor-schema-validation');
            }
            else {
                internal_1.ProjectUtils.clearNotification(projectRoot, 'doctor-schema-validation');
            }
            if (assetsErrorMessage) {
                internal_1.ProjectUtils.logError(projectRoot, 'expo', assetsErrorMessage, `doctor-validate-asset-fields`);
            }
            else {
                internal_1.ProjectUtils.clearNotification(projectRoot, `doctor-validate-asset-fields`);
            }
            internal_1.ProjectUtils.clearNotification(projectRoot, 'doctor-schema-validation-exception');
            if (schemaErrorMessage || assetsErrorMessage)
                return exports.ERROR;
        }
        catch (e) {
            internal_1.ProjectUtils.logWarning(projectRoot, 'expo', `Warning: Problem validating ${configName}: ${e.message}.`, 'doctor-schema-validation-exception');
        }
    }
    if (sdkVersion) {
        const reactNativeIssue = await _validateReactNativeVersionAsync(exp, pkg, projectRoot, sdkVersions, sdkVersion);
        if (reactNativeIssue !== exports.NO_ISSUES) {
            return reactNativeIssue;
        }
    }
    // TODO: Check any native module versions here
    return exports.NO_ISSUES;
}
async function _validateReactNativeVersionAsync(exp, pkg, projectRoot, sdkVersions, sdkVersion) {
    var _a, _b, _c, _d;
    if (internal_1.Config.validation.reactNativeVersionWarnings) {
        let reactNative = null;
        if ((_a = pkg.dependencies) === null || _a === void 0 ? void 0 : _a['react-native']) {
            reactNative = pkg.dependencies['react-native'];
        }
        else if ((_b = pkg.devDependencies) === null || _b === void 0 ? void 0 : _b['react-native']) {
            reactNative = pkg.devDependencies['react-native'];
        }
        else if ((_c = pkg.peerDependencies) === null || _c === void 0 ? void 0 : _c['react-native']) {
            reactNative = pkg.peerDependencies['react-native'];
        }
        // react-native is required
        if (!reactNative) {
            internal_1.ProjectUtils.logError(projectRoot, 'expo', `Error: Can't find react-native in package.json dependencies`, 'doctor-no-react-native-in-package-json');
            return exports.ERROR;
        }
        internal_1.ProjectUtils.clearNotification(projectRoot, 'doctor-no-react-native-in-package-json');
        if (internal_1.Versions.gteSdkVersion(exp, '41.0.0') && ((_d = pkg.dependencies) === null || _d === void 0 ? void 0 : _d['@react-native-community/async-storage'])) {
            internal_1.ProjectUtils.logWarning(projectRoot, 'expo', `@react-native-community/async-storage has been renamed. To upgrade:\n- remove @react-native-community/async-storage from package.json\n- run "expo install @react-native-async-storage/async-storage"\n- run "npx expo-codemod sdk41-async-storage src" to rename imports`, 'doctor-legacy-async-storage');
            return exports.WARNING;
        }
        else {
            internal_1.ProjectUtils.clearNotification(projectRoot, 'doctor-legacy-async-storage');
        }
        if (!exp.isDetached) {
            return exports.NO_ISSUES;
            // (TODO-2017-07-20): Validate the react-native version if it uses
            // officially published package rather than Expo fork. Expo fork of
            // react-native was required before CRNA. We now only run the react-native
            // validation of the version if we are using the fork. We should probably
            // validate the version here as well such that it matches with the
            // react-native version compatible with the selected SDK.
        }
        // Expo fork of react-native is required
        if (!/expo\/react-native/.test(reactNative)) {
            internal_1.ProjectUtils.logWarning(projectRoot, 'expo', `Warning: Not using the Expo fork of react-native. See ${internal_1.Config.helpUrl}.`, 'doctor-not-using-expo-fork');
            return exports.WARNING;
        }
        internal_1.ProjectUtils.clearNotification(projectRoot, 'doctor-not-using-expo-fork');
        try {
            const reactNativeTag = reactNative.match(/sdk-\d+\.\d+\.\d+/)[0];
            const sdkVersionObject = sdkVersions[sdkVersion];
            // TODO: Want to be smarter about this. Maybe warn if there's a newer version.
            if (semver_1.default.major(internal_1.Versions.parseSdkVersionFromTag(reactNativeTag)) !==
                semver_1.default.major(internal_1.Versions.parseSdkVersionFromTag(sdkVersionObject['expoReactNativeTag']))) {
                internal_1.ProjectUtils.logWarning(projectRoot, 'expo', `Warning: Invalid version of react-native for sdkVersion ${sdkVersion}. Use github:expo/react-native#${sdkVersionObject['expoReactNativeTag']}`, 'doctor-invalid-version-of-react-native');
                return exports.WARNING;
            }
            internal_1.ProjectUtils.clearNotification(projectRoot, 'doctor-invalid-version-of-react-native');
            internal_1.ProjectUtils.clearNotification(projectRoot, 'doctor-malformed-version-of-react-native');
        }
        catch (e) {
            internal_1.ProjectUtils.logWarning(projectRoot, 'expo', `Warning: ${reactNative} is not a valid version. Version must be in the form of sdk-x.y.z. Please update your package.json file.`, 'doctor-malformed-version-of-react-native');
            return exports.WARNING;
        }
    }
    return exports.NO_ISSUES;
}
async function _validateNodeModulesAsync(projectRoot) {
    // Check to make sure react-native is installed
    if (resolve_from_1.default.silent(projectRoot, 'react-native/local-cli/cli.js')) {
        internal_1.ProjectUtils.clearNotification(projectRoot, 'doctor-react-native-not-installed');
    }
    else {
        internal_1.ProjectUtils.logError(projectRoot, 'expo', `Error: react-native is not installed. Please run \`npm install\` or \`yarn\` in your project directory.`, 'doctor-react-native-not-installed');
        return exports.FATAL;
    }
    return exports.NO_ISSUES;
}
async function validateWithoutNetworkAsync(projectRoot, options = {}) {
    return validateAsync(projectRoot, false, options.skipSDKVersionRequirement);
}
exports.validateWithoutNetworkAsync = validateWithoutNetworkAsync;
async function validateWithNetworkAsync(projectRoot, options = {}) {
    return validateAsync(projectRoot, true, options.skipSDKVersionRequirement);
}
exports.validateWithNetworkAsync = validateWithNetworkAsync;
async function validateAsync(projectRoot, allowNetwork, skipSDKVersionRequirement) {
    if (EXPO_NO_DOCTOR) {
        return exports.NO_ISSUES;
    }
    const { exp, pkg } = config_1.getConfig(projectRoot, {
        strict: true,
        skipSDKVersionRequirement,
    });
    internal_1.ProjectUtils.clearNotification(projectRoot, 'doctor-config-json-not-read');
    let status = await _checkNpmVersionAsync(projectRoot);
    if (status === exports.FATAL) {
        return status;
    }
    const expStatus = await _validateExpJsonAsync(exp, pkg, projectRoot, allowNetwork, skipSDKVersionRequirement);
    if (expStatus === exports.FATAL) {
        return expStatus;
    }
    status = Math.max(status, expStatus);
    const nodeModulesStatus = await _validateNodeModulesAsync(projectRoot);
    if (nodeModulesStatus > status) {
        return nodeModulesStatus;
    }
    return status;
}
async function validateExpoServersAsync(projectRoot) {
    const domains = ['expo.io', 'expo.fyi', 'expo.dev', 'static.expo.dev', 'exp.host'];
    const attempts = await Promise.all(domains.map(async (domain) => ({
        domain,
        reachable: await is_reachable_1.default(domain),
    })));
    const failures = attempts.filter(attempt => !attempt.reachable);
    if (failures.length) {
        failures.forEach(failure => {
            internal_1.ProjectUtils.logWarning(projectRoot, 'expo', `Warning: could not reach \`${failure.domain}\`.`, `doctor-server-dashboard-not-reachable-${failure.domain}`);
        });
        console.log();
        internal_1.ProjectUtils.logWarning(projectRoot, 'expo', `We couldn't reach some of our domains, this might cause issues on our website or services.\nPlease check your network configuration and try to access these domains in your browser.`, 'doctor-server-dashboard-not-reachable');
        console.log();
        return exports.WARNING;
    }
    return exports.NO_ISSUES;
}
exports.validateExpoServersAsync = validateExpoServersAsync;
//# sourceMappingURL=Doctor.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("@expo/config");
const schemer_1 = __importDefault(require("@expo/schemer"));
const fs_1 = __importDefault(require("fs"));
const getenv_1 = require("getenv");
const json_schema_deref_sync_1 = __importDefault(require("json-schema-deref-sync"));
const path_1 = __importDefault(require("path"));
const internal_1 = require("../internal");
const _xdlSchemaJson = {};
const _schemaCaches = {};
async function validatorFromProjectRoot(projectRoot) {
    const { exp } = config_1.getConfig(projectRoot);
    if (!exp.sdkVersion)
        throw new Error(`Couldn't read local manifest`);
    const schema = await getSchemaAsync(exp.sdkVersion);
    const validator = new schemer_1.default(schema);
    return validator;
}
exports.validatorFromProjectRoot = validatorFromProjectRoot;
async function validateAsync(projectRoot) {
    const { exp } = config_1.getConfig(projectRoot);
    if (!exp.sdkVersion)
        throw new Error(`Couldn't read local manifest`);
    const schema = await getSchemaAsync(exp.sdkVersion);
    const validator = new schemer_1.default(schema);
    await validator.validateAll(exp);
}
exports.validateAsync = validateAsync;
async function getSchemaAsync(sdkVersion) {
    const json = await _getSchemaJSONAsync(sdkVersion);
    const schema = json_schema_deref_sync_1.default(json.schema);
    return schema;
}
exports.getSchemaAsync = getSchemaAsync;
/**
 * Array of schema nodes that refer to assets along with their field path (eg. 'notification.icon')
 *
 * @param sdkVersion
 */
async function getAssetSchemasAsync(sdkVersion) {
    // If no SDK version is available then fall back to unversioned
    const schema = await getSchemaAsync(sdkVersion !== null && sdkVersion !== void 0 ? sdkVersion : 'UNVERSIONED');
    const assetSchemas = [];
    const visit = (node, fieldPath) => {
        if (node.meta && node.meta.asset) {
            assetSchemas.push(fieldPath);
        }
        const properties = node.properties;
        if (properties) {
            Object.keys(properties).forEach(property => visit(properties[property], `${fieldPath}${fieldPath.length > 0 ? '.' : ''}${property}`));
        }
    };
    visit(schema, '');
    return assetSchemas;
}
exports.getAssetSchemasAsync = getAssetSchemasAsync;
async function _getSchemaJSONAsync(sdkVersion) {
    if (getenv_1.boolish('LOCAL_XDL_SCHEMA', false)) {
        if (process.env.EXPONENT_UNIVERSE_DIR) {
            return JSON.parse(fs_1.default
                .readFileSync(path_1.default.join(process.env.EXPONENT_UNIVERSE_DIR, 'server', 'www', 'xdl-schemas', 'UNVERSIONED-schema.json'))
                .toString());
        }
        else {
            throw new Error(`LOCAL_XDL_SCHEMA is set but EXPONENT_UNIVERSE_DIR is not.`);
        }
    }
    if (!_xdlSchemaJson[sdkVersion]) {
        try {
            _xdlSchemaJson[sdkVersion] = await getConfigurationSchemaAsync(sdkVersion);
        }
        catch (e) {
            if (e.code && e.code === 'INVALID_JSON') {
                throw new Error(`Couldn't read schema from server`);
            }
            else {
                throw e;
            }
        }
    }
    return _xdlSchemaJson[sdkVersion];
}
async function getConfigurationSchemaAsync(sdkVersion) {
    if (!_schemaCaches.hasOwnProperty(sdkVersion)) {
        _schemaCaches[sdkVersion] = new internal_1.FsCache.Cacher(async () => {
            return await new internal_1.ApiV2().getAsync(`project/configuration/schema/${sdkVersion}`);
        }, `schema-${sdkVersion}.json`, 0, path_1.default.join(__dirname, `../caches/schema-${sdkVersion}.json`));
    }
    return await _schemaCaches[sdkVersion].getAsync();
}
//# sourceMappingURL=ExpSchema.js.map
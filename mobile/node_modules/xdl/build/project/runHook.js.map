{"version":3,"file":"runHook.js","sourceRoot":"","sources":["../../src/project/runHook.ts"],"names":[],"mappings":";;;;;AACA,sDAA8B;AAC9B,gEAAuC;AAEvC,0CAAyD;AAMzD,SAAS,kBAAkB,CAAC,WAAmB,EAAE,UAAkB;IACjE,IAAI;QACF,MAAM,QAAQ,GAAG,sBAAW,CAAC,WAAW,EAAE,UAAU,CAAC,CAAC;QACtD,uEAAuE;QACvE,iDAAiD;QACjD,iBAAO,CAAC,QAAQ,CAAC,CAAC;QAClB,OAAO,OAAO,CAAC,QAAQ,CAAC,CAAC;KAC1B;IAAC,WAAM;QACN,OAAO,IAAI,CAAC;KACb;AACH,CAAC;AAED,SAAgB,YAAY,CAAC,KAA0B,EAAE,QAAkB,EAAE,WAAmB;;IAC9F,MAAM,UAAU,GAAiB,EAAE,CAAC;IAEpC,IAAI,KAAK,EAAE;QACT,IAAI,KAAK,CAAC,QAAQ,CAAC,EAAE;YACnB,KAAK,CAAC,QAAQ,CAAE,CAAC,OAAO,CAAC,CAAC,IAAS,EAAE,EAAE;gBACrC,MAAM,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC;gBACtB,MAAM,EAAE,GAAG,kBAAkB,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;gBACjD,IAAI,OAAO,EAAE,KAAK,UAAU,EAAE;oBAC5B,iBAAM,CAAC,MAAM,CAAC,KAAK,CACjB,kBAAkB,QAAQ,WAAW,IAAI,2CAA2C,CACrF,CAAC;iBACH;qBAAM;oBACL,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC;oBACd,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBACvB;YACH,CAAC,CAAC,CAAC;SACJ;QAED,IAAI,KAAK,CAAC,QAAQ,CAAC,KAAK,SAAS,IAAI,UAAU,CAAC,MAAM,YAAK,KAAK,CAAC,QAAQ,CAAC,0CAAE,MAAM,CAAA,EAAE;YAClF,MAAM,IAAI,mBAAQ,CAChB,2BAA2B,EAC3B,mBAAmB,QAAQ,qBAAqB,CACjD,CAAC;SACH;KACF;IAED,OAAO,UAAU,CAAC;AACpB,CAAC;AA5BD,oCA4BC;AAEM,KAAK,UAAU,OAAO,CAAC,IAAgB,EAAE,WAA0C;IACxF,IAAI,MAAM,GAAG,IAAI,CAAC,GAAG,iBACnB,MAAM,EAAE,IAAI,CAAC,MAAM,IAChB,WAAW,EACd,CAAC;IAEH,4CAA4C;IAC5C,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,EAAE;QACzB,MAAM,GAAG,MAAM,MAAM,CAAC;KACvB;IAED,IAAI,MAAM,EAAE;QACV,iBAAM,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,EAAE,MAAM,CAAC,CAAC;KAC7C;AACH,CAAC;AAdD,0BAcC","sourcesContent":["import { ExpoConfig, Hook, HookArguments, HookType } from '@expo/config';\nimport decache from 'decache';\nimport resolveFrom from 'resolve-from';\n\nimport { Logger as logger, XDLError } from '../internal';\n\nexport type LoadedHook = Hook & {\n  _fn: (input: HookArguments) => any;\n};\n\nfunction requireFromProject(projectRoot: string, modulePath: string) {\n  try {\n    const fullPath = resolveFrom(projectRoot, modulePath);\n    // Clear the require cache for this module so get a fresh version of it\n    // without requiring the user to restart Expo CLI\n    decache(fullPath);\n    return require(fullPath);\n  } catch {\n    return null;\n  }\n}\n\nexport function prepareHooks(hooks: ExpoConfig['hooks'], hookType: HookType, projectRoot: string) {\n  const validHooks: LoadedHook[] = [];\n\n  if (hooks) {\n    if (hooks[hookType]) {\n      hooks[hookType]!.forEach((hook: any) => {\n        const { file } = hook;\n        const fn = requireFromProject(projectRoot, file);\n        if (typeof fn !== 'function') {\n          logger.global.error(\n            `Unable to load ${hookType} hook: '${file}'. The module does not export a function.`\n          );\n        } else {\n          hook._fn = fn;\n          validHooks.push(hook);\n        }\n      });\n    }\n\n    if (hooks[hookType] !== undefined && validHooks.length !== hooks[hookType]?.length) {\n      throw new XDLError(\n        'HOOK_INITIALIZATION_ERROR',\n        `Please fix your ${hookType} hook configuration`\n      );\n    }\n  }\n\n  return validHooks;\n}\n\nexport async function runHook(hook: LoadedHook, hookOptions: Omit<HookArguments, 'config'>) {\n  let result = hook._fn({\n    config: hook.config,\n    ...hookOptions,\n  });\n\n  // If it's a promise, wait for it to resolve\n  if (result && result.then) {\n    result = await result;\n  }\n\n  if (result) {\n    logger.global.info({ quiet: true }, result);\n  }\n}\n"]}
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const decache_1 = __importDefault(require("decache"));
const resolve_from_1 = __importDefault(require("resolve-from"));
const internal_1 = require("../internal");
function requireFromProject(projectRoot, modulePath) {
    try {
        const fullPath = resolve_from_1.default(projectRoot, modulePath);
        // Clear the require cache for this module so get a fresh version of it
        // without requiring the user to restart Expo CLI
        decache_1.default(fullPath);
        return require(fullPath);
    }
    catch (_a) {
        return null;
    }
}
function prepareHooks(hooks, hookType, projectRoot) {
    var _a;
    const validHooks = [];
    if (hooks) {
        if (hooks[hookType]) {
            hooks[hookType].forEach((hook) => {
                const { file } = hook;
                const fn = requireFromProject(projectRoot, file);
                if (typeof fn !== 'function') {
                    internal_1.Logger.global.error(`Unable to load ${hookType} hook: '${file}'. The module does not export a function.`);
                }
                else {
                    hook._fn = fn;
                    validHooks.push(hook);
                }
            });
        }
        if (hooks[hookType] !== undefined && validHooks.length !== ((_a = hooks[hookType]) === null || _a === void 0 ? void 0 : _a.length)) {
            throw new internal_1.XDLError('HOOK_INITIALIZATION_ERROR', `Please fix your ${hookType} hook configuration`);
        }
    }
    return validHooks;
}
exports.prepareHooks = prepareHooks;
async function runHook(hook, hookOptions) {
    let result = hook._fn(Object.assign({ config: hook.config }, hookOptions));
    // If it's a promise, wait for it to resolve
    if (result && result.then) {
        result = await result;
    }
    if (result) {
        internal_1.Logger.global.info({ quiet: true }, result);
    }
}
exports.runHook = runHook;
//# sourceMappingURL=runHook.js.map
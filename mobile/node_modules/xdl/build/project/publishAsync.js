"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("@expo/config");
const form_data_1 = __importDefault(require("form-data"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const internal_1 = require("../internal");
async function publishAsync(projectRoot, options = {}) {
    var _a, _b, _c, _d, _e, _f;
    options.target = (_a = options.target) !== null && _a !== void 0 ? _a : config_1.getDefaultTarget(projectRoot);
    const target = options.target;
    const user = await internal_1.UserManager.ensureLoggedInAsync();
    if (internal_1.Env.isDebug()) {
        console.log();
        console.log('Publish Assets:');
        console.log(`- Asset target: ${target}`);
        console.log();
    }
    internal_1.Analytics.logEvent('Publish', {
        projectRoot,
        developerTool: internal_1.Config.developerTool,
    });
    const validationStatus = await internal_1.Doctor.validateWithNetworkAsync(projectRoot);
    if (validationStatus === internal_1.Doctor.ERROR || validationStatus === internal_1.Doctor.FATAL) {
        throw new internal_1.XDLError('PUBLISH_VALIDATION_ERROR', "Couldn't publish because errors were found. (See logs above.) Please fix the errors and try again.");
    }
    // Get project config
    const { exp, pkg, hooks } = await internal_1.getPublishExpConfigAsync(projectRoot, options);
    // Exit early if kernel builds are created with robot users
    if (exp.isKernel && user.kind === 'robot') {
        throw new internal_1.XDLError('ROBOT_ACCOUNT_ERROR', 'Kernel builds are not available for robot users');
    }
    // TODO: refactor this out to a function, throw error if length doesn't match
    const validPostPublishHooks = internal_1.prepareHooks(hooks, 'postPublish', projectRoot);
    const bundles = await internal_1.createBundlesAsync(projectRoot, options, {
        useDevServer: internal_1.Env.shouldUseDevServer(exp),
    });
    internal_1.printBundleSizes(bundles);
    await internal_1.ProjectAssets.publishAssetsAsync({ projectRoot, exp, bundles });
    const androidBundle = bundles.android.code;
    const iosBundle = bundles.ios.code;
    const hasHooks = validPostPublishHooks.length > 0;
    const shouldPublishAndroidMaps = !!((_b = exp.android) === null || _b === void 0 ? void 0 : _b.publishSourceMapPath);
    const shouldPublishIosMaps = !!((_c = exp.ios) === null || _c === void 0 ? void 0 : _c.publishSourceMapPath);
    const androidSourceMap = hasHooks || shouldPublishAndroidMaps ? bundles.android.map : null;
    const iosSourceMap = hasHooks || shouldPublishIosMaps ? bundles.ios.map : null;
    let response;
    try {
        response = await _uploadArtifactsAsync({
            pkg,
            exp,
            iosBundle,
            androidBundle,
            options,
        });
    }
    catch (e) {
        if (e.serverError === 'SCHEMA_VALIDATION_ERROR') {
            throw new Error(`There was an error validating your project schema. Check for any warnings about the contents of your app.json or app.config.js.`);
        }
        internal_1.Sentry.captureException(e);
        throw e;
    }
    let androidManifest = {};
    let iosManifest = {};
    if (validPostPublishHooks.length || ((_d = exp.ios) === null || _d === void 0 ? void 0 : _d.publishManifestPath) || ((_e = exp.android) === null || _e === void 0 ? void 0 : _e.publishManifestPath) ||
        internal_1.EmbeddedAssets.shouldEmbedAssetsForExpoUpdates(projectRoot, exp, pkg, target)) {
        [androidManifest, iosManifest] = await Promise.all([
            internal_1.ExponentTools.getManifestAsync(response.url, {
                'Exponent-SDK-Version': exp.sdkVersion,
                'Exponent-Platform': 'android',
                'Expo-Release-Channel': options.releaseChannel,
                Accept: 'application/expo+json,application/json',
            }),
            internal_1.ExponentTools.getManifestAsync(response.url, {
                'Exponent-SDK-Version': exp.sdkVersion,
                'Exponent-Platform': 'ios',
                'Expo-Release-Channel': options.releaseChannel,
                Accept: 'application/expo+json,application/json',
            }),
        ]);
        const hookOptions = {
            url: response.url,
            exp,
            iosBundle,
            iosSourceMap,
            iosManifest,
            androidBundle,
            androidSourceMap,
            androidManifest,
            projectRoot,
            log: (msg) => {
                internal_1.Logger.global.info({ quiet: true }, msg);
            },
        };
        for (const hook of validPostPublishHooks) {
            internal_1.Logger.global.info(`Running postPublish hook: ${hook.file}`);
            try {
                internal_1.runHook(hook, hookOptions);
            }
            catch (e) {
                internal_1.Logger.global.warn(`Warning: postPublish hook '${hook.file}' failed: ${e.stack}`);
            }
        }
    }
    const fullManifestUrl = response.url.replace('exp://', 'https://');
    await internal_1.EmbeddedAssets.configureAsync({
        projectRoot,
        pkg,
        exp,
        releaseChannel: (_f = options.releaseChannel) !== null && _f !== void 0 ? _f : 'default',
        iosManifestUrl: fullManifestUrl,
        iosManifest,
        iosBundle,
        iosSourceMap,
        androidManifestUrl: fullManifestUrl,
        androidManifest,
        androidBundle,
        androidSourceMap,
        target,
    });
    // TODO: move to postPublish hook
    // This method throws early when a robot account is used for a kernel build
    if (exp.isKernel && user.kind !== 'robot') {
        await _handleKernelPublishedAsync({
            user,
            exp,
            projectRoot,
            url: response.url,
        });
    }
    return Object.assign(Object.assign({}, response), { url: options.releaseChannel && options.releaseChannel !== 'default'
            ? `${response.url}?release-channel=${options.releaseChannel}`
            : response.url });
}
exports.publishAsync = publishAsync;
async function _uploadArtifactsAsync({ exp, iosBundle, androidBundle, options, pkg, }) {
    internal_1.Logger.global.info('');
    internal_1.Logger.global.info('Uploading JavaScript bundles');
    const formData = new form_data_1.default();
    formData.append('expJson', JSON.stringify(exp));
    formData.append('packageJson', JSON.stringify(pkg));
    formData.append('iosBundle', iosBundle, 'iosBundle');
    formData.append('androidBundle', androidBundle, 'androidBundle');
    formData.append('options', JSON.stringify(options));
    const user = await internal_1.UserManager.ensureLoggedInAsync();
    const api = internal_1.ApiV2.clientForUser(user);
    return await api.uploadFormDataAsync('publish/new', formData);
}
async function _handleKernelPublishedAsync({ projectRoot, user, exp, url, }) {
    var _a, _b;
    let kernelBundleUrl = `${internal_1.Config.api.scheme}://${internal_1.Config.api.host}`;
    if (internal_1.Config.api.port) {
        kernelBundleUrl = `${kernelBundleUrl}:${internal_1.Config.api.port}`;
    }
    kernelBundleUrl = `${kernelBundleUrl}/@${user.username}/${exp.slug}/bundle`;
    if ((_a = exp.kernel) === null || _a === void 0 ? void 0 : _a.androidManifestPath) {
        const manifest = await internal_1.ExponentTools.getManifestAsync(url, {
            'Exponent-SDK-Version': exp.sdkVersion,
            'Exponent-Platform': 'android',
            Accept: 'application/expo+json,application/json',
        });
        manifest.bundleUrl = kernelBundleUrl;
        manifest.sdkVersion = 'UNVERSIONED';
        await fs_extra_1.default.writeFile(path_1.default.resolve(projectRoot, exp.kernel.androidManifestPath), JSON.stringify(manifest));
    }
    if ((_b = exp.kernel) === null || _b === void 0 ? void 0 : _b.iosManifestPath) {
        const manifest = await internal_1.ExponentTools.getManifestAsync(url, {
            'Exponent-SDK-Version': exp.sdkVersion,
            'Exponent-Platform': 'ios',
            Accept: 'application/expo+json,application/json',
        });
        manifest.bundleUrl = kernelBundleUrl;
        manifest.sdkVersion = 'UNVERSIONED';
        await fs_extra_1.default.writeFile(path_1.default.resolve(projectRoot, exp.kernel.iosManifestPath), JSON.stringify(manifest));
    }
}
//# sourceMappingURL=publishAsync.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("@expo/config");
const dev_server_1 = require("@expo/dev-server");
const axios_1 = __importDefault(require("axios"));
const chalk_1 = __importDefault(require("chalk"));
const internal_1 = require("../internal");
const MINIMUM_BUNDLE_SIZE = 500;
function printBundleSizes(bundles) {
    const files = [
        ['index.ios.js', bundles.ios.code],
        ['index.android.js', bundles.android.code],
    ];
    // Account for inline source maps
    if (bundles.ios.map) {
        files.push([chalk_1.default.dim('index.ios.js.map'), bundles.ios.map]);
    }
    if (bundles.android.map) {
        files.push([chalk_1.default.dim('index.android.js.map'), bundles.android.map]);
    }
    internal_1.Logger.global.info('');
    internal_1.Logger.global.info(internal_1.TableText.createFilesTable(files));
    internal_1.Logger.global.info('');
    internal_1.Logger.global.info(`ðŸ’¡ JavaScript bundle sizes affect startup time. ${chalk_1.default.dim(internal_1.learnMore(`https://expo.fyi/javascript-bundle-sizes`))}`);
    internal_1.Logger.global.info('');
}
exports.printBundleSizes = printBundleSizes;
async function createBundlesAsync(projectRoot, publishOptions = {}, bundleOptions) {
    if (!bundleOptions.useDevServer) {
        try {
            await internal_1.startReactNativeServerAsync({
                projectRoot,
                options: {
                    nonPersistent: true,
                    maxWorkers: publishOptions.maxWorkers,
                    target: publishOptions.target,
                    reset: publishOptions.resetCache,
                },
                verbose: !publishOptions.quiet,
            });
            return await fetchPublishBundlesAsync(projectRoot);
        }
        finally {
            await internal_1.stopReactNativeServerAsync(projectRoot);
        }
    }
    const isLegacy = config_1.isLegacyImportsEnabled(config_1.getConfig(projectRoot, { skipSDKVersionRequirement: true }).exp);
    // If not legacy, delete the target option to prevent warnings from being thrown.
    if (!isLegacy) {
        delete publishOptions.target;
    }
    const platforms = ['android', 'ios'];
    const [android, ios] = await dev_server_1.bundleAsync(projectRoot, {
        target: publishOptions.target,
        resetCache: publishOptions.resetCache,
        logger: internal_1.ProjectUtils.getLogger(projectRoot),
        quiet: publishOptions.quiet,
    }, platforms.map((platform) => ({
        platform,
        entryPoint: internal_1.resolveEntryPoint(projectRoot, platform),
        dev: bundleOptions.dev,
    })));
    return {
        android,
        ios,
    };
}
exports.createBundlesAsync = createBundlesAsync;
// Fetch iOS and Android bundles for publishing
async function fetchPublishBundlesAsync(projectRoot, opts) {
    const entryPoint = internal_1.resolveEntryPoint(projectRoot);
    const publishUrl = await internal_1.UrlUtils.constructPublishUrlAsync(projectRoot, entryPoint, undefined, opts);
    const sourceMapUrl = await internal_1.UrlUtils.constructSourceMapUrlAsync(projectRoot, entryPoint);
    const assetsUrl = await internal_1.UrlUtils.constructAssetsUrlAsync(projectRoot, entryPoint);
    internal_1.Logger.global.info('Building iOS bundle');
    const iosBundle = await _getForPlatformAsync(projectRoot, publishUrl, 'ios', {
        errorCode: 'INVALID_BUNDLE',
        minLength: MINIMUM_BUNDLE_SIZE,
    });
    internal_1.Logger.global.info('Building Android bundle');
    const androidBundle = await _getForPlatformAsync(projectRoot, publishUrl, 'android', {
        errorCode: 'INVALID_BUNDLE',
        minLength: MINIMUM_BUNDLE_SIZE,
    });
    internal_1.Logger.global.info('Building source maps');
    const iosSourceMap = await _getForPlatformAsync(projectRoot, sourceMapUrl, 'ios', {
        errorCode: 'INVALID_BUNDLE',
        minLength: MINIMUM_BUNDLE_SIZE,
    });
    const androidSourceMap = await _getForPlatformAsync(projectRoot, sourceMapUrl, 'android', {
        errorCode: 'INVALID_BUNDLE',
        minLength: MINIMUM_BUNDLE_SIZE,
    });
    internal_1.Logger.global.info('Building asset maps');
    const iosAssetsJson = await _getForPlatformAsync(projectRoot, assetsUrl, 'ios', {
        errorCode: 'INVALID_ASSETS',
    });
    const androidAssetsJson = await _getForPlatformAsync(projectRoot, assetsUrl, 'android', {
        errorCode: 'INVALID_ASSETS',
    });
    return {
        android: { code: androidBundle, map: androidSourceMap, assets: JSON.parse(androidAssetsJson) },
        ios: { code: iosBundle, map: iosSourceMap, assets: JSON.parse(iosAssetsJson) },
    };
}
async function _getForPlatformAsync(projectRoot, url, platform, { errorCode, minLength }) {
    const fullUrl = `${url}&platform=${platform}`;
    let response;
    try {
        response = await axios_1.default.request({
            url: fullUrl,
            responseType: 'text',
            // Workaround for https://github.com/axios/axios/issues/907.
            // Without transformResponse, axios will parse the body as JSON regardless of the responseType/
            transformResponse: [data => data],
            proxy: false,
            validateStatus: status => status === 200,
            headers: {
                'Exponent-Platform': platform,
            },
        });
    }
    catch (error) {
        if (error.response) {
            if (error.response.data) {
                let body;
                try {
                    body = JSON.parse(error.response.data);
                }
                catch (e) {
                    internal_1.ProjectUtils.logError(projectRoot, 'expo', error.response.data);
                }
                if (body) {
                    if (body.message) {
                        internal_1.ProjectUtils.logError(projectRoot, 'expo', body.message);
                    }
                    else {
                        internal_1.ProjectUtils.logError(projectRoot, 'expo', error.response.data);
                    }
                }
            }
            throw new internal_1.XDLError(errorCode, `Packager URL ${fullUrl} returned unexpected code ${error.response.status}. ` +
                'Please open your project in the Expo app and see if there are any errors. ' +
                'Also scroll up and make sure there were no errors or warnings when opening your project.');
        }
        else {
            throw error;
        }
    }
    if (!response.data || (minLength && response.data.length < minLength)) {
        throw new internal_1.XDLError(errorCode, `Body is: ${response.data}`);
    }
    return response.data;
}
//# sourceMappingURL=createBundlesAsync.js.map
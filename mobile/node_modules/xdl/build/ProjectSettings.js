"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const json_file_1 = __importDefault(require("@expo/json-file"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const projectSettingsFile = 'settings.json';
const projectSettingsDefaults = {
    scheme: null,
    hostType: 'lan',
    lanType: 'ip',
    devClient: false,
    dev: true,
    minify: false,
    urlRandomness: null,
    https: false,
};
const packagerInfoFile = 'packager-info.json';
function projectSettingsJsonFile(projectRoot) {
    return new json_file_1.default(path_1.default.join(dotExpoProjectDirectory(projectRoot), projectSettingsFile));
}
function packagerInfoJsonFile(projectRoot) {
    return new json_file_1.default(path_1.default.join(dotExpoProjectDirectory(projectRoot), packagerInfoFile));
}
async function readAsync(projectRoot) {
    let projectSettings;
    try {
        projectSettings = await projectSettingsJsonFile(projectRoot).readAsync();
    }
    catch (e) {
        projectSettings = await projectSettingsJsonFile(projectRoot).writeAsync(projectSettingsDefaults);
    }
    migrateDeprecatedSettings(projectSettings);
    // Set defaults for any missing fields
    return Object.assign(Object.assign({}, projectSettingsDefaults), projectSettings);
}
exports.readAsync = readAsync;
function migrateDeprecatedSettings(projectSettings) {
    if (projectSettings.hostType === 'ngrok') {
        // 'ngrok' is deprecated
        projectSettings.hostType = 'tunnel';
    }
    if (projectSettings.urlType) {
        // urlType is deprecated as a project setting
        delete projectSettings.urlType;
    }
    if ('strict' in projectSettings) {
        // strict mode is not supported at the moment
        delete projectSettings.strict;
    }
}
async function setAsync(projectRoot, json) {
    try {
        return await projectSettingsJsonFile(projectRoot).mergeAsync(json, {
            cantReadFileDefault: projectSettingsDefaults,
        });
    }
    catch (e) {
        return await projectSettingsJsonFile(projectRoot).writeAsync(Object.assign(Object.assign({}, projectSettingsDefaults), json));
    }
}
exports.setAsync = setAsync;
async function readPackagerInfoAsync(projectRoot) {
    try {
        return await packagerInfoJsonFile(projectRoot).readAsync({
            cantReadFileDefault: {},
        });
    }
    catch (e) {
        return await packagerInfoJsonFile(projectRoot).writeAsync({});
    }
}
exports.readPackagerInfoAsync = readPackagerInfoAsync;
async function getCurrentStatusAsync(projectRoot) {
    const { packagerPort, expoServerPort } = await readPackagerInfoAsync(projectRoot);
    if (packagerPort && expoServerPort) {
        return 'running';
    }
    else if (packagerPort || expoServerPort) {
        return 'ill';
    }
    else {
        return 'exited';
    }
}
exports.getCurrentStatusAsync = getCurrentStatusAsync;
async function setPackagerInfoAsync(projectRoot, json) {
    try {
        return await packagerInfoJsonFile(projectRoot).mergeAsync(json, {
            cantReadFileDefault: {},
        });
    }
    catch (e) {
        return await packagerInfoJsonFile(projectRoot).writeAsync(json);
    }
}
exports.setPackagerInfoAsync = setPackagerInfoAsync;
function dotExpoProjectDirectory(projectRoot) {
    const dirPath = path_1.default.join(projectRoot, '.expo');
    try {
        // move .exponent to .expo
        const oldDirPath = path_1.default.join(projectRoot, '.exponent');
        if (fs_extra_1.default.statSync(oldDirPath).isDirectory()) {
            fs_extra_1.default.renameSync(oldDirPath, dirPath);
        }
    }
    catch (e) {
        // no old directory, continue
    }
    fs_extra_1.default.mkdirpSync(dirPath);
    const readmeFilePath = path_1.default.resolve(dirPath, 'README.md');
    if (!fs_extra_1.default.existsSync(readmeFilePath)) {
        fs_extra_1.default.writeFileSync(readmeFilePath, `> Why do I have a folder named ".expo" in my project?

The ".expo" folder is created when an Expo project is started using "expo start" command.

> What does the "packager-info.json" file contain?

The "packager-info.json" file contains port numbers and process PIDs that are used to serve the application to the mobile device/simulator.

> What does the "settings.json" file contain?

The "settings.json" file contains the server configuration that is used to serve the application manifest.

> Should I commit the ".expo" folder?

No, you should not share the ".expo" folder. It does not contain any information that is relevant for other developers working on the project, it is specific to your machine.

Upon project creation, the ".expo" folder is already added to your ".gitignore" file.
`);
    }
    return dirPath;
}
exports.dotExpoProjectDirectory = dotExpoProjectDirectory;
function dotExpoProjectDirectoryExists(projectRoot) {
    const dirPath = path_1.default.join(projectRoot, '.expo');
    try {
        if (fs_extra_1.default.statSync(dirPath).isDirectory()) {
            return true;
        }
    }
    catch (e) {
        // file doesn't exist
    }
    return false;
}
exports.dotExpoProjectDirectoryExists = dotExpoProjectDirectoryExists;
async function getPackagerOptsAsync(projectRoot) {
    const projectSettings = await readAsync(projectRoot);
    return projectSettings;
}
exports.getPackagerOptsAsync = getPackagerOptsAsync;
//# sourceMappingURL=ProjectSettings.js.map
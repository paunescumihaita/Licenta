"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const osascript = __importStar(require("@expo/osascript"));
const spawn_async_1 = __importDefault(require("@expo/spawn-async"));
const chalk_1 = __importDefault(require("chalk"));
const path_1 = __importDefault(require("path"));
const internal_1 = require("./internal");
async function isSimulatorRunningAsync() {
    try {
        const zeroMeansNo = (await osascript.execAsync('tell app "System Events" to count processes whose name is "Simulator"')).trim();
        if (zeroMeansNo === '0') {
            return false;
        }
    }
    catch (_a) {
        return false;
    }
    return true;
}
exports.isSimulatorRunningAsync = isSimulatorRunningAsync;
async function getDefaultSimulatorDeviceUDIDAsync() {
    try {
        const { stdout: defaultDeviceUDID } = await spawn_async_1.default('defaults', [
            'read',
            'com.apple.iphonesimulator',
            'CurrentDeviceUDID',
        ]);
        return defaultDeviceUDID.trim();
    }
    catch (e) {
        return null;
    }
}
exports.getDefaultSimulatorDeviceUDIDAsync = getDefaultSimulatorDeviceUDIDAsync;
/**
 * Returns the local path for the installed tar.app. Returns null when the app isn't installed.
 *
 * @param udid
 * @param bundleIdentifier
 */
async function getContainerPathAsync(udid, bundleIdentifier) {
    var _a;
    try {
        const { stdout } = await xcrunAsync([
            'simctl',
            'get_app_container',
            deviceUDIDOrBooted(udid),
            bundleIdentifier,
        ]);
        return stdout.trim();
    }
    catch (error) {
        if ((_a = error.stderr) === null || _a === void 0 ? void 0 : _a.match(/No such file or directory/)) {
            return null;
        }
        throw error;
    }
}
exports.getContainerPathAsync = getContainerPathAsync;
async function openURLAsync(options) {
    return simctlAsync(['openurl', deviceUDIDOrBooted(options.udid), options.url]);
}
exports.openURLAsync = openURLAsync;
async function openBundleIdAsync(options) {
    return simctlAsync(['launch', deviceUDIDOrBooted(options.udid), options.bundleIdentifier]);
}
exports.openBundleIdAsync = openBundleIdAsync;
// This will only boot in headless mode if the Simulator app is not running.
async function bootAsync({ udid }) {
    var _a;
    try {
        // Skip logging since this is likely to fail.
        await xcrunAsync(['simctl', 'boot', udid]);
    }
    catch (error) {
        if (!((_a = error.stderr) === null || _a === void 0 ? void 0 : _a.match(/Unable to boot device in current state: Booted/))) {
            throw error;
        }
    }
    return await isSimulatorBootedAsync({ udid });
}
exports.bootAsync = bootAsync;
async function getBootedSimulatorsAsync() {
    const simulatorDeviceInfo = await listAsync('devices');
    return Object.values(simulatorDeviceInfo.devices).reduce((prev, runtime) => {
        return prev.concat(runtime.filter(device => device.state === 'Booted'));
    }, []);
}
exports.getBootedSimulatorsAsync = getBootedSimulatorsAsync;
async function isSimulatorBootedAsync({ udid, }) {
    var _a, _b;
    // Simulators can be booted even if the app isn't running :(
    const devices = await getBootedSimulatorsAsync();
    if (udid) {
        return (_a = devices.find(bootedDevice => bootedDevice.udid === udid)) !== null && _a !== void 0 ? _a : null;
    }
    else {
        return (_b = devices[0]) !== null && _b !== void 0 ? _b : null;
    }
}
exports.isSimulatorBootedAsync = isSimulatorBootedAsync;
async function installAsync(options) {
    return simctlAsync(['install', deviceUDIDOrBooted(options.udid), options.dir]);
}
exports.installAsync = installAsync;
async function uninstallAsync(options) {
    return simctlAsync(['uninstall', deviceUDIDOrBooted(options.udid), options.bundleIdentifier]);
}
exports.uninstallAsync = uninstallAsync;
function parseSimControlJSONResults(input) {
    try {
        return JSON.parse(input);
    }
    catch (error) {
        // Nov 15, 2020: Observed this can happen when opening the simulator and the simulator prompts the user to update the XC command line tools.
        // Unexpected token I in JSON at position 0
        if (error.message.match('Unexpected token')) {
            internal_1.Logger.global.error(`Apple's simctl returned malformed JSON:\n${input}`);
        }
        throw error;
    }
}
// TODO: Compare with
// const results = await SimControl.xcrunAsync(['instruments', '-s']);
async function listAsync(type, query) {
    const result = await simctlAsync(['list', type, '--json', query]);
    const info = parseSimControlJSONResults(result.stdout);
    for (const runtime of Object.keys(info.devices)) {
        // Given a string like 'com.apple.CoreSimulator.SimRuntime.tvOS-13-4'
        const runtimeSuffix = runtime.split('com.apple.CoreSimulator.SimRuntime.').pop();
        // Create an array [tvOS, 13, 4]
        const [osType, ...osVersionComponents] = runtimeSuffix.split('-');
        // Join the end components [13, 4] -> '13.4'
        const osVersion = osVersionComponents.join('.');
        const sims = info.devices[runtime];
        for (const device of sims) {
            device.runtime = runtime;
            device.osVersion = osVersion;
            device.windowName = `${device.name} (${osVersion})`;
            device.osType = osType;
        }
    }
    return info;
}
exports.listAsync = listAsync;
/**
 * Get a list of all connected devices.
 */
async function listDevicesAsync() {
    const { output } = await xcrunAsync(['xctrace', 'list', 'devices']);
    const text = output.join('');
    const devices = [];
    if (!text.includes('== Simulators ==')) {
        return [];
    }
    const lines = text.split('\n');
    for (const line of lines) {
        if (line === '== Simulators ==') {
            break;
        }
        const device = line.match(/(.*?) (\(([0-9.]+)\) )?\(([0-9A-F-]+)\)/i);
        if (device) {
            const [, name, , osVersion, udid] = device;
            const metadata = {
                name,
                udid,
                osVersion: osVersion !== null && osVersion !== void 0 ? osVersion : '??',
                deviceType: osVersion ? 'device' : 'catalyst',
            };
            devices.push(metadata);
        }
    }
    return devices;
}
exports.listDevicesAsync = listDevicesAsync;
async function shutdownAsync(udid) {
    var _a;
    try {
        return simctlAsync(['shutdown', deviceUDIDOrBooted(udid)]);
    }
    catch (e) {
        if (!((_a = e.message) === null || _a === void 0 ? void 0 : _a.includes('No devices are booted.'))) {
            throw e;
        }
    }
    return null;
}
exports.shutdownAsync = shutdownAsync;
// Some permission changes will terminate the application if running
async function updatePermissionsAsync(udid, action, permission, bundleIdentifier) {
    return simctlAsync(['privacy', deviceUDIDOrBooted(udid), action, permission, bundleIdentifier]);
}
exports.updatePermissionsAsync = updatePermissionsAsync;
async function setAppearanceAsync(udid, theme) {
    return simctlAsync(['ui', deviceUDIDOrBooted(udid), theme]);
}
exports.setAppearanceAsync = setAppearanceAsync;
// Cannot be invoked unless the simulator is `shutdown`
async function eraseAsync(udid) {
    return simctlAsync(['erase', deviceUDIDOrBooted(udid)]);
}
exports.eraseAsync = eraseAsync;
async function eraseAllAsync() {
    return simctlAsync(['erase', 'all']);
}
exports.eraseAllAsync = eraseAllAsync;
// Add photos and videos to the simulator's gallery
async function addMediaAsync(udid, mediaPath) {
    return simctlAsync(['addmedia', deviceUDIDOrBooted(udid), mediaPath]);
}
exports.addMediaAsync = addMediaAsync;
async function captureScreenAsync(udid, captureType, outputFilePath) {
    return simctlAsync([
        'io',
        deviceUDIDOrBooted(udid),
        captureType,
        `—type=${path_1.default.extname(outputFilePath)}`,
        outputFilePath,
    ]);
}
exports.captureScreenAsync = captureScreenAsync;
// Clear all unused simulators
async function deleteUnavailableAsync() {
    return simctlAsync(['delete', 'unavailable']);
}
exports.deleteUnavailableAsync = deleteUnavailableAsync;
async function simctlAsync([command, ...args], options) {
    return xcrunWithLogging(
    // @ts-ignore
    ['simctl', command, ...args.filter(Boolean)], options);
}
exports.simctlAsync = simctlAsync;
function deviceUDIDOrBooted(udid) {
    return udid ? udid : 'booted';
}
/**
 * I think the app can be open while no simulators are booted.
 */
async function isSimulatorAppRunningAsync() {
    try {
        const zeroMeansNo = (await osascript.execAsync('tell app "System Events" to count processes whose name is "Simulator"')).trim();
        if (zeroMeansNo === '0') {
            return false;
        }
    }
    catch (error) {
        if (error.message.includes('Application isn’t running')) {
            return false;
        }
        throw error;
    }
    return true;
}
exports.isSimulatorAppRunningAsync = isSimulatorAppRunningAsync;
async function openSimulatorAppAsync({ udid }) {
    const args = ['-a', 'Simulator'];
    if (udid) {
        // This has no effect if the app is already running.
        args.push('--args', '-CurrentDeviceUDID', udid);
    }
    return await spawn_async_1.default('open', args);
}
exports.openSimulatorAppAsync = openSimulatorAppAsync;
async function killAllAsync() {
    return await spawn_async_1.default('killAll', ['Simulator']);
}
exports.killAllAsync = killAllAsync;
function isLicenseOutOfDate(text) {
    if (!text) {
        return false;
    }
    const lower = text.toLowerCase();
    return lower.includes('xcode') && lower.includes('license');
}
exports.isLicenseOutOfDate = isLicenseOutOfDate;
async function isXcrunInstalledAsync() {
    try {
        await spawn_async_1.default('xcrun', ['--version']);
        return true;
    }
    catch (error) {
        return false;
    }
}
exports.isXcrunInstalledAsync = isXcrunInstalledAsync;
async function xcrunAsync(args, options) {
    var _a;
    try {
        return await spawn_async_1.default('xcrun', args, options);
    }
    catch (e) {
        if (isLicenseOutOfDate(e.stdout) || isLicenseOutOfDate(e.stderr)) {
            throw new internal_1.XDLError('XCODE_LICENSE_NOT_ACCEPTED', 'Xcode license is not accepted. Please run `sudo xcodebuild -license`.');
        }
        else if ((_a = e.stderr) === null || _a === void 0 ? void 0 : _a.includes('not a developer tool or in PATH')) {
            throw new internal_1.XDLError('SIMCTL_NOT_AVAILABLE', `You may need to run ${chalk_1.default.bold('sudo xcode-select -s /Applications/Xcode.app')} and try again.`);
        }
        throw e;
    }
}
exports.xcrunAsync = xcrunAsync;
async function xcrunWithLogging(args, options) {
    try {
        return await xcrunAsync(args, options);
    }
    catch (e) {
        internal_1.Logger.global.error(`Error running \`xcrun ${args.join(' ')}\`: ${e.stderr || e.message}`);
        throw e;
    }
}
exports.xcrunWithLogging = xcrunWithLogging;
//# sourceMappingURL=SimControl.js.map
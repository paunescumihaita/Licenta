"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * BundleIdentifier.ts
 *
 * NOTE:
 * The code in this module originates from eas-cli and the canonical version of
 * it is in
 * https://github.com/expo/eas-cli/blob/6a0a9bbaaad03b053b5930f7d14bde35b4d0a9f0/packages/eas-cli/src/build/ios/bundleIdentifer.ts#L36
 * Any changes to this code should be applied to eas-cli as well!
 *
 * TODO: move the code for configuring and validating the bundle identifier
 * to a shared package that can be used for both eas-cli and expo-cli.
 */
const config_1 = require("@expo/config");
const config_plugins_1 = require("@expo/config-plugins");
const json_file_1 = __importDefault(require("@expo/json-file"));
const assert_1 = __importDefault(require("assert"));
const chalk_1 = __importDefault(require("chalk"));
const prompts_1 = require("prompts");
const internal_1 = require("./internal");
const { logInfo, logWarning } = internal_1.ProjectUtils;
var BundleIdentiferSource;
(function (BundleIdentiferSource) {
    BundleIdentiferSource[BundleIdentiferSource["XcodeProject"] = 0] = "XcodeProject";
    BundleIdentiferSource[BundleIdentiferSource["AppJson"] = 1] = "AppJson";
})(BundleIdentiferSource || (BundleIdentiferSource = {}));
async function configureBundleIdentifierAsync(projectRoot, exp) {
    const configDescription = config_1.getProjectConfigDescription(projectRoot);
    const bundleIdentifierFromPbxproj = config_plugins_1.IOSConfig.BundleIdentifier.getBundleIdentifierFromPbxproj(projectRoot);
    const bundleIdentifierFromConfig = config_plugins_1.IOSConfig.BundleIdentifier.getBundleIdentifier(exp);
    if (bundleIdentifierFromPbxproj && bundleIdentifierFromConfig) {
        if (bundleIdentifierFromPbxproj === bundleIdentifierFromConfig) {
            return bundleIdentifierFromConfig;
        }
        else {
            logWarning(projectRoot, 'expo', `We detected that your Xcode project is configured with a different bundle identifier than the one defined in ${configDescription}.`);
            const hasBundleIdentifierInStaticConfig = await hasBundleIdentifierInStaticConfigAsync(projectRoot, exp);
            if (!hasBundleIdentifierInStaticConfig) {
                logInfo(projectRoot, 'expo', `If you choose the one defined in ${configDescription} we'll automatically configure your Xcode project with it.
However, if you choose the one defined in the Xcode project you'll have to update ${configDescription} on your own.`);
            }
            const { bundleIdentifierSource } = await prompts_1.prompt({
                type: 'select',
                name: 'bundleIdentifierSource',
                message: 'Which bundle identifier should we use?',
                choices: [
                    {
                        title: `${chalk_1.default.bold(bundleIdentifierFromPbxproj)} - In Xcode project`,
                        value: BundleIdentiferSource.XcodeProject,
                    },
                    {
                        title: `${chalk_1.default.bold(bundleIdentifierFromConfig)} - In your ${configDescription}`,
                        value: BundleIdentiferSource.AppJson,
                    },
                ],
            });
            if (bundleIdentifierSource === BundleIdentiferSource.XcodeProject) {
                config_plugins_1.IOSConfig.BundleIdentifier.setBundleIdentifierForPbxproj(projectRoot, bundleIdentifierFromConfig);
                return bundleIdentifierFromConfig;
            }
            else {
                if (hasBundleIdentifierInStaticConfig) {
                    await updateAppJsonConfigAsync(projectRoot, exp, bundleIdentifierFromPbxproj);
                }
                else {
                    throw new Error(missingBundleIdentifierMessage(configDescription));
                }
                return bundleIdentifierFromPbxproj;
            }
        }
    }
    else if (bundleIdentifierFromPbxproj && !bundleIdentifierFromConfig) {
        if (config_1.getConfigFilePaths(projectRoot).staticConfigPath) {
            await updateAppJsonConfigAsync(projectRoot, exp, bundleIdentifierFromPbxproj);
            return bundleIdentifierFromPbxproj;
        }
        else {
            throw new Error(missingBundleIdentifierMessage(configDescription));
        }
    }
    else if (!bundleIdentifierFromPbxproj && bundleIdentifierFromConfig) {
        config_plugins_1.IOSConfig.BundleIdentifier.setBundleIdentifierForPbxproj(projectRoot, bundleIdentifierFromConfig);
        return bundleIdentifierFromConfig;
    }
    else {
        throw new Error(missingBundleIdentifierMessage(configDescription));
    }
}
exports.configureBundleIdentifierAsync = configureBundleIdentifierAsync;
function missingBundleIdentifierMessage(configDescription) {
    return `Please define "ios.bundleIdentifier" in ${configDescription}.`;
}
async function updateAppJsonConfigAsync(projectRoot, exp, newBundleIdentifier) {
    var _a;
    const paths = config_1.getConfigFilePaths(projectRoot);
    assert_1.default(paths.staticConfigPath, "Can't update dynamic configs");
    const rawStaticConfig = (await json_file_1.default.readAsync(paths.staticConfigPath));
    rawStaticConfig.expo = Object.assign(Object.assign({}, rawStaticConfig.expo), { ios: Object.assign(Object.assign({}, (_a = rawStaticConfig.expo) === null || _a === void 0 ? void 0 : _a.ios), { bundleIdentifier: newBundleIdentifier }) });
    await json_file_1.default.writeAsync(paths.staticConfigPath, rawStaticConfig);
    exp.ios = Object.assign(Object.assign({}, exp.ios), { bundleIdentifier: newBundleIdentifier });
}
/**
 * Check if static config exists and if ios.bundleIdentifier is defined there.
 * It will return false if the value in static config is different than "ios.bundleIdentifier" in ExpoConfig
 */
async function hasBundleIdentifierInStaticConfigAsync(projectRoot, exp) {
    var _a, _b, _c;
    if (!((_a = exp.ios) === null || _a === void 0 ? void 0 : _a.bundleIdentifier)) {
        return false;
    }
    const paths = config_1.getConfigFilePaths(projectRoot);
    if (!paths.staticConfigPath) {
        return false;
    }
    const rawStaticConfig = json_file_1.default.read(paths.staticConfigPath);
    return ((_c = (_b = rawStaticConfig === null || rawStaticConfig === void 0 ? void 0 : rawStaticConfig.expo) === null || _b === void 0 ? void 0 : _b.ios) === null || _c === void 0 ? void 0 : _c.bundleIdentifier) === exp.ios.bundleIdentifier;
}
//# sourceMappingURL=BundleIdentifier.js.map
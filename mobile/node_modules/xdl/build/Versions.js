"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const getenv_1 = __importDefault(require("getenv"));
const pickBy_1 = __importDefault(require("lodash/pickBy"));
const path_1 = __importDefault(require("path"));
const semver_1 = __importDefault(require("semver"));
const internal_1 = require("./internal");
async function versionsAsync(options) {
    const api = new internal_1.ApiV2();
    const versionCache = new internal_1.FsCache.Cacher(() => api.getAsync('versions/latest'), 'versions.json', 0, path_1.default.join(__dirname, '../caches/versions.json'));
    // Clear cache when opting in to beta because things can change quickly in beta
    if (getenv_1.default.boolish('EXPO_BETA', false) || (options === null || options === void 0 ? void 0 : options.skipCache)) {
        versionCache.clearAsync();
    }
    return await versionCache.getAsync();
}
exports.versionsAsync = versionsAsync;
async function sdkVersionsAsync() {
    const { sdkVersions } = await versionsAsync();
    return sdkVersions;
}
exports.sdkVersionsAsync = sdkVersionsAsync;
async function setVersionsAsync(value) {
    const user = await internal_1.UserManager.getCurrentUserAsync();
    const api = internal_1.ApiV2.clientForUser(user);
    const secret = process.env.EXPO_VERSIONS_SECRET;
    if (!secret)
        throw new Error('Versions.setVersionsAsync: EXPO_VERSIONS_SECRET environment variable is required');
    await api.postAsync('versions/update', {
        value: value,
        secret,
    });
}
exports.setVersionsAsync = setVersionsAsync;
// NOTE(brentvatne): it is possible for an unreleased version to be published to
// the versions endpoint, but in some cases we only want to list out released
// versions
async function releasedSdkVersionsAsync() {
    const sdkVersions = await sdkVersionsAsync();
    return pickBy_1.default(sdkVersions, (data, _sdkVersionString) => !!data.releaseNoteUrl || (getenv_1.default.boolish('EXPO_BETA', false) && data.beta));
}
exports.releasedSdkVersionsAsync = releasedSdkVersionsAsync;
function gteSdkVersion(expJson, sdkVersion) {
    if (!expJson.sdkVersion) {
        return false;
    }
    if (expJson.sdkVersion === 'UNVERSIONED') {
        return true;
    }
    try {
        return semver_1.default.gte(expJson.sdkVersion, sdkVersion);
    }
    catch (e) {
        throw new internal_1.XDLError('INVALID_VERSION', `${expJson.sdkVersion} is not a valid version. Must be in the form of x.y.z`);
    }
}
exports.gteSdkVersion = gteSdkVersion;
function lteSdkVersion(expJson, sdkVersion) {
    if (!expJson.sdkVersion) {
        return false;
    }
    if (expJson.sdkVersion === 'UNVERSIONED') {
        return false;
    }
    try {
        return semver_1.default.lte(expJson.sdkVersion, sdkVersion);
    }
    catch (e) {
        throw new internal_1.XDLError('INVALID_VERSION', `${expJson.sdkVersion} is not a valid version. Must be in the form of x.y.z`);
    }
}
exports.lteSdkVersion = lteSdkVersion;
function parseSdkVersionFromTag(tag) {
    if (tag.startsWith('sdk-')) {
        return tag.substring(4);
    }
    return tag;
}
exports.parseSdkVersionFromTag = parseSdkVersionFromTag;
// NOTE(brentvatne): it is possible for an unreleased version to be published to
// the versions endpoint, but in some cases we need to get the latest *released*
// version, not just the latest version.
async function newestReleasedSdkVersionAsync() {
    const betaOptInEnabled = getenv_1.default.boolish('EXPO_BETA', false);
    const sdkVersions = await sdkVersionsAsync();
    let result = null;
    let highestMajorVersion = '0.0.0';
    for (const [version, data] of Object.entries(sdkVersions)) {
        const hasReleaseNotes = !!data.releaseNoteUrl;
        const isBeta = !!data.beta;
        if (semver_1.default.major(version) > semver_1.default.major(highestMajorVersion) &&
            (hasReleaseNotes || (isBeta && betaOptInEnabled))) {
            highestMajorVersion = version;
            result = data;
        }
    }
    return {
        version: highestMajorVersion,
        data: result,
    };
}
exports.newestReleasedSdkVersionAsync = newestReleasedSdkVersionAsync;
/**
 * Be careful when using this! It can include unreleased and beta SDK versions.
 */
async function newestSdkVersionAsync() {
    const sdkVersions = await sdkVersionsAsync();
    let result = null;
    let highestMajorVersion = '0.0.0';
    for (const [version, data] of Object.entries(sdkVersions)) {
        if (semver_1.default.major(version) > semver_1.default.major(highestMajorVersion)) {
            highestMajorVersion = version;
            result = data;
        }
    }
    return {
        version: highestMajorVersion,
        data: result,
    };
}
exports.newestSdkVersionAsync = newestSdkVersionAsync;
async function oldestSupportedMajorVersionAsync() {
    const sdkVersions = await sdkVersionsAsync();
    const supportedVersions = pickBy_1.default(sdkVersions, v => !v.isDeprecated);
    const versionNumbers = Object.keys(supportedVersions).map(version => semver_1.default.major(version));
    return Math.min(...versionNumbers);
}
exports.oldestSupportedMajorVersionAsync = oldestSupportedMajorVersionAsync;
async function facebookReactNativeVersionsAsync() {
    const sdkVersions = await sdkVersionsAsync();
    const facebookReactNativeVersions = new Set(Object.values(sdkVersions)
        .map(data => data.facebookReactNativeVersion)
        .filter(version => version));
    return Array.from(facebookReactNativeVersions);
}
exports.facebookReactNativeVersionsAsync = facebookReactNativeVersionsAsync;
async function facebookReactNativeVersionToExpoVersionAsync(outerFacebookReactNativeVersion) {
    if (!semver_1.default.valid(outerFacebookReactNativeVersion)) {
        throw new internal_1.XDLError('INVALID_VERSION', `${outerFacebookReactNativeVersion} is not a valid version. Must be in the form of x.y.z`);
    }
    const sdkVersions = await releasedSdkVersionsAsync();
    let currentSdkVersion = null;
    for (const [version, { facebookReactNativeVersion }] of Object.entries(sdkVersions)) {
        if (semver_1.default.major(outerFacebookReactNativeVersion) === semver_1.default.major(facebookReactNativeVersion) &&
            semver_1.default.minor(outerFacebookReactNativeVersion) === semver_1.default.minor(facebookReactNativeVersion) &&
            (!currentSdkVersion || semver_1.default.gt(version, currentSdkVersion))) {
            currentSdkVersion = version;
        }
    }
    return currentSdkVersion;
}
exports.facebookReactNativeVersionToExpoVersionAsync = facebookReactNativeVersionToExpoVersionAsync;
async function canTurtleBuildSdkVersion(sdkVersion, platform) {
    var _a;
    if (sdkVersion === 'UNVERSIONED') {
        return true;
    }
    if (semver_1.default.valid(sdkVersion) == null) {
        throw new internal_1.XDLError('INVALID_VERSION', `"${sdkVersion}" is not a valid version. Must be in the form of x.y.z`);
    }
    const supportedVersions = await getSdkVersionsSupportedByTurtle();
    const supportedVersionsForPlatform = (_a = supportedVersions[platform]) !== null && _a !== void 0 ? _a : [];
    return supportedVersionsForPlatform.indexOf(sdkVersion) !== -1;
}
exports.canTurtleBuildSdkVersion = canTurtleBuildSdkVersion;
async function getSdkVersionsSupportedByTurtle() {
    const api = new internal_1.ApiV2();
    return await api.getAsync('standalone-build/supportedSDKVersions');
}
//# sourceMappingURL=Versions.js.map
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runAndroidActionAsync = runAndroidActionAsync;

function _configPlugins() {
  const data = require("@expo/config-plugins");

  _configPlugins = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _fs() {
  const data = _interopRequireDefault(require("fs"));

  _fs = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _xdl() {
  const data = require("xdl");

  _xdl = function () {
    return data;
  };

  return data;
}

function _CommandError() {
  const data = _interopRequireDefault(require("../../../CommandError"));

  _CommandError = function () {
    return data;
  };

  return data;
}

function _log() {
  const data = _interopRequireDefault(require("../../../log"));

  _log = function () {
    return data;
  };

  return data;
}

function _prebuildAsync() {
  const data = require("../../eject/prebuildAsync");

  _prebuildAsync = function () {
    return data;
  };

  return data;
}

function _startBundlerAsync() {
  const data = require("../ios/startBundlerAsync");

  _startBundlerAsync = function () {
    return data;
  };

  return data;
}

function _resolvePortAsync() {
  const data = require("../utils/resolvePortAsync");

  _resolvePortAsync = function () {
    return data;
  };

  return data;
}

function _resolveDeviceAsync() {
  const data = require("./resolveDeviceAsync");

  _resolveDeviceAsync = function () {
    return data;
  };

  return data;
}

function _spawnGradleAsync() {
  const data = require("./spawnGradleAsync");

  _spawnGradleAsync = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function resolveAndroidProjectPathAsync(projectRoot) {
  try {
    return await _configPlugins().AndroidConfig.Paths.getProjectPathOrThrowAsync(projectRoot);
  } catch (_unused) {
    // If the project doesn't have native code, prebuild it...
    await (0, _prebuildAsync().prebuildAsync)(projectRoot, {
      install: true,
      platforms: ['android']
    });
    return await _configPlugins().AndroidConfig.Paths.getProjectPathOrThrowAsync(projectRoot);
  }
}

async function resolveOptionsAsync(projectRoot, options) {
  if (typeof options.variant !== 'string') {
    throw new (_CommandError().default)('--variant must be a string');
  }

  const device = await (0, _resolveDeviceAsync().resolveDeviceAsync)(options.device);

  if (!device) {
    throw new (_CommandError().default)('Cannot resolve an Android device');
  }

  const filePath = await _configPlugins().AndroidConfig.Paths.getAndroidManifestAsync(projectRoot);
  const androidManifest = await _configPlugins().AndroidConfig.Manifest.readAndroidManifestAsync(filePath); // Assert MainActivity defined.

  await _configPlugins().AndroidConfig.Manifest.getMainActivityOrThrow(androidManifest);
  const mainActivity = 'MainActivity';
  const packageName = androidManifest.manifest.$.package;

  if (!packageName) {
    throw new (_CommandError().default)(`Could not find package name in AndroidManifest.xml at "${filePath}"`);
  }

  let port = await (0, _resolvePortAsync().resolvePortAsync)(projectRoot, options.port);
  options.bundler = !!port;

  if (!port) {
    // Skip bundling if the port is null
    // any random number
    port = 8081;
  }

  const variant = options.variant.toLowerCase();

  const apkDirectory = _xdl().Android.getAPKDirectory(projectRoot);

  const apkVariantDirectory = _path().default.join(apkDirectory, variant);

  return { ...options,
    port,
    device,
    mainActivity,
    packageName,
    apkVariantDirectory,
    variantFolder: variant,
    appName: 'app'
  };
}

async function runAndroidActionAsync(projectRoot, options) {
  const props = await resolveOptionsAsync(projectRoot, options);

  _log().default.log('\u203A Building app...');

  const androidProjectPath = await resolveAndroidProjectPathAsync(projectRoot);
  await (0, _spawnGradleAsync().spawnGradleAsync)({
    androidProjectPath,
    variant: options.variant
  });

  if (props.bundler) {
    await (0, _startBundlerAsync().startBundlerAsync)(projectRoot);
  }

  const apkFile = await getInstallApkNameAsync(props.device, props);

  _log().default.debug(`\u203A Installing: ${apkFile}`);

  const binaryPath = _path().default.join(props.apkVariantDirectory, apkFile);

  await _xdl().Android.installOnDeviceAsync(props.device, {
    binaryPath
  }); // For now, just open the app with a matching package name

  await _xdl().Android.openAppAsync(props.device, props);

  if (props.bundler) {
    // TODO: unify logs
    _log().default.nested(`\nLogs for your project will appear in the browser console. ${_chalk().default.dim(`Press Ctrl+C to exit.`)}`);
  }
}

async function getInstallApkNameAsync(device, {
  appName,
  variantFolder,
  apkVariantDirectory
}) {
  const availableCPUs = await _xdl().Android.getDeviceABIsAsync(device);
  availableCPUs.push(_xdl().Android.DeviceABI.universal);

  _log().default.debug('Supported ABIs: ' + availableCPUs.join(', '));

  _log().default.debug('Searching for APK: ' + apkVariantDirectory); // Check for cpu specific builds first


  for (const availableCPU of availableCPUs) {
    const apkName = `${appName}-${availableCPU}-${variantFolder}.apk`;

    if (_fs().default.existsSync(_path().default.join(apkVariantDirectory, apkName))) {
      return apkName;
    }
  } // Otherwise use the default apk named after the variant: app-debug.apk


  const apkName = `${appName}-${variantFolder}.apk`;

  if (_fs().default.existsSync(_path().default.join(apkVariantDirectory, apkName))) {
    return apkName;
  }

  throw new (_CommandError().default)(`Failed to resolve APK build file in folder "${apkVariantDirectory}"`);
}
//# sourceMappingURL=runAndroid.js.map
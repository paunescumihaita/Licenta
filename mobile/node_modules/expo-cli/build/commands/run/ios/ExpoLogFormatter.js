"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExpoLogFormatter = void 0;

function _xcpretty() {
  const data = require("@expo/xcpretty");

  _xcpretty = function () {
    return data;
  };

  return data;
}

function _switchRegex() {
  const data = require("@expo/xcpretty/build/switchRegex");

  _switchRegex = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _log() {
  const data = _interopRequireDefault(require("../../../log"));

  _log = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const ERROR = '❌ ';

function moduleNameFromPath(modulePath) {
  if (modulePath.startsWith('@')) {
    const [org, packageName] = modulePath.split('/');

    if (org && packageName) {
      return [org, packageName].join('/');
    }

    return modulePath;
  }

  const [packageName] = modulePath.split('/');
  return packageName ? packageName : modulePath;
}

function getNodeModuleName(filePath) {
  // '/Users/evanbacon/Documents/GitHub/lab/yolo5/node_modules/react-native-reanimated/ios/Nodes/REACallFuncNode.m'
  const [, modulePath] = filePath.split('/node_modules/');

  if (modulePath) {
    return moduleNameFromPath(modulePath);
  }

  return null;
}

class CustomParser extends _xcpretty().Parser {
  constructor(formatter) {
    super(formatter);
    this.formatter = formatter;

    _defineProperty(this, "isCollectingMetroError", false);

    _defineProperty(this, "metroError", []);
  }

  parse(text) {
    const results = this.checkMetroError(text);

    if (results) {
      return results;
    }

    return super.parse(text);
  } // Error for the build script wrapper in expo-updates that catches metro bundler errors.
  // This can be repro'd by importing a file that doesn't exist, then building.
  // Metro will fail to generate the JS bundle, and throw an error that should be caught here.


  checkMetroError(text) {
    // In expo-updates, we wrap the bundler script and add regex around the error message so we can present it nicely to the user.
    return (0, _switchRegex().switchRegex)(text, [[/@build-script-error-begin/m, () => {
      this.isCollectingMetroError = true;
    }], [/@build-script-error-end/m, () => {
      const results = this.metroError.join('\n'); // Reset the metro collection error array (should never need this).

      this.isCollectingMetroError = false;
      this.metroError = [];
      return this.formatter.formatMetroAssetCollectionError(results);
    }], [null, () => {
      // Collect all the lines in the metro build error
      if (this.isCollectingMetroError) {
        let results = text;

        if (!this.metroError.length) {
          const match = text.match(/Error loading assets JSON from Metro.*steps correctly.((.|\n)*)/m);

          if (match && match[1]) {
            results = match[1].trim();
          }
        }

        this.metroError.push(results);
      }
    }]]);
  }

}

class ExpoLogFormatter extends _xcpretty().Formatter {
  constructor(props) {
    super(props);
    this.parser = new CustomParser(this);
  }

  formatMetroAssetCollectionError(errorContents) {
    const results = `\n${_chalk().default.red(ERROR + // Provide proper attribution.
    'Metro encountered an error:\n' + errorContents)}\n`;
    this.errors.push(results);
    return results;
  }

  shouldShowCompileWarning(filePath, lineNumber, columnNumber) {
    if (_log().default.isDebug) return true;
    return !filePath.match(/node_modules/) && !filePath.match(/\/ios\/Pods\//);
  }

  formatCompile(fileName, filePath) {
    const moduleName = getNodeModuleName(filePath);
    const moduleNameTag = moduleName ? _chalk().default.dim(`(${moduleName})`) : undefined;
    return ['\u203A', _chalk().default.bold('Compiling'), fileName, moduleNameTag].filter(Boolean).join(' ');
  }

  finish() {
    _log().default.log(`\n\u203A ${this.errors.length} error(s), and ${this.warnings.length} warning(s)\n`);
  }

}

exports.ExpoLogFormatter = ExpoLogFormatter;
//# sourceMappingURL=ExpoLogFormatter.js.map
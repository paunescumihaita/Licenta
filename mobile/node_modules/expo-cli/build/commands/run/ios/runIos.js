"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runIosActionAsync = runIosActionAsync;

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _xdl() {
  const data = require("xdl");

  _xdl = function () {
    return data;
  };

  return data;
}

function _CommandError() {
  const data = _interopRequireDefault(require("../../../CommandError"));

  _CommandError = function () {
    return data;
  };

  return data;
}

function _log() {
  const data = _interopRequireDefault(require("../../../log"));

  _log = function () {
    return data;
  };

  return data;
}

function _prebuildAsync() {
  const data = require("../../eject/prebuildAsync");

  _prebuildAsync = function () {
    return data;
  };

  return data;
}

function _profileMethod() {
  const data = require("../../utils/profileMethod");

  _profileMethod = function () {
    return data;
  };

  return data;
}

function _binaryPlist() {
  const data = require("../utils/binaryPlist");

  _binaryPlist = function () {
    return data;
  };

  return data;
}

function IOSDeploy() {
  const data = _interopRequireWildcard(require("./IOSDeploy"));

  IOSDeploy = function () {
    return data;
  };

  return data;
}

function _Podfile() {
  const data = _interopRequireDefault(require("./Podfile"));

  _Podfile = function () {
    return data;
  };

  return data;
}

function XcodeBuild() {
  const data = _interopRequireWildcard(require("./XcodeBuild"));

  XcodeBuild = function () {
    return data;
  };

  return data;
}

function _resolveOptionsAsync() {
  const data = require("./resolveOptionsAsync");

  _resolveOptionsAsync = function () {
    return data;
  };

  return data;
}

function _startBundlerAsync() {
  const data = require("./startBundlerAsync");

  _startBundlerAsync = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const isMac = process.platform === 'darwin';

async function runIosActionAsync(projectRoot, options) {
  if (!isMac) {
    // TODO: Prompt to use EAS?
    _log().default.warn(`iOS apps can only be built on macOS devices. Use ${_chalk().default.cyan`eas build -p ios`} to build in the cloud.`);

    return;
  } // If the project doesn't have native code, prebuild it...


  if (!_fsExtra().default.existsSync(path().join(projectRoot, 'ios'))) {
    await (0, _prebuildAsync().prebuildAsync)(projectRoot, {
      install: true,
      platforms: ['ios']
    });
  } else {
    await (0, _Podfile().default)(projectRoot); // TODO: Ensure the pods are in sync -- https://github.com/expo/expo/pull/11593
  }

  const props = await (0, _resolveOptionsAsync().resolveOptionsAsync)(projectRoot, options);

  if (!props.isSimulator) {
    // Assert as early as possible
    await IOSDeploy().assertInstalledAsync();
  }

  const buildOutput = await (0, _profileMethod().profileMethod)(XcodeBuild().buildAsync, 'XcodeBuild.buildAsync')(props);
  const binaryPath = await (0, _profileMethod().profileMethod)(XcodeBuild().getAppBinaryPath, 'XcodeBuild.getAppBinaryPath')(buildOutput);

  if (props.shouldStartBundler) {
    await (0, _startBundlerAsync().startBundlerAsync)(projectRoot);
  }

  const bundleIdentifier = await (0, _profileMethod().profileMethod)(getBundleIdentifierForBinaryAsync)(binaryPath);

  if (props.isSimulator) {
    XcodeBuild().logPrettyItem(`${_chalk().default.bold`Installing`} on ${props.device.name}`);
    await _xdl().SimControl.installAsync({
      udid: props.device.udid,
      dir: binaryPath
    });
    await openInSimulatorAsync({
      bundleIdentifier,
      device: props.device,
      shouldStartBundler: props.shouldStartBundler
    });
  } else {
    await IOSDeploy().installOnDeviceAsync({
      bundle: binaryPath,
      appDeltaDirectory: IOSDeploy().getAppDeltaDirectory(bundleIdentifier),
      udid: props.device.udid,
      deviceName: props.device.name
    });
  }

  if (props.shouldStartBundler) {
    _log().default.nested(`\nLogs for your project will appear in the browser console. ${_chalk().default.dim(`Press Ctrl+C to exit.`)}`);
  }
}

async function getBundleIdentifierForBinaryAsync(binaryPath) {
  const builtInfoPlistPath = path().join(binaryPath, 'Info.plist');
  const {
    CFBundleIdentifier
  } = await (0, _binaryPlist().parseBinaryPlistAsync)(builtInfoPlistPath);
  return CFBundleIdentifier;
}

async function openInSimulatorAsync({
  bundleIdentifier,
  device,
  shouldStartBundler
}) {
  let pid = null;
  XcodeBuild().logPrettyItem(`${_chalk().default.bold`Opening`} on ${device.name} ${_chalk().default.dim(`(${bundleIdentifier})`)}`);

  if (shouldStartBundler) {
    await _xdl().Simulator.streamLogsAsync({
      udid: device.udid,
      bundleIdentifier
    });
  }

  const result = await _xdl().SimControl.openBundleIdAsync({
    udid: device.udid,
    bundleIdentifier
  });

  if (result.status === 0) {
    if (result.stdout) {
      var _pidMatch$;

      const pidRegExp = new RegExp(`${bundleIdentifier}:\\s?(\\d+)`);
      const pidMatch = result.stdout.match(pidRegExp);
      pid = (_pidMatch$ = pidMatch === null || pidMatch === void 0 ? void 0 : pidMatch[1]) !== null && _pidMatch$ !== void 0 ? _pidMatch$ : null;
    }

    await _xdl().Simulator.activateSimulatorWindowAsync();
  } else {
    throw new (_CommandError().default)(`Failed to launch the app on simulator ${device.name} (${device.udid}). Error in "osascript" command: ${result.stderr}`);
  }

  return {
    pid
  };
}
//# sourceMappingURL=runIos.js.map
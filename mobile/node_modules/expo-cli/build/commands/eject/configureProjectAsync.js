"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getModdedConfigAsync = getModdedConfigAsync;
exports.logConfig = logConfig;
exports.default = configureManagedProjectAsync;
exports.expoManagedPlugins = void 0;

function _config() {
  const data = require("@expo/config");

  _config = function () {
    return data;
  };

  return data;
}

function _configPlugins() {
  const data = require("@expo/config-plugins");

  _configPlugins = function () {
    return data;
  };

  return data;
}

function _util() {
  const data = _interopRequireDefault(require("util"));

  _util = function () {
    return data;
  };

  return data;
}

function _xdl() {
  const data = require("xdl");

  _xdl = function () {
    return data;
  };

  return data;
}

function _log() {
  const data = _interopRequireDefault(require("../../log"));

  _log = function () {
    return data;
  };

  return data;
}

function _ConfigValidation() {
  const data = require("./ConfigValidation");

  _ConfigValidation = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Expo managed packages that require extra update.
// These get applied automatically to create parity with expo build in eas build.
const expoManagedPlugins = ['expo-app-auth', 'expo-av', 'expo-background-fetch', 'expo-barcode-scanner', 'expo-brightness', 'expo-calendar', 'expo-camera', 'expo-contacts', 'expo-image-picker', 'expo-file-system', 'expo-ads-facebook', 'expo-location', 'expo-media-library', // 'expo-notifications',
'expo-screen-orientation', 'expo-sensors', 'expo-task-manager', 'expo-local-authentication']; // Plugins that need to be automatically applied, but also get applied by expo-cli if the versioned plugin isn't available.
// These are split up because the user doesn't need to be prompted to setup these packages.

exports.expoManagedPlugins = expoManagedPlugins;
const expoManagedVersionedPlugins = [// 'expo-splash-screen',
// 'expo-facebook',
// 'expo-branch',
// 'expo-updates',
// 'expo-ads-admob',
'expo-apple-authentication', 'expo-document-picker', 'expo-firebase-analytics', 'expo-firebase-core', 'expo-google-sign-in' // 'expo-dev-menu',
// 'expo-dev-launcher',
];

const withOptionalPlugins = (config, plugins) => {
  return plugins.reduce((prev, plugin) => {
    return (0, _configPlugins().withStaticPlugin)(prev, {
      // hide errors
      _isLegacyPlugin: true,
      plugin,
      // If a plugin doesn't exist, do nothing.
      fallback: config => config
    });
  }, config);
};

function withManagedPlugins(config) {
  return withOptionalPlugins(config, [...new Set(expoManagedVersionedPlugins.concat(expoManagedPlugins))]);
}

async function getModdedConfigAsync({
  projectRoot,
  platforms,
  bundleIdentifier,
  packageName
}) {
  // let config: ExpoConfig;
  let {
    exp: config,
    ...rest
  } = (0, _config().getConfig)(projectRoot, {
    skipSDKVersionRequirement: true,
    isModdedConfig: true
  });
  const expoUsername = process.env.EAS_BUILD_USERNAME || (await _xdl().UserManager.getCurrentUsernameAsync()); // Add all built-in plugins first because they should take
  // priority over the unversioned plugins.

  config = (0, _configPlugins().withExpoVersionedSDKPlugins)(config, {
    expoUsername
  });
  config = withManagedPlugins(config);

  if (platforms.includes('ios')) {
    var _ref;

    config.ios.bundleIdentifier = (_ref = bundleIdentifier !== null && bundleIdentifier !== void 0 ? bundleIdentifier : config.ios.bundleIdentifier) !== null && _ref !== void 0 ? _ref : 'UNDEFINED (invalid)'; // Add all built-in plugins

    config = (0, _configPlugins().withExpoIOSPlugins)(config, {
      bundleIdentifier: config.ios.bundleIdentifier
    });
  }

  if (platforms.includes('android')) {
    var _ref2, _config$android;

    config.android.package = (_ref2 = packageName !== null && packageName !== void 0 ? packageName : (_config$android = config.android) === null || _config$android === void 0 ? void 0 : _config$android.package) !== null && _ref2 !== void 0 ? _ref2 : 'UNDEFINED (invalid)'; // Add all built-in plugins

    config = (0, _configPlugins().withExpoAndroidPlugins)(config, {
      package: config.android.package
    });
  }

  return {
    exp: config,
    ...rest
  };
}

function logConfig(config) {
  const isObjStr = str => /^\w+: {/g.test(str);

  _log().default.log(_util().default.inspect(config, {
    colors: true,
    compact: false,

    // Sort objects to the end so that smaller values aren't hidden between large objects.
    sorted(a, b) {
      if (isObjStr(a)) return 1;
      if (isObjStr(b)) return -1;
      return 0;
    },

    showHidden: false,
    depth: null
  }));
}

async function configureManagedProjectAsync({
  projectRoot,
  platforms
}) {
  let bundleIdentifier;

  if (platforms.includes('ios')) {
    // Check bundle ID before reading the config because it may mutate the config if the user is prompted to define it.
    bundleIdentifier = await (0, _ConfigValidation().getOrPromptForBundleIdentifier)(projectRoot);
  }

  let packageName;

  if (platforms.includes('android')) {
    // Check package before reading the config because it may mutate the config if the user is prompted to define it.
    packageName = await (0, _ConfigValidation().getOrPromptForPackage)(projectRoot);
  }

  let {
    exp: config
  } = await getModdedConfigAsync({
    projectRoot,
    platforms,
    packageName,
    bundleIdentifier
  }); // compile all plugins and mods

  config = await (0, _configPlugins().compileModsAsync)(config, {
    projectRoot,
    platforms
  });

  if (_log().default.isDebug) {
    _log().default.debug();

    _log().default.debug('Evaluated config:');

    logConfig(config);

    _log().default.debug();
  }

  return config;
}
//# sourceMappingURL=configureProjectAsync.js.map
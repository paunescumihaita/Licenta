"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Formatter = void 0;
const code_frame_1 = require("@babel/code-frame");
const chalk_1 = __importDefault(require("chalk"));
const fs = __importStar(require("fs"));
const os = __importStar(require("os"));
const path = __importStar(require("path"));
const Matchers_1 = require("./Matchers");
const Parser_1 = require("./Parser");
const switchRegex_1 = require("./switchRegex");
var Status;
(function (Status) {
    Status["Pass"] = "pass";
    Status["Fail"] = "fail";
    Status["Pending"] = "pending";
    Status["Error"] = "error";
    Status["Completion"] = "completion";
    Status["Measure"] = "measure";
})(Status || (Status = {}));
const USE_ASCII = false;
const PASS = '✓';
const FAIL = '✗';
const PENDING = '⧖';
const COMPLETION = '\u203A'; //'▸';
const MEASURE = '◷';
const ERROR = USE_ASCII ? '[x]' : '❌ ';
const WARNING = USE_ASCII ? '[!]' : '⚠️ ';
const INDENT = '    ';
const BREADCRUMB = '»';
function format(command, argumentText = '', success = true) {
    const symbol = statusSymbol(success ? Status.Completion : Status.Fail);
    return [symbol, chalk_1.default.bold(command), argumentText].join(' ').trim();
}
function formatTest(testCase, status) {
    return [statusSymbol(status), testCase].join(' ').trim();
}
function heading(prefix, text, description) {
    return [prefix, chalk_1.default.white(text), description].join(' ').trim();
}
function statusSymbol(status) {
    switch (status) {
        case Status.Pass:
            return chalk_1.default.green(PASS);
        case Status.Fail:
            return chalk_1.default.red(FAIL);
        case Status.Pending:
            return chalk_1.default.cyan(PENDING);
        case Status.Error:
            return chalk_1.default.red(ERROR);
        case Status.Completion:
            return chalk_1.default.white(COMPLETION);
        case Status.Measure:
            return chalk_1.default.magenta(MEASURE);
        default:
            return '';
    }
}
function coloredTime(time) {
    const flt = parseFloat(time);
    if (flt >= 0 && flt <= 0.025) {
        return time;
    }
    else if (flt >= 0.026 && flt <= 0.1) {
        return chalk_1.default.yellow(time);
    }
    return chalk_1.default.red(time);
}
function capitalize(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}
function relativePath(projectRoot, filePath) {
    return slash(path.relative(projectRoot, filePath));
}
function formatBreadCrumb(fileName, target, project) {
    // TODO: Simplify
    return [[project, target].filter(Boolean).join(`/`), fileName]
        .filter(Boolean)
        .join(` ${BREADCRUMB} `);
}
class Formatter {
    constructor(props) {
        this.props = props;
        this.errors = [];
        this.warnings = [];
        this.parser = new Parser_1.Parser(this);
    }
    pipe(data) {
        const lines = [];
        data.split(os.EOL).forEach(line => {
            const results = this.parser.parse(line);
            if (typeof results === 'string' && results.trim()) {
                lines.push(results);
            }
        });
        return lines;
    }
    dimConfiguration(configuration) {
        return chalk_1.default.dim(`(${configuration})`);
    }
    formatAnalyze(fileName, filePath, target, project) {
        return format('Analyzing', formatBreadCrumb(fileName, target, project));
    }
    formatBuildTarget(target, project, configuration) {
        return format('Building', this.dimConfiguration(formatBreadCrumb(configuration, target, project)));
    }
    formatAggregateTarget(target, project, configuration) {
        return format('Aggregate', this.dimConfiguration(formatBreadCrumb(configuration, target, project)));
    }
    formatAnalyzeTarget(target, project, configuration) {
        return format('Analyzing', this.dimConfiguration(formatBreadCrumb(configuration, target, project)));
    }
    formatClean(project, target, configuration) {
        return '';
    }
    formatCleanTarget(target, project, configuration) {
        return format('Cleaning', this.dimConfiguration(formatBreadCrumb(configuration, target, project)));
    }
    formatCompile(fileName, filePath, target, project) {
        return format('Compiling', formatBreadCrumb(fileName, target, project));
    }
    formatCompileCommand(compilerCommand, filePath) {
        return '';
    }
    formatCompileStoryboard(fileName, filePath, target, project) {
        return format('Compiling', formatBreadCrumb(fileName, target, project));
    }
    formatCompileXib(fileName, filePath, target, project) {
        return format('Compiling', formatBreadCrumb(fileName, target, project));
    }
    formatCopyHeaderFile(source, target) {
        return format('Copying', path.basename(source));
    }
    formatCopyPlistFile(source, target) {
        return format('Copying', path.basename(source));
    }
    formatCopyStringsFile(filePath, target, project) {
        const relativeFile = relativePath(this.props.projectRoot, filePath);
        return format('Copying', formatBreadCrumb(relativeFile, target, project));
    }
    formatCpresource(filePath) {
        return format('Copying', relativePath(this.props.projectRoot, filePath));
    }
    formatGenerateDsym(dsym, target, project) {
        return format(`Generating debug`, formatBreadCrumb(`'${dsym}'`, target, project));
    }
    formatLinking(file, targetName, arch, target, project) {
        return format('Linking', formatBreadCrumb(file, target, project));
    }
    formatLibtool(library, target, project) {
        return format('Building library', formatBreadCrumb(library, target, project));
    }
    formatPendingTest(suite, test) {
        return INDENT + formatTest(`${test} [PENDING]`, Status.Pending);
    }
    formatPassingTest(suite, test, time) {
        return INDENT + formatTest(`${test} (${coloredTime(time)} seconds)`, Status.Pass);
    }
    formatMeasuringTest(suite, test, time) {
        return INDENT + formatTest(`${test} measured (${coloredTime(time)} seconds)`, Status.Measure);
    }
    formatFailingTest(suite, test, reason, filePath) {
        return INDENT + formatTest(`${test}, ${reason}`, Status.Fail);
    }
    formatProcessPch(fileName, filePath, target, project) {
        return format('Precompiling', formatBreadCrumb(fileName, target, project));
    }
    formatProcessPchCommand(filePath) {
        return '';
    }
    formatPhaseSuccess(phaseName) {
        return format(capitalize(phaseName.toLowerCase()), 'Succeeded', true);
    }
    formatPhaseScriptExecution(scriptName, target, project) {
        return format('Running script', formatBreadCrumb(`'${scriptName}'`, target, project));
    }
    formatProcessInfoPlist(fileName, filePath, target, project) {
        return format('Processing', formatBreadCrumb(fileName, target, project));
    }
    formatCodesign(fileName, filePath, target, project) {
        return format('Signing', formatBreadCrumb(fileName, target, project));
    }
    formatPreprocess(file) {
        return format('Preprocessing', file);
    }
    formatPbxcp(file) {
        return format('Copying', file);
    }
    formatShellCommand(command, args) {
        return '';
    }
    formatTestRunFinished(name, time) {
        return '';
    }
    formatTouch(filePath, fileName) {
        return format('Touching', fileName);
    }
    formatTestRunStarted(name) {
        return heading('Test Suite', name, 'started');
    }
    formatTestSuiteStarted(name) {
        return heading('', name, '');
    }
    formatTiffutil(file) {
        return format('Validating', file);
    }
    formatWriteFile(file) {
        return '';
    }
    formatOther(text) {
        return '';
    }
    formatCheckDependencies(text) {
        return format('Check Dependencies');
    }
    formatCleanRemove(msg) {
        return '';
    }
    formatWriteAuxiliaryFiles(text) {
        return '';
    }
    formatWillNotBeCodeSigned(message) {
        const results = `${chalk_1.default.yellow(WARNING + ' ' + message)}`;
        this.warnings.push(results);
        return results;
    }
    // COMPILER / LINKER ERRORS AND WARNINGS
    /**
     *
     * @param fileName 'SampleTest.m',
     * @param filePathAndLocation '/Users/foo/bar.m:12:59',
     * @param reason 'expected identifier',
     * @param line '                [[thread should] equal:thread.];',
     * @param cursor '                                           ^'
     */
    formatCompileError(fileName, filePathAndLocation, reason, line, cursor) {
        const { filePath, lineNumber, columnNumber } = splitPathInfo(filePathAndLocation);
        const results = formatWarningOrError({
            isError: true,
            filePath,
            reason,
            cursor,
            lineText: line,
            lineNumber,
            columnNumber,
            projectRoot: this.props.projectRoot,
        });
        this.errors.push(results);
        return results;
    }
    formatError(message) {
        const results = `\n${chalk_1.default.red(ERROR + ' ' + message)}\n\n`;
        this.errors.push(results);
        return results;
    }
    formatFileMissingError(reason, filePath) {
        const results = `\n${chalk_1.default.red(ERROR + ' ' + reason)} ${filePath}\n\n`;
        this.errors.push(results);
        return results;
    }
    formatLdWarning(reason) {
        const results = `${chalk_1.default.yellow(WARNING + ' ' + reason)}`;
        this.warnings.push(results);
        return results;
    }
    formatUndefinedSymbols(message, symbol, reference) {
        const symbols = chalk_1.default.gray(`┌─ Symbol: ${symbol}\n└─ Referenced from: ${reference}`);
        const results = `${chalk_1.default.red(ERROR + ' ' + message)}\n${symbols}\n`;
        this.errors.push(results);
        return results;
    }
    formatDuplicateSymbols(message, filePaths, isWarning) {
        const formattedMessage = isWarning
            ? chalk_1.default.yellow(WARNING + ' ' + message)
            : chalk_1.default.red(ERROR + ' ' + message);
        const symbols = chalk_1.default.gray(filePaths
            .map((p, i) => {
            const branch = i === filePaths.length - 1 ? '└─' : i === 0 ? '┌─' : '├─';
            return `${branch} ${path.basename(p)}`;
        })
            .join('\n'));
        const results = `${formattedMessage}\n${symbols}\n`;
        if (isWarning) {
            this.warnings.push(results);
        }
        else {
            this.errors.push(results);
        }
        return results;
    }
    /**
     * In: `The iOS Simulator deployment target 'IPHONEOS_DEPLOYMENT_TARGET' is set to 8.0, but the range of supported deployment target versions is 9.0 to 14.3.99. (in target 'boost-for-react-native' from project 'Pods')`
     * Out: `⚠️ Pods/boost-for-react-native: iOS@8.0 version mismatch. Expected >= 9.0 < 14.3.99`
     *
     * @param os iOS
     * @param deploymentTarget IPHONEOS_DEPLOYMENT_TARGET
     * @param version 8.0
     * @param minVersion 9.0
     * @param maxVersion 14.3.99
     * @param target boost-for-react-native
     * @param project Pods
     */
    formatVersionMismatchWarning(os, deploymentTarget, version, minVersion, maxVersion, target, project) {
        const packageName = [project, target].join('/');
        const platform = chalk_1.default.bold(`${packageName}:`);
        const packageNameWithVersion = chalk_1.default.greenBright(os) + chalk_1.default.cyan `@` + chalk_1.default.magenta(version);
        const expectedRange = `>= ${minVersion} <= ${maxVersion}`;
        return `${WARNING} ${platform} ${packageNameWithVersion} deployment version mismatch, expected ${expectedRange}`;
    }
    /**
     * In: `Skipping duplicate build file in Compile Sources build phase: /Users/evanbacon/Documents/GitHub/expo/ios/Exponent/Kernel/ReactAppManager/EXReactAppManager.mm (in target 'Exponent' from project 'Exponent')`
     * Out:
     * `⚠️ Skipping duplicate file: Exponent/Kernel/ReactAppManager/EXReactAppManager.mm:
     *    Remove: Exponent » Exponent » Build Phases » Compile Sources » EXReactAppManager.mm`
     *
     * @param filePath
     * @param buildPhase 'Compile Sources'
     * @param target Exponent-watch-app
     * @param project Exponent
     */
    formatDuplicateFileCompilerWarning(filePath, buildPhase, target, project) {
        const message = `${chalk_1.default.yellow `Skipping duplicate file:`} ${relativePath(this.props.projectRoot, filePath)}`;
        const fileName = path.basename(filePath);
        const crumbs = chalk_1.default.gray('Remove: ' +
            ['Xcode', `${project}/${target}`, 'Build Phases', buildPhase, fileName].join(` ${BREADCRUMB} `));
        return `${WARNING} ${message}\n   ${crumbs}\n`;
    }
    /**
     * In: `The Copy Bundle Resources build phase contains this target's Info.plist file '/Users/evanbacon/Documents/GitHub/expo/ios/Exponent/Supporting/Info.plist'. (in target 'Exponent' from project 'Exponent')`
     * Out:
     * `⚠️ Target's Info.plist file is incorrectly linked: Exponent/Supporting/Info.plist:
     *    Remove: Exponent » Exponent » Build Phases » Copy Bundle Resources » Info.plist`
     *
     * @param filePath
     * @param reservedFileDescription 'entitlements'
     * @param target Exponent-watch-app
     * @param project Exponent
     */
    formatReservedFileInCopyBundleResourcesCompilerWarning(filePath, reservedFileDescription, target, project) {
        const message = `${chalk_1.default.yellow `Target's ${chalk_1.default.bold(reservedFileDescription)} file is incorrectly linked:`} ${relativePath(this.props.projectRoot, filePath)}`;
        const fileName = path.basename(filePath);
        const crumbs = chalk_1.default.gray('Remove: ' +
            ['Xcode', `${project}/${target}`, 'Build Phases', 'Copy Bundle Resources', fileName].join(` ${BREADCRUMB} `));
        return `${WARNING} ${message}\n   ${crumbs}\n`;
    }
    formatMissingFileCompilerWarning(filePath) {
        return `${WARNING} ${chalk_1.default.yellow `No such file or directory:`} ${filePath}`;
    }
    formatGenericWarning(message) {
        return INDENT + chalk_1.default.yellow(message);
    }
    formatWarning(message) {
        const results = switchRegex_1.switchRegex(message, [
            [
                Matchers_1.Matchers.Warnings.VERSION_MISMATCH,
                ([, $1, $2, $3, $4, $5, $6, $7]) => {
                    return this.formatVersionMismatchWarning($1, $2, $3, $4, $5, $6, $7);
                },
            ],
            [
                Matchers_1.Matchers.Warnings.MISSING_FILE_COMPILER_WARNING_MATCHER,
                ([, $1]) => {
                    return this.formatMissingFileCompilerWarning($1);
                },
            ],
            [
                Matchers_1.Matchers.Warnings.SKIPPING_DUPLICATE_FILE,
                ([, $1, $2, $3, $4]) => {
                    return this.formatDuplicateFileCompilerWarning($2, $1, $3, $4);
                },
            ],
            [
                Matchers_1.Matchers.Warnings.TARGETS_FILE_INCLUDED,
                ([, $1, $2, $3, $4]) => {
                    return this.formatReservedFileInCopyBundleResourcesCompilerWarning($2, $1, $3, $4);
                },
            ],
            [null, () => this.formatGenericWarning(message)],
        ]);
        this.warnings.push(results);
        return results;
    }
    // TODO: see how we can unify formatError and formatCompileError,
    //       the same for warnings
    formatCompileWarning(fileName, filePathAndLocation, reason, line, cursor) {
        const { filePath, lineNumber, columnNumber } = splitPathInfo(filePathAndLocation);
        if (this.shouldShowCompileWarning(filePath, lineNumber, columnNumber)) {
            const results = formatWarningOrError({
                isError: false,
                filePath,
                reason,
                cursor,
                lineText: line,
                lineNumber,
                columnNumber,
                projectRoot: this.props.projectRoot,
            });
            this.warnings.push(results);
            return results;
        }
        return '';
    }
    shouldShowCompileWarning(filePath, lineNumber, columnNumber) {
        return true;
    }
    finish() { }
    // Override if you want to catch something specific with your regex
    prettyFormat(text) {
        return this.parser.parse(text);
    }
    // If you want to print inline, override #optionalNewline with ''
    optionalNewline() {
        return '\n';
    }
    // Will be printed by default. Override with '' if you don't want summary
    formatTestSummary(executedMessage, failuresPerSuite) {
        const failures = this.formatFailures(failuresPerSuite);
        let finalMessage = '';
        if (!failures) {
            finalMessage = chalk_1.default.green(executedMessage);
        }
        else {
            finalMessage = chalk_1.default.red(executedMessage);
        }
        const text = [failures, finalMessage].join('\n\n\n').trim();
        return `\n\n${text}`;
    }
    formatFailures(failuresPerSuite) {
        return Object.entries(failuresPerSuite)
            .map(([suite, failures]) => {
            const formattedFailures = failures.map(failure => this.formatFailure(failure)).join('\n\n');
            return `\n${suite}\n${formattedFailures}`;
        })
            .join('\n');
    }
    formatFailure(f) {
        const { filePath, lineNumber, columnNumber } = splitPathInfo(f.filePath);
        return formatWarningOrError({
            isError: true,
            testName: f.testCase,
            filePath,
            reason: f.reason,
            // cursor,
            lineNumber,
            columnNumber,
            projectRoot: this.props.projectRoot,
        });
    }
}
exports.Formatter = Formatter;
Formatter.format = format;
Formatter.formatBreadCrumb = formatBreadCrumb;
function formatPaths(config) {
    const filePath = chalk_1.default.reset.cyan(config.filePath);
    return (chalk_1.default.dim('(') +
        filePath +
        chalk_1.default.dim(`:${[config.line, config.col].filter(Boolean).join(':')})`));
}
/**
 * Split a string like `/Users/foo/bar.m:420:68` into its components.
 *
 * @param filePath '/Users/foo/bar.m:420:68'
 */
function splitPathInfo(filePathAndLocation) {
    const [path, line, column] = filePathAndLocation.split(':');
    return {
        filePath: path || filePathAndLocation,
        lineNumber: line,
        columnNumber: column,
    };
}
function parseOptionalInt(text) {
    if (!text)
        return undefined;
    try {
        return parseInt(text, 10);
    }
    catch {
        return undefined;
    }
}
function formatWarningOrError({ filePath, reason, cursor, lineText, lineNumber, columnNumber, projectRoot, isError, }) {
    // TODO: Use testName for errors
    const line = parseOptionalInt(lineNumber) || 0;
    const column = parseOptionalInt(columnNumber);
    const color = isError ? chalk_1.default.red : chalk_1.default.yellow;
    const icon = color(isError ? ERROR : WARNING);
    try {
        const raw = fs.readFileSync(filePath, 'utf8');
        const location = { start: { line, column } };
        const framed = code_frame_1.codeFrameColumns(raw, location, {
            // TODO: Support iOS languages: C++, Objc, swift, Ruby, Bash
            // Maybe something like prism but for terminals?
            highlightCode: false,
            // Remove `(_Nonnull, _Nullable, or _Null_unspecified)` options
            message: color(grayOutMatch(reason, /(\[-.*?\])/).replace(/(\(.*?\)\s?)/, '')),
        });
        const relativeFilePath = filePath ? slash(path.relative(projectRoot, filePath)) : null;
        const formattedPath = formatPaths({
            filePath: relativeFilePath,
            col: column,
            line,
        });
        return `\n${icon} ${formattedPath}\n\n${framed}\n`;
    }
    catch {
        // TODO: Format legacy like JS
        return `\n${icon} ${filePath}: ${color(reason)}\n\n${lineText}\n${chalk_1.default.cyan(cursor)}\n`;
    }
}
// Dim values like `[-Wnullability-completeness]`
function grayOutMatch(text, reg) {
    return replaceMatch(text, reg, chalk_1.default.gray.dim);
}
function replaceMatch(text, reg, callback) {
    const match = text.match(reg);
    if (match === null || match === void 0 ? void 0 : match.length) {
        return text.replace(reg, callback(match[0]));
    }
    return text;
}
function slash(path) {
    const isExtendedLengthPath = /^\\\\\?\\/.test(path);
    const hasNonAscii = /[^\u0000-\u0080]+/.test(path); // eslint-disable-line no-control-regex
    if (isExtendedLengthPath || hasNonAscii) {
        return path;
    }
    return path.replace(/\\/g, '/');
}
//# sourceMappingURL=Formatter.js.map